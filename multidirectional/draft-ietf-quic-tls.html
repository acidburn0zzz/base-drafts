<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Using Transport Layer Security (TLS) to Secure QUIC</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Notational Conventions"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Protocol Overview"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 TLS Overview"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 TLS Handshake"/>
<link href="#rfc.section.4" rel="Chapter" title="4 TLS Usage"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Handshake and Setup Sequence"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Interface to TLS"/>
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Handshake Interface"/>
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Source Address Validation"/>
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 Key Ready Events"/>
<link href="#rfc.section.4.2.4" rel="Chapter" title="4.2.4 Secret Export"/>
<link href="#rfc.section.4.2.5" rel="Chapter" title="4.2.5 TLS Interface Summary"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 TLS Version"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 ClientHello Size"/>
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Peer Authentication"/>
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 TLS Errors"/>
<link href="#rfc.section.5" rel="Chapter" title="5 QUIC Packet Protection"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Installing New Keys"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 QUIC Key Expansion"/>
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 0-RTT Secret"/>
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 1-RTT Secrets"/>
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 Packet Protection Key and IV"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 QUIC AEAD Usage"/>
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Packet Numbers"/>
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Receiving Protected Packets"/>
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Packet Number Gaps"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Unprotected Packets"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Integrity Check Processing"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 The 64-bit FNV-1a Algorithm"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Key Phases"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Packet Protection for the TLS Handshake"/>
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Initial Key Transitions"/>
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 Retransmission and Acknowledgment of Unprotected Packets"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Key Update"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Client Address Validation"/>
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 HelloRetryRequest Address Validation"/>
<link href="#rfc.section.8.1.1" rel="Chapter" title="8.1.1 Stateless Address Validation"/>
<link href="#rfc.section.8.1.2" rel="Chapter" title="8.1.2 Sending HelloRetryRequest"/>
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 NewSessionTicket Address Validation"/>
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Address Validation Token Integrity"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Pre-handshake QUIC Messages"/>
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Unprotected Packets Prior to Handshake Completion"/>
<link href="#rfc.section.9.1.1" rel="Chapter" title="9.1.1 STREAM Frames"/>
<link href="#rfc.section.9.1.2" rel="Chapter" title="9.1.2 ACK Frames"/>
<link href="#rfc.section.9.1.3" rel="Chapter" title="9.1.3 Updates to Data and Stream Limits"/>
<link href="#rfc.section.9.1.4" rel="Chapter" title="9.1.4 Denial of Service with Unprotected Packets"/>
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Use of 0-RTT Keys"/>
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Receiving Out-of-Order Protected Frames"/>
<link href="#rfc.section.10" rel="Chapter" title="10 QUIC-Specific Additions to the TLS Handshake"/>
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Protocol and Version Negotiation"/>
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 QUIC Transport Parameters Extension"/>
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Priming 0-RTT"/>
<link href="#rfc.section.11" rel="Chapter" title="11 Security Considerations"/>
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 Packet Reflection Attack Mitigation"/>
<link href="#rfc.section.11.2" rel="Chapter" title="11.2 Peer Denial of Service"/>
<link href="#rfc.section.12" rel="Chapter" title="12 Error codes"/>
<link href="#rfc.section.13" rel="Chapter" title="13 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="14 References"/>
<link href="#rfc.references.1" rel="Chapter" title="14.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="14.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Contributors"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Acknowledgments"/>
<link href="#rfc.appendix.C" rel="Chapter" title="C Change Log"/>
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Since draft-ietf-quic-tls-02"/>
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Since draft-ietf-quic-tls-01"/>
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 Since draft-ietf-quic-tls-00"/>
<link href="#rfc.appendix.C.4" rel="Chapter" title="C.4 Since draft-thomson-quic-tls-01"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Thomson, M., Ed. and S. Turner, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-tls-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-6-28" />
  <meta name="dct.abstract" content="This document describes how Transport Layer Security (TLS) is used to secure QUIC." />
  <meta name="description" content="This document describes how Transport Layer Security (TLS) is used to secure QUIC." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">QUIC</td>
  <td class="right">M. Thomson, Ed.</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Mozilla</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">S. Turner, Ed.</td>
</tr>
<tr>
  <td class="left">Expires: December 30, 2017</td>
  <td class="right">sn3rd</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">June 28, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Using Transport Layer Security (TLS) to Secure QUIC<br />
  <span class="filename">draft-ietf-quic-tls-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes how Transport Layer Security (TLS) is used to secure QUIC.</p>
<h1>
  <a>Note to Readers</a>
</h1>
<p>Discussion of this draft takes place on the QUIC working group mailing list (quic@ietf.org), which is archived at <a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a>.</p>
<p>Working Group information can be found at <a href="https://github.com/quicwg">https://github.com/quicwg</a>; source code and issues list for this draft can be found at <a href="https://github.com/quicwg/base-drafts/labels/tls">https://github.com/quicwg/base-drafts/labels/tls</a>.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 30, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Notational Conventions</a></li>
<li>3.   <a href="#rfc.section.3">Protocol Overview</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">TLS Overview</a></li>
<li>3.2.   <a href="#rfc.section.3.2">TLS Handshake</a></li>
</ul><li>4.   <a href="#rfc.section.4">TLS Usage</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Handshake and Setup Sequence</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Interface to TLS</a></li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">Handshake Interface</a></li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Source Address Validation</a></li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">Key Ready Events</a></li>
<li>4.2.4.   <a href="#rfc.section.4.2.4">Secret Export</a></li>
<li>4.2.5.   <a href="#rfc.section.4.2.5">TLS Interface Summary</a></li>
</ul><li>4.3.   <a href="#rfc.section.4.3">TLS Version</a></li>
<li>4.4.   <a href="#rfc.section.4.4">ClientHello Size</a></li>
<li>4.5.   <a href="#rfc.section.4.5">Peer Authentication</a></li>
<li>4.6.   <a href="#rfc.section.4.6">TLS Errors</a></li>
</ul><li>5.   <a href="#rfc.section.5">QUIC Packet Protection</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Installing New Keys</a></li>
<li>5.2.   <a href="#rfc.section.5.2">QUIC Key Expansion</a></li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">0-RTT Secret</a></li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">1-RTT Secrets</a></li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">Packet Protection Key and IV</a></li>
</ul><li>5.3.   <a href="#rfc.section.5.3">QUIC AEAD Usage</a></li>
<li>5.4.   <a href="#rfc.section.5.4">Packet Numbers</a></li>
<li>5.5.   <a href="#rfc.section.5.5">Receiving Protected Packets</a></li>
<li>5.6.   <a href="#rfc.section.5.6">Packet Number Gaps</a></li>
</ul><li>6.   <a href="#rfc.section.6">Unprotected Packets</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Integrity Check Processing</a></li>
<li>6.2.   <a href="#rfc.section.6.2">The 64-bit FNV-1a Algorithm</a></li>
</ul><li>7.   <a href="#rfc.section.7">Key Phases</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Packet Protection for the TLS Handshake</a></li>
<ul><li>7.1.1.   <a href="#rfc.section.7.1.1">Initial Key Transitions</a></li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">Retransmission and Acknowledgment of Unprotected Packets</a></li>
</ul><li>7.2.   <a href="#rfc.section.7.2">Key Update</a></li>
</ul><li>8.   <a href="#rfc.section.8">Client Address Validation</a></li>
<ul><li>8.1.   <a href="#rfc.section.8.1">HelloRetryRequest Address Validation</a></li>
<ul><li>8.1.1.   <a href="#rfc.section.8.1.1">Stateless Address Validation</a></li>
<li>8.1.2.   <a href="#rfc.section.8.1.2">Sending HelloRetryRequest</a></li>
</ul><li>8.2.   <a href="#rfc.section.8.2">NewSessionTicket Address Validation</a></li>
<li>8.3.   <a href="#rfc.section.8.3">Address Validation Token Integrity</a></li>
</ul><li>9.   <a href="#rfc.section.9">Pre-handshake QUIC Messages</a></li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Unprotected Packets Prior to Handshake Completion</a></li>
<ul><li>9.1.1.   <a href="#rfc.section.9.1.1">STREAM Frames</a></li>
<li>9.1.2.   <a href="#rfc.section.9.1.2">ACK Frames</a></li>
<li>9.1.3.   <a href="#rfc.section.9.1.3">Updates to Data and Stream Limits</a></li>
<li>9.1.4.   <a href="#rfc.section.9.1.4">Denial of Service with Unprotected Packets</a></li>
</ul><li>9.2.   <a href="#rfc.section.9.2">Use of 0-RTT Keys</a></li>
<li>9.3.   <a href="#rfc.section.9.3">Receiving Out-of-Order Protected Frames</a></li>
</ul><li>10.   <a href="#rfc.section.10">QUIC-Specific Additions to the TLS Handshake</a></li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Protocol and Version Negotiation</a></li>
<li>10.2.   <a href="#rfc.section.10.2">QUIC Transport Parameters Extension</a></li>
<li>10.3.   <a href="#rfc.section.10.3">Priming 0-RTT</a></li>
</ul><li>11.   <a href="#rfc.section.11">Security Considerations</a></li>
<ul><li>11.1.   <a href="#rfc.section.11.1">Packet Reflection Attack Mitigation</a></li>
<li>11.2.   <a href="#rfc.section.11.2">Peer Denial of Service</a></li>
</ul><li>12.   <a href="#rfc.section.12">Error codes</a></li>
<li>13.   <a href="#rfc.section.13">IANA Considerations</a></li>
<li>14.   <a href="#rfc.references">References</a></li>
<ul><li>14.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>14.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Contributors</a></li>
<li>Appendix B.   <a href="#rfc.appendix.B">Acknowledgments</a></li>
<li>Appendix C.   <a href="#rfc.appendix.C">Change Log</a></li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Since draft-ietf-quic-tls-02</a></li>
<li>C.2.   <a href="#rfc.appendix.C.2">Since draft-ietf-quic-tls-01</a></li>
<li>C.3.   <a href="#rfc.appendix.C.3">Since draft-ietf-quic-tls-00</a></li>
<li>C.4.   <a href="#rfc.appendix.C.4">Since draft-thomson-quic-tls-01</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">This document describes how QUIC <a href="#QUIC-TRANSPORT">[QUIC-TRANSPORT]</a> is secured using Transport Layer Security (TLS) version 1.3 <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>.  TLS 1.3 provides critical latency improvements for connection establishment over previous versions.  Absent packet loss, most new connections can be established and secured within a single round trip; on subsequent connections between the same client and server, the client can often send application data immediately, that is, using a zero round trip setup.</p>
<p id="rfc.section.1.p.2">This document describes how the standardized TLS 1.3 acts a security component of QUIC.  The same design could work for TLS 1.2, though few of the benefits QUIC provides would be realized due to the handshake latency in versions of TLS prior to 1.3.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a></h1>
<p id="rfc.section.2.p.1">The words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221;, and &#8220;MAY&#8221; are used in this document.  It&#8217;s not shouting; when they are capitalized, they have the special meaning defined in <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.2.p.2">This document uses the terminology established in <a href="#QUIC-TRANSPORT">[QUIC-TRANSPORT]</a>.</p>
<p id="rfc.section.2.p.3">For brevity, the acronym TLS is used to refer to TLS 1.3.</p>
<p id="rfc.section.2.p.4">TLS terminology is used when referring to parts of TLS. Though TLS assumes a continuous stream of octets, it divides that stream into <em>records</em>. Most relevant to QUIC are the records that contain TLS <em>handshake messages</em>, which are discrete messages that are used for key agreement, authentication and parameter negotiation. Ordinarily, TLS records can also contain <em>application data</em>, though in the QUIC usage there is no use of TLS application data.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#protocol-overview" id="protocol-overview">Protocol Overview</a></h1>
<p id="rfc.section.3.p.1">QUIC <a href="#QUIC-TRANSPORT">[QUIC-TRANSPORT]</a> assumes responsibility for the confidentiality and integrity protection of packets.  For this it uses keys derived from a TLS 1.3 connection <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>; QUIC also relies on TLS 1.3 for authentication and negotiation of parameters that are critical to security and performance.</p>
<p id="rfc.section.3.p.2">Rather than a strict layering, these two protocols are co-dependent: QUIC uses the TLS handshake; TLS uses the reliability and ordered delivery provided by QUIC streams.</p>
<p id="rfc.section.3.p.3">This document defines how QUIC interacts with TLS.  This includes a description of how TLS is used, how keying material is derived from TLS, and the application of that keying material to protect QUIC packets.  <a href="#schematic">Figure 1</a> shows the basic interactions between TLS and QUIC, with the QUIC packet protection being called out specially.</p>
<div id="rfc.figure.1"/>
<div id="schematic"/>
<pre>
+------------+                        +------------+
|            |------ Handshake ------&gt;|            |
|            |&lt;-- Validate Address ---|            |
|            |-- OK/Error/Validate --&gt;|            |
|            |&lt;----- Handshake -------|            |
|   QUIC     |------ Validate -------&gt;|    TLS     |
|            |                        |            |
|            |&lt;------ 0-RTT OK -------|            |
|            |&lt;------ 1-RTT OK -------|            |
|            |&lt;--- Handshake Done ----|            |
+------------+                        +------------+
 |         ^                               ^ |
 | Protect | Protected                     | |
 v         | Packet                        | |
+------------+                             / /
|   QUIC     |                            / /
|  Packet    |-------- Get Secret -------' /
| Protection |&lt;-------- Secret -----------'
+------------+
</pre>
<p class="figure">Figure 1: QUIC and TLS Interactions</p>
<p id="rfc.section.3.p.4">The initial state of a QUIC connection has packets exchanged without any form of protection.  In this state, QUIC is limited to using stream 0 and associated packets.  Stream 0 is reserved for a TLS connection.  This is a complete TLS connection as it would appear when layered over TCP; the only difference is that QUIC provides the reliability and ordering that would otherwise be provided by TCP.</p>
<p id="rfc.section.3.p.5">At certain points during the TLS handshake, keying material is exported from the TLS connection for use by QUIC.  This keying material is used to derive packet protection keys.  Details on how and when keys are derived and used are included in <a href="#packet-protection">Section 5</a>.</p>
<h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#tls-overview" id="tls-overview">TLS Overview</a></h2>
<p id="rfc.section.3.1.p.1">TLS provides two endpoints with a way to establish a means of communication over an untrusted medium (that is, the Internet) that ensures that messages they exchange cannot be observed, modified, or forged.</p>
<p id="rfc.section.3.1.p.2">TLS features can be separated into two basic functions: an authenticated key exchange and record protection.  QUIC primarily uses the authenticated key exchange provided by TLS but provides its own packet protection.</p>
<p id="rfc.section.3.1.p.3">The TLS authenticated key exchange occurs between two entities: client and server.  The client initiates the exchange and the server responds.  If the key exchange completes successfully, both client and server will agree on a secret.  TLS supports both pre-shared key (PSK) and Diffie-Hellman (DH) key exchanges.  PSK is the basis for 0-RTT; the latter provides perfect forward secrecy (PFS) when the DH keys are destroyed.</p>
<p id="rfc.section.3.1.p.4">After completing the TLS handshake, the client will have learned and authenticated an identity for the server and the server is optionally able to learn and authenticate an identity for the client.  TLS supports X.509 <a href="#RFC5280">[RFC5280]</a> certificate-based authentication for both server and client.</p>
<p id="rfc.section.3.1.p.5">The TLS key exchange is resistent to tampering by attackers and it produces shared secrets that cannot be controlled by either participating peer.</p>
<h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#tls-handshake" id="tls-handshake">TLS Handshake</a></h2>
<p id="rfc.section.3.2.p.1">TLS 1.3 provides two basic handshake modes of interest to QUIC:</p>
<p/>

<ul>
  <li>A full 1-RTT handshake in which the client is able to send application data after one round trip and the server immediately after receiving the first handshake message from the client.</li>
  <li>A 0-RTT handshake in which the client uses information it has previously learned about the server to send application data immediately.  This application data can be replayed by an attacker so it MUST NOT carry a self-contained trigger for any non-idempotent action.</li>
</ul>
<p id="rfc.section.3.2.p.3">A simplified TLS 1.3 handshake with 0-RTT application data is shown in <a href="#tls-full">Figure 2</a>, see <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> for more options and details.</p>
<div id="rfc.figure.2"/>
<div id="tls-full"/>
<pre>
    Client                                             Server

    ClientHello
   (0-RTT Application Data)  --------&gt;
                                                  ServerHello
                                         {EncryptedExtensions}
                                                    {Finished}
                             &lt;--------      [Application Data]
   (EndOfEarlyData)
   {Finished}                --------&gt;

   [Application Data]        &lt;-------&gt;      [Application Data]
</pre>
<p class="figure">Figure 2: TLS Handshake with 0-RTT</p>
<p id="rfc.section.3.2.p.4">This 0-RTT handshake is only possible if the client and server have previously communicated.  In the 1-RTT handshake, the client is unable to send protected application data until it has received all of the handshake messages sent by the server.</p>
<p id="rfc.section.3.2.p.5">Two additional variations on this basic handshake exchange are relevant to this document:</p>
<p/>

<ul>
  <li>The server can respond to a ClientHello with a HelloRetryRequest, which adds an additional round trip prior to the basic exchange.  This is needed if the server wishes to request a different key exchange key from the client.  HelloRetryRequest is also used to verify that the client is correctly able to receive packets on the address it claims to have (see <a href="#QUIC-TRANSPORT">[QUIC-TRANSPORT]</a>).</li>
  <li>A pre-shared key mode can be used for subsequent handshakes to reduce the number of public key operations.  This is the basis for 0-RTT data, even if the remainder of the connection is protected by a new Diffie-Hellman exchange.</li>
</ul>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#tls-usage" id="tls-usage">TLS Usage</a></h1>
<p id="rfc.section.4.p.1">QUIC reserves stream 0 for a TLS connection.  Stream 0 contains a complete TLS connection, which includes the TLS record layer.  Other than the definition of a QUIC-specific extension (see <a href="#quic_parameters">Section 10.2</a>), TLS is unmodified for this use.  This means that TLS will apply confidentiality and integrity protection to its records.  In particular, TLS record protection is what provides confidentiality protection for the TLS handshake messages sent by the server.</p>
<p id="rfc.section.4.p.2">QUIC permits a client to send frames on streams starting from the first packet.  The initial packet from a client contains a stream frame for stream 0 that contains the first TLS handshake messages from the client.  This allows the TLS handshake to start with the first packet that a client sends.</p>
<p id="rfc.section.4.p.3">QUIC packets are protected using a scheme that is specific to QUIC, see <a href="#packet-protection">Section 5</a>.  Keys are exported from the TLS connection when they become available using a TLS exporter (see Section 7.5 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> and <a href="#key-expansion">Section 5.2</a>).  After keys are exported from TLS, QUIC manages its own key schedule.</p>
<h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#handshake-and-setup-sequence" id="handshake-and-setup-sequence">Handshake and Setup Sequence</a></h2>
<p id="rfc.section.4.1.p.1">The integration of QUIC with a TLS handshake is shown in more detail in <a href="#quic-tls-handshake">Figure 3</a>.  QUIC <samp>STREAM</samp> frames on stream 0 carry the TLS handshake.  QUIC performs loss recovery <a href="#QUIC-RECOVERY">[QUIC-RECOVERY]</a> for this stream and ensures that TLS handshake messages are delivered in the correct order.</p>
<div id="rfc.figure.3"/>
<div id="quic-tls-handshake"/>
<pre>
    Client                                             Server

@C QUIC STREAM Frame(s) &lt;0&gt;:
     ClientHello
       + QUIC Extension
                            --------&gt;
                        0-RTT Key =&gt; @0

@0 QUIC STREAM Frame(s) &lt;any stream&gt;:
   Replayable QUIC Frames
                            --------&gt;

                                      QUIC STREAM Frame &lt;0&gt;: @C
                                               ServerHello
                                  {TLS Handshake Messages}
                            &lt;--------
                        1-RTT Key =&gt; @1

                                           QUIC Frames &lt;any&gt; @1
                            &lt;--------
@C QUIC STREAM Frame(s) &lt;0&gt;:
     (EndOfEarlyData)
     {Finished}
                            --------&gt;

@1 QUIC Frames &lt;any&gt;        &lt;-------&gt;      QUIC Frames &lt;any&gt; @1
</pre>
<p class="figure">Figure 3: QUIC over TLS Handshake</p>
<p id="rfc.section.4.1.p.2">In <a href="#quic-tls-handshake">Figure 3</a>, symbols mean:</p>
<p/>

<ul>
  <li>&#8221;&lt;&#8221; and &#8220;&gt;&#8221; enclose stream numbers.</li>
  <li>&#8221;@&#8221; indicates the keys that are used for protecting the QUIC packet (C = cleartext, with integrity only; 0 = 0-RTT keys; 1 = 1-RTT keys).</li>
  <li>&#8221;(&#8220; and &#8220;)&#8221; enclose messages that are protected with TLS 0-RTT handshake or application keys.</li>
  <li>&#8221;{&#8220; and &#8220;}&#8221; enclose messages that are protected by the TLS Handshake keys.</li>
</ul>
<p id="rfc.section.4.1.p.4">If 0-RTT is not attempted, then the client does not send packets protected by the 0-RTT key (@0).  In that case, the only key transition on the client is from cleartext packets (@C) to 1-RTT protection (@1), which happens after it sends its final set of TLS handshake messages.</p>
<p id="rfc.section.4.1.p.5">Note: the client uses two different types of cleartext packet during the handshake.  The Client Initial packet carries a TLS ClientHello message; the remainder of the TLS handshake is carried in Client Cleartext packets.</p>
<p id="rfc.section.4.1.p.6">The server sends TLS handshake messages without protection (@C).  The server transitions from no protection (@C) to full 1-RTT protection (@1) after it sends the last of its handshake messages.</p>
<p id="rfc.section.4.1.p.7">Some TLS handshake messages are protected by the TLS handshake record protection.  These keys are not exported from the TLS connection for use in QUIC.  QUIC packets from the server are sent in the clear until the final transition to 1-RTT keys.</p>
<p id="rfc.section.4.1.p.8">The client transitions from cleartext (@C) to 0-RTT keys (@0) when sending 0-RTT data, and subsequently to to 1-RTT keys (@1) after its second flight of TLS handshake messages.  This creates the potential for unprotected packets to be received by a server in close proximity to packets that are protected with 1-RTT keys.</p>
<p id="rfc.section.4.1.p.9">More information on key transitions is included in <a href="#cleartext-hs">Section 7.1</a>.</p>
<h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#interface-to-tls" id="interface-to-tls">Interface to TLS</a></h2>
<p id="rfc.section.4.2.p.1">As shown in <a href="#schematic">Figure 1</a>, the interface from QUIC to TLS consists of four primary functions: Handshake, Source Address Validation, Key Ready Events, and Secret Export.</p>
<p id="rfc.section.4.2.p.2">Additional functions might be needed to configure TLS.</p>
<h3 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#handshake-interface" id="handshake-interface">Handshake Interface</a></h3>
<p id="rfc.section.4.2.1.p.1">In order to drive the handshake, TLS depends on being able to send and receive handshake messages on stream 0.  There are two basic functions on this interface: one where QUIC requests handshake messages and one where QUIC provides handshake packets.</p>
<p id="rfc.section.4.2.1.p.2">Before starting the handshake QUIC provides TLS with the transport parameters (see <a href="#quic_parameters">Section 10.2</a>) that it wishes to carry.</p>
<p id="rfc.section.4.2.1.p.3">A QUIC client starts TLS by requesting TLS handshake octets from TLS.  The client acquires handshake octets before sending its first packet.</p>
<p id="rfc.section.4.2.1.p.4">A QUIC server starts the process by providing TLS with stream 0 octets.</p>
<p id="rfc.section.4.2.1.p.5">Each time that an endpoint receives data on stream 0, it delivers the octets to TLS if it is able.  Each time that TLS is provided with new data, new handshake octets are requested from TLS.  TLS might not provide any octets if the handshake messages it has received are incomplete or it has no data to send.</p>
<p id="rfc.section.4.2.1.p.6">Once the TLS handshake is complete, this is indicated to QUIC along with any final handshake octets that TLS needs to send.  TLS also provides QUIC with the transport parameters that the peer advertised during the handshake.</p>
<p id="rfc.section.4.2.1.p.7">Once the handshake is complete, TLS becomes passive.  TLS can still receive data from its peer and respond in kind, but it will not need to send more data unless specifically requested - either by an application or QUIC.  One reason to send data is that the server might wish to provide additional or updated session tickets to a client.</p>
<p id="rfc.section.4.2.1.p.8">When the handshake is complete, QUIC only needs to provide TLS with any data that arrives on stream 0.  In the same way that is done during the handshake, new data is requested from TLS after providing received data.</p>
<p/>

<dl>
  <dt>Important:</dt>
  <dd style="margin-left: 8">Until the handshake is reported as complete, the connection and key exchange are not properly authenticated at the server.  Even though 1-RTT keys are available to a server after receiving the first handshake messages from a client, the server cannot consider the client to be authenticated until it receives and validates the client&#8217;s Finished message.</dd>
  <dt></dt>
  <dd style="margin-left: 8">The requirement for the server to wait for the client Finished message creates a dependency on that message being delivered.  A client can avoid the potential for head-of-line blocking that this implies by sending a copy of the STREAM frame that carries the Finished message in multiple packets.  This enables immediate server processing for those packets.</dd>
</dl>
<h3 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#source-address-validation" id="source-address-validation">Source Address Validation</a></h3>
<p id="rfc.section.4.2.2.p.1">During the processing of the TLS ClientHello, TLS requests that the transport make a decision about whether to request source address validation from the client.</p>
<p id="rfc.section.4.2.2.p.2">An initial TLS ClientHello that resumes a session includes an address validation token in the session ticket; this includes all attempts at 0-RTT.  If the client does not attempt session resumption, no token will be present.  While processing the initial ClientHello, TLS provides QUIC with any token that is present. In response, QUIC provides one of three responses:</p>
<p/>

<ul>
  <li>proceed with the connection,</li>
  <li>ask for client address validation, or</li>
  <li>abort the connection.</li>
</ul>
<p id="rfc.section.4.2.2.p.4">If QUIC requests source address validation, it also provides a new address validation token.  TLS includes that along with any information it requires in the cookie extension of a TLS HelloRetryRequest message.  In the other cases, the connection either proceeds or terminates with a handshake error.</p>
<p id="rfc.section.4.2.2.p.5">The client echoes the cookie extension in a second ClientHello.  A ClientHello that contains a valid cookie extension will always be in response to a HelloRetryRequest.  If address validation was requested by QUIC, then this will include an address validation token.  TLS makes a second address validation request of QUIC, including the value extracted from the cookie extension.  In response to this request, QUIC cannot ask for client address validation, it can only abort or permit the connection attempt to proceed.</p>
<p id="rfc.section.4.2.2.p.6">QUIC can provide a new address validation token for use in session resumption at any time after the handshake is complete.  Each time a new token is provided TLS generates a NewSessionTicket message, with the token included in the ticket.</p>
<p id="rfc.section.4.2.2.p.7">See <a href="#client-address-validation">Section 8</a> for more details on client address validation.</p>
<h3 id="rfc.section.4.2.3"><a href="#rfc.section.4.2.3">4.2.3.</a> <a href="#key-ready-events" id="key-ready-events">Key Ready Events</a></h3>
<p id="rfc.section.4.2.3.p.1">TLS provides QUIC with signals when 0-RTT and 1-RTT keys are ready for use.  These events are not asynchronous, they always occur immediately after TLS is provided with new handshake octets, or after TLS produces handshake octets.</p>
<p id="rfc.section.4.2.3.p.2">When TLS completed its handshake, 1-RTT keys can be provided to QUIC.  On both client and server, this occurs after sending the TLS Finished message.</p>
<p id="rfc.section.4.2.3.p.3">This ordering means that there could be frames that carry TLS handshake messages ready to send at the same time that application data is available.  An implementation MUST ensure that TLS handshake messages are always sent in cleartext packets.  Separate packets are required for data that needs protection from 1-RTT keys.</p>
<p id="rfc.section.4.2.3.p.4">If 0-RTT is possible, it is ready after the client sends a TLS ClientHello message or the server receives that message.  After providing a QUIC client with the first handshake octets, the TLS stack might signal that 0-RTT keys are ready.  On the server, after receiving handshake octets that contain a ClientHello message, a TLS server might signal that 0-RTT keys are available.</p>
<p id="rfc.section.4.2.3.p.5">1-RTT keys are used for packets in both directions.  0-RTT keys are only used to protect packets sent by the client.</p>
<h3 id="rfc.section.4.2.4"><a href="#rfc.section.4.2.4">4.2.4.</a> <a href="#secret-export" id="secret-export">Secret Export</a></h3>
<p id="rfc.section.4.2.4.p.1">Details how secrets are exported from TLS are included in <a href="#key-expansion">Section 5.2</a>.</p>
<h3 id="rfc.section.4.2.5"><a href="#rfc.section.4.2.5">4.2.5.</a> <a href="#tls-interface-summary" id="tls-interface-summary">TLS Interface Summary</a></h3>
<p><a href="#exchange-summary">Figure 4</a> summarizes the exchange between QUIC and TLS for both client and server.</p>
<div id="rfc.figure.4"/>
<div id="exchange-summary"/>
<pre>
Client                                                    Server

Get Handshake
0-RTT Key Ready
                      --- send/receive ---&gt;
                                              Handshake Received
                                                 0-RTT Key Ready
                                                   Get Handshake
                                                1-RTT Keys Ready
                     &lt;--- send/receive ---
Handshake Received
Get Handshake
Handshake Complete
1-RTT Keys Ready
                      --- send/receive ---&gt;
                                              Handshake Received
                                                   Get Handshake
                                              Handshake Complete
                     &lt;--- send/receive ---
Handshake Received
Get Handshake
</pre>
<p class="figure">Figure 4: Interaction Summary between QUIC and TLS</p>
<h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#tls-version" id="tls-version">TLS Version</a></h2>
<p id="rfc.section.4.3.p.1">This document describes how TLS 1.3 <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> is used with QUIC.</p>
<p id="rfc.section.4.3.p.2">In practice, the TLS handshake will negotiate a version of TLS to use.  This could result in a newer version of TLS than 1.3 being negotiated if both endpoints support that version.  This is acceptable provided that the features of TLS 1.3 that are used by QUIC are supported by the newer version.</p>
<p id="rfc.section.4.3.p.3">A badly configured TLS implementation could negotiate TLS 1.2 or another older version of TLS.  An endpoint MUST terminate the connection if a version of TLS older than 1.3 is negotiated.</p>
<h2 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#clienthello-size" id="clienthello-size">ClientHello Size</a></h2>
<p id="rfc.section.4.4.p.1">QUIC requires that the initial handshake packet from a client fit within the payload of a single packet.  The size limits on QUIC packets mean that a record containing a ClientHello needs to fit within 1197 octets.</p>
<p id="rfc.section.4.4.p.2">A TLS ClientHello can fit within this limit with ample space remaining.  However, there are several variables that could cause this limit to be exceeded.  Implementations are reminded that large session tickets or HelloRetryRequest cookies, multiple or large key shares, and long lists of supported ciphers, signature algorithms, versions, QUIC transport parameters, and other negotiable parameters and extensions could cause this message to grow.</p>
<p id="rfc.section.4.4.p.3">For servers, the size of the session tickets and HelloRetryRequest cookie extension can have an effect on a client&#8217;s ability to connect.  Choosing a small value increases the probability that these values can be successfully used by a client.</p>
<p id="rfc.section.4.4.p.4">The TLS implementation does not need to ensure that the ClientHello is sufficiently large.  QUIC PADDING frames are added to increase the size of the packet as necessary.</p>
<h2 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5.</a> <a href="#peer-authentication" id="peer-authentication">Peer Authentication</a></h2>
<p id="rfc.section.4.5.p.1">The requirements for authentication depend on the application protocol that is in use.  TLS provides server authentication and permits the server to request client authentication.</p>
<p id="rfc.section.4.5.p.2">A client MUST authenticate the identity of the server.  This typically involves verification that the identity of the server is included in a certificate and that the certificate is issued by a trusted entity (see for example <a href="#RFC2818">[RFC2818]</a>).</p>
<p id="rfc.section.4.5.p.3">A server MAY request that the client authenticate during the handshake. A server MAY refuse a connection if the client is unable to authenticate when requested.  The requirements for client authentication vary based on application protocol and deployment.</p>
<p id="rfc.section.4.5.p.4">A server MUST NOT use post-handshake client authentication (see Section 4.6.2 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>).</p>
<h2 id="rfc.section.4.6"><a href="#rfc.section.4.6">4.6.</a> <a href="#tls-errors" id="tls-errors">TLS Errors</a></h2>
<p id="rfc.section.4.6.p.1">Errors in the TLS connection SHOULD be signaled using TLS alerts on stream 0.  A failure in the handshake MUST be treated as a QUIC connection error of type TLS_HANDSHAKE_FAILED.  Once the handshake is complete, an error in the TLS connection that causes a TLS alert to be sent or received MUST be treated as a QUIC connection error of type TLS_FATAL_ALERT_GENERATED or TLS_FATAL_ALERT_RECEIVED respectively.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#packet-protection" id="packet-protection">QUIC Packet Protection</a></h1>
<p id="rfc.section.5.p.1">QUIC packet protection provides authenticated encryption of packets.  This provides confidentiality and integrity protection for the content of packets (see <a href="#aead">Section 5.3</a>).  Packet protection uses keys that are exported from the TLS connection (see <a href="#key-expansion">Section 5.2</a>).</p>
<p id="rfc.section.5.p.2">Different keys are used for QUIC packet protection and TLS record protection.  TLS handshake messages are protected solely with TLS record protection, but post-handshake messages are redundantly proteted with both both the QUIC packet protection and the TLS record protection. These messages are limited in number, and so the additional overhead is small.</p>
<h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#new-key" id="new-key">Installing New Keys</a></h2>
<p id="rfc.section.5.1.p.1">As TLS reports the availability of keying material, the packet protection keys and initialization vectors (IVs) are updated (see <a href="#key-expansion">Section 5.2</a>).  The selection of AEAD function is also updated to match the AEAD negotiated by TLS.</p>
<p id="rfc.section.5.1.p.2">For packets other than any unprotected handshake packets (see <a href="#cleartext-hs">Section 7.1</a>), once a change of keys has been made, packets with higher packet numbers MUST be sent with the new keying material.  The KEY_PHASE bit on these packets is inverted each time new keys are installed to signal the use of the new keys to the recipient (see <a href="#key-phases">Section 7</a> for details).</p>
<p id="rfc.section.5.1.p.3">An endpoint retransmits stream data in a new packet.  New packets have new packet numbers and use the latest packet protection keys.  This simplifies key management when there are key updates (see <a href="#key-update">Section 7.2</a>).</p>
<h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#key-expansion" id="key-expansion">QUIC Key Expansion</a></h2>
<p id="rfc.section.5.2.p.1">QUIC uses a system of packet protection secrets, keys and IVs that are modelled on the system used in TLS <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>.  The secrets that QUIC uses as the basis of its key schedule are obtained using TLS exporters (see Section 7.5 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>).</p>
<p id="rfc.section.5.2.p.2">QUIC uses HKDF with the same hash function negotiated by TLS for key derivation.  For example, if TLS is using the TLS_AES_128_GCM_SHA256, the SHA-256 hash function is used.</p>
<h3 id="rfc.section.5.2.1"><a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#zero-rtt-secrets" id="zero-rtt-secrets">0-RTT Secret</a></h3>
<p id="rfc.section.5.2.1.p.1">0-RTT keys are those keys that are used in resumed connections prior to the completion of the TLS handshake.  Data sent using 0-RTT keys might be replayed and so has some restrictions on its use, see <a href="#using-early-data">Section 9.2</a>.  0-RTT keys are used after sending or receiving a ClientHello.</p>
<p id="rfc.section.5.2.1.p.2">The secret is exported from TLS using the exporter label &#8220;EXPORTER-QUIC 0-RTT Secret&#8221; and an empty context.  The size of the secret MUST be the size of the hash output for the PRF hash function negotiated by TLS.  This uses the TLS early_exporter_secret.  The QUIC 0-RTT secret is only used for protection of packets sent by the client.</p>
<pre>
   client_0rtt_secret
       = TLS-Exporter("EXPORTER-QUIC 0-RTT Secret"
                      "", Hash.length)
</pre>
<h3 id="rfc.section.5.2.2"><a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#one-rtt-secrets" id="one-rtt-secrets">1-RTT Secrets</a></h3>
<p id="rfc.section.5.2.2.p.1">1-RTT keys are used by both client and server after the TLS handshake completes.  There are two secrets used at any time: one is used to derive packet protection keys for packets sent by the client, the other for packet protection keys on packets sent by the server.</p>
<p id="rfc.section.5.2.2.p.2">The initial client packet protection secret is exported from TLS using the exporter label &#8220;EXPORTER-QUIC client 1-RTT Secret&#8221;; the initial server packet protection secret uses the exporter label &#8220;EXPORTER-QUIC server 1-RTT Secret&#8221;.  Both exporters use an empty context.  The size of the secret MUST be the size of the hash output for the PRF hash function negotiated by TLS.</p>
<pre>
   client_pp_secret_0
       = TLS-Exporter("EXPORTER-QUIC client 1-RTT Secret"
                      "", Hash.length)
   server_pp_secret_0
       = TLS-Exporter("EXPORTER-QUIC server 1-RTT Secret"
                      "", Hash.length)
</pre>
<p id="rfc.section.5.2.2.p.3">These secrets are used to derive the initial client and server packet protection keys.</p>
<p id="rfc.section.5.2.2.p.4">After a key update (see <a href="#key-update">Section 7.2</a>), these secrets are updated using the HKDF-Expand-Label function defined in Section 7.1 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>.  HKDF-Expand-Label uses the PRF hash function negotiated by TLS.  The replacement secret is derived using the existing Secret, a Label of &#8220;QUIC client 1-RTT Secret&#8221; for the client and &#8220;QUIC server 1-RTT Secret&#8221; for the server, an empty HashValue, and the same output Length as the hash function selected by TLS for its PRF.</p>
<pre>
   client_pp_secret_&lt;N+1&gt;
       = HKDF-Expand-Label(client_pp_secret_&lt;N&gt;,
                           "QUIC client 1-RTT Secret",
                           "", Hash.length)
   server_pp_secret_&lt;N+1&gt;
       = HKDF-Expand-Label(server_pp_secret_&lt;N&gt;,
                           "QUIC server 1-RTT Secret",
                           "", Hash.length)
</pre>
<p id="rfc.section.5.2.2.p.5">This allows for a succession of new secrets to be created as needed.</p>
<p id="rfc.section.5.2.2.p.6">HKDF-Expand-Label uses HKDF-Expand <a href="#RFC5869">[RFC5869]</a> with a specially formatted info parameter, as shown:</p>
<pre>
    HKDF-Expand-Label(Secret, Label, HashValue, Length) =
         HKDF-Expand(Secret, HkdfLabel, Length)

    Where HkdfLabel is specified as:

    struct {
        uint16 length = Length;
        opaque label&lt;10..255&gt; = "tls13 " + Label;
        uint8 hashLength;     // Always 0
    } HkdfLabel;
</pre>
<p id="rfc.section.5.2.2.p.7">For example, the client packet protection secret uses an info parameter of:</p>
<pre>
   info = (HashLen / 256) || (HashLen % 256) || 0x21 ||
          "tls13 QUIC client 1-RTT secret" || 0x00
</pre>
<h3 id="rfc.section.5.2.3"><a href="#rfc.section.5.2.3">5.2.3.</a> <a href="#packet-protection-key-and-iv" id="packet-protection-key-and-iv">Packet Protection Key and IV</a></h3>
<p id="rfc.section.5.2.3.p.1">The complete key expansion uses an identical process for key expansion as defined in Section 7.3 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>, using different values for the input secret.  QUIC uses the AEAD function negotiated by TLS.</p>
<p id="rfc.section.5.2.3.p.2">The packet protection key and IV used to protect the 0-RTT packets sent by a client are derived from the QUIC 0-RTT secret. The packet protection keys and IVs for 1-RTT packets sent by the client and server are derived from the current generation of client_pp_secret and server_pp_secret respectively.  The length of the output is determined by the requirements of the AEAD function selected by TLS.  The key length is the AEAD key size.  As defined in Section 5.3 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>, the IV length is the larger of 8 or N_MIN (see Section 4 of <a href="#RFC5116">[RFC5116]</a>). For any secret S, the corresponding key and IV are derived as shown below:</p>
<pre>
   key = HKDF-Expand-Label(S, "key", "", key_length)
   iv  = HKDF-Expand-Label(S, "iv", "", iv_length)
</pre>
<p id="rfc.section.5.2.3.p.3">The QUIC record protection initially starts without keying material.  When the TLS state machine reports that the ClientHello has been sent, the 0-RTT keys can be generated and installed for writing.  When the TLS state machine reports completion of the handshake, the 1-RTT keys can be generated and installed for writing.</p>
<h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#aead" id="aead">QUIC AEAD Usage</a></h2>
<p id="rfc.section.5.3.p.1">The Authentication Encryption with Associated Data (AEAD) <a href="#RFC5116">[RFC5116]</a> function used for QUIC packet protection is AEAD that is negotiated for use with the TLS connection.  For example, if TLS is using the TLS_AES_128_GCM_SHA256, the AEAD_AES_128_GCM function is used.</p>
<p id="rfc.section.5.3.p.2">Regular QUIC packets are protected by an AEAD algorithm <a href="#RFC5116">[RFC5116]</a>.  Version negotiation and public reset packets are not protected.</p>
<p id="rfc.section.5.3.p.3">Once TLS has provided a key, the contents of regular QUIC packets immediately after any TLS messages have been sent are protected by the AEAD selected by TLS.</p>
<p id="rfc.section.5.3.p.4">The key, K, is either the client packet protection key (client_pp_key_n) or the server packet protection key (server_pp_key_n), derived as defined in <a href="#key-expansion">Section 5.2</a>.</p>
<p id="rfc.section.5.3.p.5">The nonce, N, is formed by combining the packet protection IV (either client_pp_iv_n or server_pp_iv_n) with the packet number.  The 64 bits of the reconstructed QUIC packet number in network byte order is left-padded with zeros to the size of the IV.  The exclusive OR of the padded packet number and the IV forms the AEAD nonce.</p>
<p id="rfc.section.5.3.p.6">The associated data, A, for the AEAD is the contents of the QUIC header, starting from the flags octet in the common header.</p>
<p id="rfc.section.5.3.p.7">The input plaintext, P, for the AEAD is the contents of the QUIC frame following the packet number, as described in <a href="#QUIC-TRANSPORT">[QUIC-TRANSPORT]</a>.</p>
<p id="rfc.section.5.3.p.8">The output ciphertext, C, of the AEAD is transmitted in place of P.</p>
<p id="rfc.section.5.3.p.9">Prior to TLS providing keys, no record protection is performed and the plaintext, P, is transmitted unmodified.</p>
<h2 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a> <a href="#packet-number" id="packet-number">Packet Numbers</a></h2>
<p id="rfc.section.5.4.p.1">QUIC has a single, contiguous packet number space.  In comparison, TLS restarts its sequence number each time that record protection keys are changed.  The sequence number restart in TLS ensures that a compromise of the current traffic keys does not allow an attacker to truncate the data that is sent after a key update by sending additional packets under the old key (causing new packets to be discarded).</p>
<p id="rfc.section.5.4.p.2">QUIC does not assume a reliable transport and is required to handle attacks where packets are dropped in other ways.  QUIC is therefore not affected by this form of truncation.</p>
<p id="rfc.section.5.4.p.3">The QUIC packet number is not reset and it is not permitted to go higher than its maximum value of 2^64-1.  This establishes a hard limit on the number of packets that can be sent.</p>
<p id="rfc.section.5.4.p.4">Some AEAD functions have limits for how many packets can be encrypted under the same key and IV (see for example <a href="#AEBounds">[AEBounds]</a>).  This might be lower than the packet number limit.  An endpoint MUST initiate a key update (<a href="#key-update">Section 7.2</a>) prior to exceeding any limit set for the AEAD that is in use.</p>
<p id="rfc.section.5.4.p.5">TLS maintains a separate sequence number that is used for record protection on the connection that is hosted on stream 0.  This sequence number is not visible to QUIC.</p>
<h2 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a> <a href="#receiving-protected-packets" id="receiving-protected-packets">Receiving Protected Packets</a></h2>
<p id="rfc.section.5.5.p.1">Once an endpoint successfully receives a packet with a given packet number, it MUST discard all packets with higher packet numbers if they cannot be successfully unprotected with either the same key, or - if there is a key update - the next packet protection key (see <a href="#key-update">Section 7.2</a>).  Similarly, a packet that appears to trigger a key update, but cannot be unprotected successfully MUST be discarded.</p>
<p id="rfc.section.5.5.p.2">Failure to unprotect a packet does not necessarily indicate the existence of a protocol error in a peer or an attack.  The truncated packet number encoding used in QUIC can cause packet numbers to be decoded incorrectly if they are delayed significantly.</p>
<h2 id="rfc.section.5.6"><a href="#rfc.section.5.6">5.6.</a> <a href="#packet-number-gaps" id="packet-number-gaps">Packet Number Gaps</a></h2>
<p><a href="#QUIC-TRANSPORT">[QUIC-TRANSPORT]</a>; Section 7.5.1.1 also requires a secret to compute packet number gaps on connection ID transitions. That secret is computed as:</p>
<pre>
      packet_number_secret
          = TLS-Exporter("EXPORTER-QUIC Packet Number Secret"
                         "", Hash.length)
</pre>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#unprotected-packets" id="unprotected-packets">Unprotected Packets</a></h1>
<p id="rfc.section.6.p.1">QUIC adds an integrity check to all unprotected packets.  Any packet that is not protected by the negotiated AEAD (see <a href="#packet-protection">Section 5</a>), includes an integrity check.  This check does not prevent the packet from being altered, it exists for added resilience against data corruption and to provided added assurance that the sender intends to use QUIC.</p>
<p id="rfc.section.6.p.2">Unprotected packets all use the long form of the QUIC header and so will include a version number.  For this version of QUIC, the integrity check uses the 64-bit FNV-1a hash (see <a href="#fnv1a">Section 6.2</a>).  The output of this hash is appended to the payload of the packet.</p>
<p id="rfc.section.6.p.3">The integrity check algorithm MAY change for other versions of the protocol.</p>
<h2 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#integrity-check-processing" id="integrity-check-processing">Integrity Check Processing</a></h2>
<p id="rfc.section.6.1.p.1">An endpoint sending a packet that has a long header and a type that does not indicate that the packet will be protected (that is, 0-RTT Encrypted (0x05), 1-RTT Encrypted (key phase 0) (0x06), or 1-RTT Encrypted (key phase 1) (0x07)) first constructs the packet that it sends without the integrity check.</p>
<p id="rfc.section.6.1.p.2">The sender then calculates the integrity check over the entire packet, starting from the type field.  The output of the hash is appended to the packet.</p>
<p id="rfc.section.6.1.p.3">A receiver that receives an unprotected packet first checks that the version is correct, then removes the trailing 8 octets.  It calculates the integrity check over the remainder of the packet.  Unprotected packets that do not contain a valid integrity check MUST be discarded.</p>
<h2 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#fnv1a" id="fnv1a">The 64-bit FNV-1a Algorithm</a></h2>
<p id="rfc.section.6.2.p.1">QUIC uses the 64-bit version of the alternative Fowler/Noll/Vo hash (FNV-1a) <a href="#FNV">[FNV]</a>.</p>
<p id="rfc.section.6.2.p.2">FNV-1a can be expressed in pseudocode as:</p>
<p>
  <samp>hash := offset basis for each input octet: hash := hash XOR input octet hash := hash * prime </samp>
</p>
<p id="rfc.section.6.2.p.4">That is, a 64-bit unsigned integer is initialized with an offset basis.  Then, for each octet of the input, the exclusive binary OR of the value is taken, then multiplied by a prime.  Any overflow from multiplication is discarded.</p>
<p id="rfc.section.6.2.p.5">The offset basis for the 64-bit FNV-1a is the decimal value 14695981039346656037 (in hex, 0xcbf29ce484222325).  The prime is 1099511628211 (in hex, 0x100000001b3; or as an expression 2^40 + 2^8 + 0xb3).</p>
<p id="rfc.section.6.2.p.6">Once all octets have been processed in this fashion, the final integer value is encoded as 8 octets in network byte order.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#key-phases" id="key-phases">Key Phases</a></h1>
<p id="rfc.section.7.p.1">As TLS reports the availability of 0-RTT and 1-RTT keys, new keying material can be exported from TLS and used for QUIC packet protection.  At each transition during the handshake a new secret is exported from TLS and packet protection keys are derived from that secret.</p>
<p id="rfc.section.7.p.2">Every time that a new set of keys is used for protecting outbound packets, the KEY_PHASE bit in the public flags is toggled.  0-RTT protected packets use the QUIC long header, they do not use the KEY_PHASE bit to select the correct keys (see <a href="#first-keys">Section 7.1.1</a>).</p>
<p id="rfc.section.7.p.3">Once the connection is fully enabled, the KEY_PHASE bit allows a recipient to detect a change in keying material without necessarily needing to receive the first packet that triggered the change.  An endpoint that notices a changed KEY_PHASE bit can update keys and decrypt the packet that contains the changed bit, see <a href="#key-update">Section 7.2</a>.</p>
<p id="rfc.section.7.p.4">The KEY_PHASE bit is included as the 0x20 bit of the QUIC short header, or is determined by the packet type from the long header (a type of 0x06 indicates a key phase of 0, 0x07 indicates key phase 1).</p>
<p id="rfc.section.7.p.5">Transitions between keys during the handshake are complicated by the need to ensure that TLS handshake messages are sent with the correct packet protection.</p>
<h2 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#cleartext-hs" id="cleartext-hs">Packet Protection for the TLS Handshake</a></h2>
<p id="rfc.section.7.1.p.1">The initial exchange of packets are sent without protection.  These packets use a cleartext packet type.</p>
<p id="rfc.section.7.1.p.2">TLS handshake messages MUST NOT be protected using QUIC packet protection.  All TLS handshake messages up to the TLS Finished message sent by either endpoint use cleartext packets.</p>
<p id="rfc.section.7.1.p.3">Any TLS handshake messages that are sent after completing the TLS handshake do not need special packet protection rules.  Packets containing these messages use the packet protection keys that are current at the time of sending (or retransmission).</p>
<p id="rfc.section.7.1.p.4">Like the client, a server MUST send retransmissions of its unprotected handshake messages or acknowledgments for unprotected handshake messages sent by the client in cleartext packets.</p>
<h3 id="rfc.section.7.1.1"><a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#first-keys" id="first-keys">Initial Key Transitions</a></h3>
<p id="rfc.section.7.1.1.p.1">Once the TLS handshake is complete, keying material is exported from TLS and QUIC packet protection commences.</p>
<p id="rfc.section.7.1.1.p.2">Packets protected with 1-RTT keys initially have a KEY_PHASE bit set to 0.  This bit inverts with each subsequent key update (see <a href="#key-update">Section 7.2</a>).</p>
<p id="rfc.section.7.1.1.p.3">If the client sends 0-RTT data, it uses the 0-RTT packet type.  The packet that contains the TLS EndOfEarlyData and Finished messages are sent in cleartext packets.</p>
<p id="rfc.section.7.1.1.p.4">Using distinct packet types during the handshake for handshake messages, 0-RTT data, and 1-RTT data ensures that the server is able to distinguish between the different keys used to remove packet protection.  All of these packets can arrive concurrently at a server.</p>
<p id="rfc.section.7.1.1.p.5">A server might choose to retain 0-RTT packets that arrive before a TLS ClientHello.  The server can then use those packets once the ClientHello arrives.  However, the potential for denial of service from buffering 0-RTT packets is significant.  These packets cannot be authenticated and so might be employed by an attacker to exhaust server resources.  Limiting the number of packets that are saved might be necessary.</p>
<p id="rfc.section.7.1.1.p.6">The server transitions to using 1-RTT keys after sending its first flight of TLS handshake messages.  From this point, the server protects all packets with 1-RTT keys.  Future packets are therefore protected with 1-RTT keys.  Initially, these are marked with a KEY_PHASE of 0.</p>
<h3 id="rfc.section.7.1.2"><a href="#rfc.section.7.1.2">7.1.2.</a> <a href="#retransmission-and-acknowledgment-of-unprotected-packets" id="retransmission-and-acknowledgment-of-unprotected-packets">Retransmission and Acknowledgment of Unprotected Packets</a></h3>
<p id="rfc.section.7.1.2.p.1">TLS handshake messages from both client and server are critical to the key exchange.  The contents of these messages determines the keys used to protect later messages.  If these handshake messages are included in packets that are protected with these keys, they will be indecipherable to the recipient.</p>
<p id="rfc.section.7.1.2.p.2">Even though newer keys could be available when retransmitting, retransmissions of these handshake messages MUST be sent in cleartext packets.  An endpoint MUST generate ACK frames for these messages and send them in cleartext packets.</p>
<p id="rfc.section.7.1.2.p.3">A HelloRetryRequest handshake message might be used to reject an initial ClientHello.  A HelloRetryRequest handshake message is sent in a Server Stateless Retry packet; any second ClientHello that is sent in response uses a Client Initial packet type.  Neither packet is protected.  This is natural, because no new keying material will be available when these messages need to be sent.  Upon receipt of a HelloRetryRequest, a client SHOULD cease any transmission of 0-RTT data; 0-RTT data will only be discarded by any server that sends a HelloRetryRequest.</p>
<p id="rfc.section.7.1.2.p.4">The packet type ensures that protected packets are clearly distinguished from unprotected packets.  Loss or reordering might cause unprotected packets to arrive once 1-RTT keys are in use, unprotected packets are easily distinguished from 1-RTT packets using the packet type.</p>
<p id="rfc.section.7.1.2.p.5">Once 1-RTT keys are available to an endpoint, it no longer needs the TLS handshake messages that are carried in unprotected packets.  However, a server might need to retransmit its TLS handshake messages in response to receiving an unprotected packet that contains ACK frames.  A server MUST process ACK frames in unprotected packets until the TLS handshake is reported as complete, or it receives an ACK frame in a protected packet that acknowledges all of its handshake messages.</p>
<p id="rfc.section.7.1.2.p.6">To limit the number of key phases that could be active, an endpoint MUST NOT initiate a key update while there are any unacknowledged handshake messages, see <a href="#key-update">Section 7.2</a>.</p>
<h2 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#key-update" id="key-update">Key Update</a></h2>
<p id="rfc.section.7.2.p.1">Once the TLS handshake is complete, the KEY_PHASE bit allows for refreshes of keying material by either peer.  Endpoints start using updated keys immediately without additional signaling; the change in the KEY_PHASE bit indicates that a new key is in use.</p>
<p id="rfc.section.7.2.p.2">An endpoint MUST NOT initiate more than one key update at a time.  A new key cannot be used until the endpoint has received and successfully decrypted a packet with a matching KEY_PHASE.  Note that when 0-RTT is attempted the value of the KEY_PHASE bit will be different on packets sent by either peer.</p>
<p id="rfc.section.7.2.p.3">A receiving endpoint detects an update when the KEY_PHASE bit doesn&#8217;t match what it is expecting.  It creates a new secret (see <a href="#key-expansion">Section 5.2</a>) and the corresponding read key and IV.  If the packet can be decrypted and authenticated using these values, then the keys it uses for packet protection are also updated.  The next packet sent by the endpoint will then use the new keys.</p>
<p id="rfc.section.7.2.p.4">An endpoint doesn&#8217;t need to send packets immediately when it detects that its peer has updated keys.  The next packet that it sends will simply use the new keys.  If an endpoint detects a second update before it has sent any packets with updated keys it indicates that its peer has updated keys twice without awaiting a reciprocal update.  An endpoint MUST treat consecutive key updates as a fatal error and abort the connection.</p>
<p id="rfc.section.7.2.p.5">An endpoint SHOULD retain old keys for a short period to allow it to decrypt packets with smaller packet numbers than the packet that triggered the key update.  This allows an endpoint to consume packets that are reordered around the transition between keys.  Packets with higher packet numbers always use the updated keys and MUST NOT be decrypted with old keys.</p>
<p id="rfc.section.7.2.p.6">Keys and their corresponding secrets SHOULD be discarded when an endpoint has received all packets with sequence numbers lower than the lowest sequence number used for the new key.  An endpoint might discard keys if it determines that the length of the delay to affected packets is excessive.</p>
<p id="rfc.section.7.2.p.7">This ensures that once the handshake is complete, packets with the same KEY_PHASE will have the same packet protection keys, unless there are multiple key updates in a short time frame succession and significant packet reordering.</p>
<div id="rfc.figure.5"/>
<div id="ex-key-update"/>
<pre>
   Initiating Peer                    Responding Peer

@M QUIC Frames
               New Keys -&gt; @N
@N QUIC Frames
                      --------&gt;
                                          QUIC Frames @M
                          New Keys -&gt; @N
                                          QUIC Frames @N
                      &lt;--------
</pre>
<p class="figure">Figure 5: Key Update</p>
<p id="rfc.section.7.2.p.8">As shown in <a href="#quic-tls-handshake">Figure 3</a> and <a href="#ex-key-update">Figure 5</a>, there is never a situation where there are more than two different sets of keying material that might be received by a peer.  Once both sending and receiving keys have been updated,</p>
<p id="rfc.section.7.2.p.9">A server cannot initiate a key update until it has received the client&#8217;s Finished message.  Otherwise, packets protected by the updated keys could be confused for retransmissions of handshake messages.  A client cannot initiate a key update until all of its handshake messages have been acknowledged by the server.</p>
<p id="rfc.section.7.2.p.10">A packet that triggers a key update could arrive after successfully processing a packet with a higher packet number.  This is only possible if there is a key compromise and an attack, or if the peer is incorrectly reverting to use of old keys.  Because the latter cannot be differentiated from an attack, an endpoint MUST immediately terminate the connection if it detects this condition.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#client-address-validation" id="client-address-validation">Client Address Validation</a></h1>
<p id="rfc.section.8.p.1">Two tools are provided by TLS to enable validation of client source addresses at a server: the cookie in the HelloRetryRequest message, and the ticket in the NewSessionTicket message.</p>
<h2 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> <a href="#helloretryrequest-address-validation" id="helloretryrequest-address-validation">HelloRetryRequest Address Validation</a></h2>
<p id="rfc.section.8.1.p.1">The cookie extension in the TLS HelloRetryRequest message allows a server to perform source address validation during the handshake.</p>
<p id="rfc.section.8.1.p.2">When QUIC requests address validation during the processing of the first ClientHello, the token it provides is included in the cookie extension of a HelloRetryRequest.  As long as the cookie cannot be successfully guessed by a client, the server can be assured that the client received the HelloRetryRequest if it includes the value in a second ClientHello.</p>
<p id="rfc.section.8.1.p.3">An initial ClientHello never includes a cookie extension.  Thus, if a server constructs a cookie that contains all the information necessary to reconstruct state, it can discard local state after sending a HelloRetryRequest.  Presence of a valid cookie in a ClientHello indicates that the ClientHello is a second attempt from the client.</p>
<p id="rfc.section.8.1.p.4">An address validation token can be extracted from a second ClientHello and passed to the transport for further validation.  If that validation fails, the server MUST fail the TLS handshake and send an illegal_parameter alert.</p>
<p id="rfc.section.8.1.p.5">Combining address validation with the other uses of HelloRetryRequest ensures that there are fewer ways in which an additional round-trip can be added to the handshake.  In particular, this makes it possible to combine a request for address validation with a request for a different client key share.</p>
<p id="rfc.section.8.1.p.6">If TLS needs to send a HelloRetryRequest for other reasons, it needs to ensure that it can correctly identify the reason that the HelloRetryRequest was generated.  During the processing of a second ClientHello, TLS does not need to consult the transport protocol regarding address validation if address validation was not requested originally.  In such cases, the cookie extension could either be absent or it could indicate that an address validation token is not present.</p>
<h3 id="rfc.section.8.1.1"><a href="#rfc.section.8.1.1">8.1.1.</a> <a href="#stateless-address-validation" id="stateless-address-validation">Stateless Address Validation</a></h3>
<p id="rfc.section.8.1.1.p.1">A server can use the cookie extension to store all state necessary to continue the connection.  This allows a server to avoid committing state for clients that have unvalidated source addresses.</p>
<p id="rfc.section.8.1.1.p.2">For instance, a server could use a statically-configured key to encrypt the information that it requires and include that information in the cookie.  In addition to address validation information, a server that uses encryption also needs to be able recover the hash of the ClientHello and its length, plus any information it needs in order to reconstruct the HelloRetryRequest.</p>
<h3 id="rfc.section.8.1.2"><a href="#rfc.section.8.1.2">8.1.2.</a> <a href="#sending-helloretryrequest" id="sending-helloretryrequest">Sending HelloRetryRequest</a></h3>
<p id="rfc.section.8.1.2.p.1">A server does not need to maintain state for the connection when sending a HelloRetryRequest message.  This might be necessary to avoid creating a denial of service exposure for the server.  However, this means that information about the transport will be lost at the server.  This includes the stream offset of stream 0, the packet number that the server selects, and any opportunity to measure round trip time.</p>
<p id="rfc.section.8.1.2.p.2">A server MUST send a TLS HelloRetryRequest in a Server Stateless Retry packet.  Using a Server Stateless Retry packet causes the client to reset stream offsets.  It also avoids the need for the server select an initial packet number, which would need to be remembered so that subsequent packets could be correctly numbered.</p>
<p id="rfc.section.8.1.2.p.3">A HelloRetryRequest message MUST NOT be split between multiple Server Stateless Retry packets.  This means that HelloRetryRequest is subject to the same size constraints as a ClientHello (see <a href="#clienthello-size">Section 4.4</a>).</p>
<h2 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a> <a href="#newsessionticket-address-validation" id="newsessionticket-address-validation">NewSessionTicket Address Validation</a></h2>
<p id="rfc.section.8.2.p.1">The ticket in the TLS NewSessionTicket message allows a server to provide a client with a similar sort of token.  When a client resumes a TLS connection - whether or not 0-RTT is attempted - it includes the ticket in the handshake message.  As with the HelloRetryRequest cookie, the server includes the address validation token in the ticket.  TLS provides the token it extracts from the session ticket to the transport when it asks whether source address validation is needed.</p>
<p id="rfc.section.8.2.p.2">If both a HelloRetryRequest cookie and a session ticket are present in the ClientHello, only the token from the cookie is passed to the transport.  The presence of a cookie indicates that this is a second ClientHello - the token from the session ticket will have been provided to the transport when it appeared in the first ClientHello.</p>
<p id="rfc.section.8.2.p.3">A server can send a NewSessionTicket message at any time.  This allows it to update the state - and the address validation token - that is included in the ticket.  This might be done to refresh the ticket or token, or it might be generated in response to changes in the state of the connection.  QUIC can request that a NewSessionTicket be sent by providing a new address validation token.</p>
<p id="rfc.section.8.2.p.4">A server that intends to support 0-RTT SHOULD provide an address validation token immediately after completing the TLS handshake.</p>
<h2 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3.</a> <a href="#validation-token-integrity" id="validation-token-integrity">Address Validation Token Integrity</a></h2>
<p id="rfc.section.8.3.p.1">TLS MUST provide integrity protection for address validation token unless the transport guarantees integrity protection by other means.  For a NewSessionTicket that includes confidential information - such as the resumption secret - including the token under authenticated encryption ensures that the token gains both confidentiality and integrity protection without duplicating the overheads of that protection.</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#pre-hs" id="pre-hs">Pre-handshake QUIC Messages</a></h1>
<p id="rfc.section.9.p.1">Implementations MUST NOT exchange data on any stream other than stream 0 without packet protection.  QUIC requires the use of several types of frame for managing loss detection and recovery during this phase.  In addition, it might be useful to use the data acquired during the exchange of unauthenticated messages for congestion control.</p>
<p id="rfc.section.9.p.2">This section generally only applies to TLS handshake messages from both peers and acknowledgments of the packets carrying those messages.  In many cases, the need for servers to provide acknowledgments is minimal, since the messages that clients send are small and implicitly acknowledged by the server&#8217;s responses.</p>
<p id="rfc.section.9.p.3">The actions that a peer takes as a result of receiving an unauthenticated packet needs to be limited.  In particular, state established by these packets cannot be retained once record protection commences.</p>
<p id="rfc.section.9.p.4">There are several approaches possible for dealing with unauthenticated packets prior to handshake completion:</p>
<p/>

<ul>
  <li>discard and ignore them</li>
  <li>use them, but reset any state that is established once the handshake completes</li>
  <li>use them and authenticate them afterwards; failing the handshake if they can&#8217;t be authenticated</li>
  <li>save them and use them when they can be properly authenticated</li>
  <li>treat them as a fatal error</li>
</ul>
<p id="rfc.section.9.p.6">Different strategies are appropriate for different types of data.  This document proposes that all strategies are possible depending on the type of message.</p>
<p/>

<ul>
  <li>Transport parameters are made usable and authenticated as part of the TLS handshake (see <a href="#quic_parameters">Section 10.2</a>).</li>
  <li>Most unprotected messages are treated as fatal errors when received except for the small number necessary to permit the handshake to complete (see <a href="#pre-hs-unprotected">Section 9.1</a>).</li>
  <li>Protected packets can either be discarded or saved and later used (see <a href="#pre-hs-protected">Section 9.3</a>).</li>
</ul>
<h2 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a> <a href="#pre-hs-unprotected" id="pre-hs-unprotected">Unprotected Packets Prior to Handshake Completion</a></h2>
<p id="rfc.section.9.1.p.1">This section describes the handling of messages that are sent and received prior to the completion of the TLS handshake.</p>
<p id="rfc.section.9.1.p.2">Sending and receiving unprotected messages is hazardous.  Unless expressly permitted, receipt of an unprotected message of any kind MUST be treated as a fatal error.</p>
<h3 id="rfc.section.9.1.1"><a href="#rfc.section.9.1.1">9.1.1.</a> <a href="#stream-frames" id="stream-frames">STREAM Frames</a></h3>
<p><samp>STREAM</samp> frames for stream 0 are permitted.  These carry the TLS handshake messages.  Once 1-RTT keys are available, unprotected <samp>STREAM</samp> frames on stream 0 can be ignored.</p>
<p id="rfc.section.9.1.1.p.2">Receiving unprotected <samp>STREAM</samp> frames for other streams MUST be treated as a fatal error.</p>
<h3 id="rfc.section.9.1.2"><a href="#rfc.section.9.1.2">9.1.2.</a> <a href="#ack-frames" id="ack-frames">ACK Frames</a></h3>
<p><samp>ACK</samp> frames are permitted prior to the handshake being complete.  Information learned from <samp>ACK</samp> frames cannot be entirely relied upon, since an attacker is able to inject these packets.  Timing and packet retransmission information from <samp>ACK</samp> frames is critical to the functioning of the protocol, but these frames might be spoofed or altered.</p>
<p id="rfc.section.9.1.2.p.2">Endpoints MUST NOT use an unprotected <samp>ACK</samp> frame to acknowledge data that was protected by 0-RTT or 1-RTT keys.  An endpoint MUST ignore an unprotected <samp>ACK</samp> frame if it claims to acknowledge data that was sent in a protected packet.  Such an acknowledgement can only serve as a denial of service, since an endpoint that can read protected data is always able to send protected data.</p>
<p/>

<dl>
  <dt>ISSUE:</dt>
  <dd style="margin-left: 8">What about 0-RTT data?  Should we allow acknowledgment of 0-RTT with unprotected frames?  If we don&#8217;t, then 0-RTT data will be unacknowledged until the handshake completes.  This isn&#8217;t a problem if the handshake completes without loss, but it could mean that 0-RTT stalls when a handshake packet disappears for any reason.</dd>
</dl>
<p id="rfc.section.9.1.2.p.4">An endpoint SHOULD use data from unprotected or 0-RTT-protected <samp>ACK</samp> frames only during the initial handshake and while they have insufficient information from 1-RTT-protected <samp>ACK</samp> frames.  Once sufficient information has been obtained from protected messages, information obtained from less reliable sources can be discarded.</p>
<h3 id="rfc.section.9.1.3"><a href="#rfc.section.9.1.3">9.1.3.</a> <a href="#updates-to-data-and-stream-limits" id="updates-to-data-and-stream-limits">Updates to Data and Stream Limits</a></h3>
<p><samp>MAX_DATA</samp>, <samp>MAX_STREAM_DATA</samp>, <samp>BLOCKED</samp>, <samp>STREAM_BLOCKED</samp>, and <samp>MAX_STREAM_ID</samp> frames MUST NOT be sent unprotected.</p>
<p id="rfc.section.9.1.3.p.2">Though data is exchanged on stream 0, the initial flow control window on that stream is sufficiently large to allow the TLS handshake to complete.  This limits the maximum size of the TLS handshake and would prevent a server or client from using an abnormally large certificate chain.</p>
<p id="rfc.section.9.1.3.p.3">Stream 0 is exempt from the connection-level flow control window.</p>
<p id="rfc.section.9.1.3.p.4">Consequently, there is no need to signal being blocked on flow control.</p>
<p id="rfc.section.9.1.3.p.5">Similarly, there is no need to increase the number of allowed streams until the handshake completes.</p>
<h3 id="rfc.section.9.1.4"><a href="#rfc.section.9.1.4">9.1.4.</a> <a href="#denial-of-service-with-unprotected-packets" id="denial-of-service-with-unprotected-packets">Denial of Service with Unprotected Packets</a></h3>
<p id="rfc.section.9.1.4.p.1">Accepting unprotected - specifically unauthenticated - packets presents a denial of service risk to endpoints.  An attacker that is able to inject unprotected packets can cause a recipient to drop even protected packets with a matching sequence number.  The spurious packet shadows the genuine packet, causing the genuine packet to be ignored as redundant.</p>
<p id="rfc.section.9.1.4.p.2">Once the TLS handshake is complete, both peers MUST ignore unprotected packets.  From that point onward, unprotected messages can be safely dropped.</p>
<p id="rfc.section.9.1.4.p.3">Since only TLS handshake packets and acknowledgments are sent in the clear, an attacker is able to force implementations to rely on retransmission for packets that are lost or shadowed.  Thus, an attacker that intends to deny service to an endpoint has to drop or shadow protected packets in order to ensure that their victim continues to accept unprotected packets.  The ability to shadow packets means that an attacker does not need to be on path.</p>
<p id="rfc.section.9.1.4.p.4">In addition to causing valid packets to be dropped, an attacker can generate packets with an intent of causing the recipient to expend processing resources.  See <a href="#useless">Section 11.2</a> for a discussion of these risks.</p>
<p id="rfc.section.9.1.4.p.5">To avoid receiving TLS packets that contain no useful data, a TLS implementation MUST reject empty TLS handshake records and any record that is not permitted by the TLS state machine.  Any TLS application data or alerts that is received prior to the end of the handshake MUST be treated as a fatal error.</p>
<h2 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a> <a href="#using-early-data" id="using-early-data">Use of 0-RTT Keys</a></h2>
<p id="rfc.section.9.2.p.1">If 0-RTT keys are available, the lack of replay protection means that restrictions on their use are necessary to avoid replay attacks on the protocol.</p>
<p id="rfc.section.9.2.p.2">A client MUST only use 0-RTT keys to protect data that is idempotent.  A client MAY wish to apply additional restrictions on what data it sends prior to the completion of the TLS handshake.  A client otherwise treats 0-RTT keys as equivalent to 1-RTT keys.</p>
<p id="rfc.section.9.2.p.3">A client that receives an indication that its 0-RTT data has been accepted by a server can send 0-RTT data until it receives all of the server&#8217;s handshake messages.  A client SHOULD stop sending 0-RTT data if it receives an indication that 0-RTT data has been rejected.</p>
<p id="rfc.section.9.2.p.4">A server MUST NOT use 0-RTT keys to protect packets.</p>
<h2 id="rfc.section.9.3"><a href="#rfc.section.9.3">9.3.</a> <a href="#pre-hs-protected" id="pre-hs-protected">Receiving Out-of-Order Protected Frames</a></h2>
<p id="rfc.section.9.3.p.1">Due to reordering and loss, protected packets might be received by an endpoint before the final TLS handshake messages are received.  A client will be unable to decrypt 1-RTT packets from the server, whereas a server will be able to decrypt 1-RTT packets from the client.</p>
<p id="rfc.section.9.3.p.2">Packets protected with 1-RTT keys MAY be stored and later decrypted and used once the handshake is complete.  A server MUST NOT use 1-RTT protected packets before verifying either the client Finished message or - in the case that the server has chosen to use a pre-shared key - the pre-shared key binder (see Section 4.2.8 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>).  Verifying these values provides the server with an assurance that the ClientHello has not been modified.</p>
<p id="rfc.section.9.3.p.3">A server could receive packets protected with 0-RTT keys prior to receiving a TLS ClientHello.  The server MAY retain these packets for later decryption in anticipation of receiving a ClientHello.</p>
<p id="rfc.section.9.3.p.4">Receiving and verifying the TLS Finished message is critical in ensuring the integrity of the TLS handshake.  A server MUST NOT use protected packets from the client prior to verifying the client Finished message if its response depends on client authentication.</p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#quic-specific-additions-to-the-tls-handshake" id="quic-specific-additions-to-the-tls-handshake">QUIC-Specific Additions to the TLS Handshake</a></h1>
<p id="rfc.section.10.p.1">QUIC uses the TLS handshake for more than just negotiation of cryptographic parameters.  The TLS handshake validates protocol version selection, provides preliminary values for QUIC transport parameters, and allows a server to perform return routeability checks on clients.</p>
<h2 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> <a href="#version-negotiation" id="version-negotiation">Protocol and Version Negotiation</a></h2>
<p id="rfc.section.10.1.p.1">The QUIC version negotiation mechanism is used to negotiate the version of QUIC that is used prior to the completion of the handshake.  However, this packet is not authenticated, enabling an active attacker to force a version downgrade.</p>
<p id="rfc.section.10.1.p.2">To ensure that a QUIC version downgrade is not forced by an attacker, version information is copied into the TLS handshake, which provides integrity protection for the QUIC negotiation.  This does not prevent version downgrade prior to the completion of the handshake, though it means that a downgrade causes a handshake failure.</p>
<p id="rfc.section.10.1.p.3">TLS uses Application Layer Protocol Negotiation (ALPN) <a href="#RFC7301">[RFC7301]</a> to select an application protocol.  The application-layer protocol MAY restrict the QUIC versions that it can operate over.  Servers MUST select an application protocol compatible with the QUIC version that the client has selected.</p>
<p id="rfc.section.10.1.p.4">If the server cannot select a compatible combination of application protocol and QUIC version, it MUST abort the connection. A client MUST abort a connection if the server picks an incompatible combination of QUIC version and ALPN identifier.</p>
<h2 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a> <a href="#quic_parameters" id="quic_parameters">QUIC Transport Parameters Extension</a></h2>
<p id="rfc.section.10.2.p.1">QUIC transport parameters are carried in a TLS extension. Different versions of QUIC might define a different format for this struct.</p>
<p id="rfc.section.10.2.p.2">Including transport parameters in the TLS handshake provides integrity protection for these values.</p>
<pre>
   enum {
      quic_transport_parameters(26), (65535)
   } ExtensionType;
</pre>
<p id="rfc.section.10.2.p.3">The <samp>extension_data</samp> field of the quic_transport_parameters extension contains a value that is defined by the version of QUIC that is in use.  The quic_transport_parameters extension carries a TransportParameters when the version of QUIC defined in <a href="#QUIC-TRANSPORT">[QUIC-TRANSPORT]</a> is used.</p>
<p id="rfc.section.10.2.p.4">The quic_transport_parameters extension is carried in the ClientHello and the EncryptedExtensions messages during the handshake.  The extension MAY be included in a NewSessionTicket message.</p>
<h2 id="rfc.section.10.3"><a href="#rfc.section.10.3">10.3.</a> <a href="#priming-0-rtt" id="priming-0-rtt">Priming 0-RTT</a></h2>
<p id="rfc.section.10.3.p.1">QUIC uses TLS without modification.  Therefore, it is possible to use a pre-shared key that was established in a TLS handshake over TCP to enable 0-RTT in QUIC.  Similarly, QUIC can provide a pre-shared key that can be used to enable 0-RTT in TCP.</p>
<p id="rfc.section.10.3.p.2">All the restrictions on the use of 0-RTT apply, with the exception of the ALPN label, which MUST only change to a label that is explicitly designated as being compatible.  The client indicates which ALPN label it has chosen by placing that ALPN label first in the ALPN extension.</p>
<p id="rfc.section.10.3.p.3">The certificate that the server uses MUST be considered valid for both connections, which will use different protocol stacks and could use different port numbers.  For instance, HTTP/1.1 and HTTP/2 operate over TLS and TCP, whereas QUIC operates over UDP.</p>
<p id="rfc.section.10.3.p.4">Source address validation is not completely portable between different protocol stacks.  Even if the source IP address remains constant, the port number is likely to be different.  Packet reflection attacks are still possible in this situation, though the set of hosts that can initiate these attacks is greatly reduced.  A server might choose to avoid source address validation for such a connection, or allow an increase to the amount of data that it sends toward the client without source validation.</p>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.11.p.1">There are likely to be some real clangers here eventually, but the current set of issues is well captured in the relevant sections of the main text.</p>
<p id="rfc.section.11.p.2">Never assume that because it isn&#8217;t in the security considerations section it doesn&#8217;t affect security.  Most of this document does.</p>
<h2 id="rfc.section.11.1"><a href="#rfc.section.11.1">11.1.</a> <a href="#reflection" id="reflection">Packet Reflection Attack Mitigation</a></h2>
<p id="rfc.section.11.1.p.1">A small ClientHello that results in a large block of handshake messages from a server can be used in packet reflection attacks to amplify the traffic generated by an attacker.</p>
<p id="rfc.section.11.1.p.2">Certificate caching <a href="#RFC7924">[RFC7924]</a> can reduce the size of the server&#8217;s handshake messages significantly.</p>
<p id="rfc.section.11.1.p.3">QUIC requires that the packet containing a ClientHello be padded to a minimum size.  A server is less likely to generate a packet reflection attack if the data it sends is a small multiple of this size.  A server SHOULD use a HelloRetryRequest if the size of the handshake messages it sends is likely to significantly exceed the size of the packet containing the ClientHello.</p>
<h2 id="rfc.section.11.2"><a href="#rfc.section.11.2">11.2.</a> <a href="#useless" id="useless">Peer Denial of Service</a></h2>
<p id="rfc.section.11.2.p.1">QUIC, TLS and HTTP/2 all contain a messages that have legitimate uses in some contexts, but that can be abused to cause a peer to expend processing resources without having any observable impact on the state of the connection.  If processing is disproportionately large in comparison to the observable effects on bandwidth or state, then this could allow a malicious peer to exhaust processing capacity without consequence.</p>
<p id="rfc.section.11.2.p.2">QUIC prohibits the sending of empty <samp>STREAM</samp> frames unless they are marked with the FIN bit.  This prevents <samp>STREAM</samp> frames from being sent that only waste effort.</p>
<p id="rfc.section.11.2.p.3">TLS records SHOULD always contain at least one octet of a handshake messages or alert.  Records containing only padding are permitted during the handshake, but an excessive number might be used to generate unnecessary work.  Once the TLS handshake is complete, endpoints SHOULD NOT send TLS application data records unless it is to hide the length of QUIC records.  QUIC packet protection does not include any allowance for padding; padded TLS application data records can be used to mask the length of QUIC frames.</p>
<p id="rfc.section.11.2.p.4">While there are legitimate uses for some redundant packets, implementations SHOULD track redundant packets and treat excessive volumes of any non-productive packets as indicative of an attack.</p>
<h1 id="rfc.section.12"><a href="#rfc.section.12">12.</a> <a href="#errors" id="errors">Error codes</a></h1>
<p id="rfc.section.12.p.1">The portion of the QUIC error code space allocated for the crypto handshake is 0xC0000000-0xFFFFFFFF. The following error codes are defined when TLS is used for the crypto handshake:</p>
<p/>

<dl>
  <dt>TLS_HANDSHAKE_FAILED (0xC000001C):</dt>
  <dd style="margin-left: 8">The TLS handshake failed.</dd>
  <dt>TLS_FATAL_ALERT_GENERATED (0xC000001D):</dt>
  <dd style="margin-left: 8">A TLS fatal alert was sent, causing the TLS connection to end prematurely.</dd>
  <dt>TLS_FATAL_ALERT_RECEIVED (0xC000001E):</dt>
  <dd style="margin-left: 8">A TLS fatal alert was received, causing the TLS connection to end prematurely.</dd>
</dl>
<h1 id="rfc.section.13"><a href="#rfc.section.13">13.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.13.p.1">This document does not create any new IANA registries, but it does utilize the following registries:</p>
<p/>

<ul>
  <li>QUIC Transport Parameter Registry - IANA is to register the three values found in <a href="#errors">Section 12</a>.</li>
  <li>TLS ExtensionsType Registry - IANA is to register the quic_transport_parameters extension found in <a href="#quic_parameters">Section 10.2</a>.  Assigning 26 to the extension would be greatly appreciated.  The Recommended column is to be marked Yes.</li>
  <li>TLS Exporter Label Registry - IANA is requested to register &#8220;EXPORTER-QUIC 0-RTT Secret&#8221; from <a href="#zero-rtt-secrets">Section 5.2.1</a>; &#8220;EXPORTER-QUIC client 1-RTT Secret&#8221; and &#8220;EXPORTER-QUIC server 1-RTT Secret&#8221; from <a href="#one-rtt-secrets">Section 5.2.2</a>; &#8220;EXPORTER-QUIC Packet Number Secret&#8221; <a href="#packet-number-gaps">Section 5.6</a>.  The DTLS column is to be marked No.  The Recommended column is to be marked Yes.</li>
</ul>
<h1 id="rfc.references"><a href="#rfc.references">14.</a> References</h1>
<h2 id="rfc.references.1"><a href="#rfc.references.1">14.1.</a> Normative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-tls13-20">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-20, April 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</b>
      </td>
      <td class="top"><a title="Google">Iyengar, J.</a> and <a title="Mozilla">M. Thomson</a>, "<a href="http://tools.ietf.org/html/draft-ietf-quic-transport">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport, June 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5116">[RFC5116]</b>
      </td>
      <td class="top"><a>McGrew, D.</a>, "<a href="http://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>", RFC 5116, DOI 10.17487/RFC5116, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5869">[RFC5869]</b>
      </td>
      <td class="top"><a>Krawczyk, H.</a> and <a>P. Eronen</a>, "<a href="http://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>", RFC 5869, DOI 10.17487/RFC5869, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7301">[RFC7301]</b>
      </td>
      <td class="top"><a>Friedl, S.</a>, <a>Popov, A.</a>, <a>Langley, A.</a> and <a>E. Stephan</a>, "<a href="http://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>", RFC 7301, DOI 10.17487/RFC7301, July 2014.</td>
    </tr>
  </tbody>
</table>
<h2 id="rfc.references.2"><a href="#rfc.references.2">14.2.</a> Informative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="AEBounds">[AEBounds]</b>
      </td>
      <td class="top"><a>Luykx, A.</a> and <a>K. Paterson</a>, "<a href="http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf">Limits on Authenticated Encryption Use in TLS</a>", March 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="FNV">[FNV]</b>
      </td>
      <td class="top"><a>Fowler, G.</a>, <a>Noll, L.</a>, <a>Vo, K.</a>, <a>Eastlake, D.</a> and <a>T. Hansen</a>, "<a href="http://tools.ietf.org/html/draft-eastlake-fnv-13">The FNV Non-Cryptographic Hash Algorithm</a>", Internet-Draft draft-eastlake-fnv-13, June 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="QUIC-HTTP">[QUIC-HTTP]</b>
      </td>
      <td class="top"><a title="Microsoft">Bishop, M.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-quic-http">Hypertext Transfer Protocol (HTTP) over QUIC</a>", Internet-Draft draft-ietf-quic-http, June 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="QUIC-RECOVERY">[QUIC-RECOVERY]</b>
      </td>
      <td class="top"><a title="Google">Iyengar, J.</a> and <a title="Google">I. Swett</a>, "<a href="http://tools.ietf.org/html/draft-ietf-quic-recovery">QUIC Loss Detection and Congestion Control</a>", Internet-Draft draft-ietf-quic-recovery, June 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2818">[RFC2818]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>", RFC 2818, DOI 10.17487/RFC2818, May 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5280">[RFC5280]</b>
      </td>
      <td class="top"><a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7924">[RFC7924]</b>
      </td>
      <td class="top"><a>Santesson, S.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc7924">Transport Layer Security (TLS) Cached Information Extension</a>", RFC 7924, DOI 10.17487/RFC7924, July 2016.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#contributors" id="contributors">Contributors</a></h1>
<p id="rfc.section.A.p.1">Ryan Hamilton was originally an author of this specification.</p>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.B.p.1">This document has benefited from input from Dragana Damjanovic, Christian Huitema, Jana Iyengar, Adam Langley, Roberto Peon, Eric Rescorla, Ian Swett, and many others.</p>
<h1 id="rfc.appendix.C"><a href="#rfc.appendix.C">Appendix C.</a> <a href="#change-log" id="change-log">Change Log</a></h1>
<p/>

<ul class="empty">
  <li><strong>RFC Editor&#8217;s Note:</strong> Please remove this section prior to publication of a final version of this document.</li>
</ul>
<p id="rfc.section.C.p.2">Issue and pull request numbers are listed with a leading octothorp.</p>
<h2 id="rfc.appendix.C.1"><a href="#rfc.appendix.C.1">C.1.</a> <a href="#since-draft-ietf-quic-tls-02" id="since-draft-ietf-quic-tls-02">Since draft-ietf-quic-tls-02</a></h2>
<p/>

<ul>
  <li>Updates to match changes in transport draft</li>
</ul>
<h2 id="rfc.appendix.C.2"><a href="#rfc.appendix.C.2">C.2.</a> <a href="#since-draft-ietf-quic-tls-01" id="since-draft-ietf-quic-tls-01">Since draft-ietf-quic-tls-01</a></h2>
<p/>

<ul>
  <li>Use TLS alerts to signal TLS errors (#272, #374)</li>
  <li>Require ClientHello to fit in a single packet (#338)</li>
  <li>The second client handshake flight is now sent in the clear (#262, #337)</li>
  <li>The QUIC header is included as AEAD Associated Data (#226, #243, #302)</li>
  <li>Add interface necessary for client address validation (#275)</li>
  <li>Define peer authentication (#140)</li>
  <li>Require at least TLS 1.3 (#138)</li>
  <li>Define transport parameters as a TLS extension (#122)</li>
  <li>Define handling for protected packets before the handshake completes (#39)</li>
  <li>Decouple QUIC version and ALPN (#12)</li>
</ul>
<h2 id="rfc.appendix.C.3"><a href="#rfc.appendix.C.3">C.3.</a> <a href="#since-draft-ietf-quic-tls-00" id="since-draft-ietf-quic-tls-00">Since draft-ietf-quic-tls-00</a></h2>
<p/>

<ul>
  <li>Changed bit used to signal key phase</li>
  <li>Updated key phase markings during the handshake</li>
  <li>Added TLS interface requirements section</li>
  <li>Moved to use of TLS exporters for key derivation</li>
  <li>Moved TLS error code definitions into this document</li>
</ul>
<h2 id="rfc.appendix.C.4"><a href="#rfc.appendix.C.4">C.4.</a> <a href="#since-draft-thomson-quic-tls-01" id="since-draft-thomson-quic-tls-01">Since draft-thomson-quic-tls-01</a></h2>
<p/>

<ul>
  <li>Adopted as base for draft-ietf-quic-tls</li>
  <li>Updated authors/editors list</li>
  <li>Added status note</li>
</ul>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Sean Turner</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Turner</span>
	  </span>
	</span>
	<span class="org vcardline">sn3rd</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:sean@sn3rd.com">sean@sn3rd.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/quicwg/base-drafts">Fork me on GitHub</a></div></div>
</body>
</html>
