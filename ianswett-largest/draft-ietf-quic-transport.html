<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Conventions and Definitions"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Notational Conventions"/>
<link href="#rfc.section.3" rel="Chapter" title="3 A QUIC Overview"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Low-Latency Connection Establishment"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Stream Multiplexing"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Rich Signaling for Congestion Control and Loss Recovery"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Stream and Connection Flow Control"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Authenticated and Encrypted Header and Payload"/>
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Connection Migration and Resilience to NAT Rebinding"/>
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 Version Negotiation"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Versions"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Packet Types and Formats"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Long Header"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Short Header"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Version Negotiation Packet"/>
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Cleartext Packets"/>
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 Client Initial Packet"/>
<link href="#rfc.section.5.4.2" rel="Chapter" title="5.4.2 Server Stateless Retry Packet"/>
<link href="#rfc.section.5.4.3" rel="Chapter" title="5.4.3 Server Cleartext Packet"/>
<link href="#rfc.section.5.4.4" rel="Chapter" title="5.4.4 Client Cleartext Packet"/>
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Protected Packets"/>
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Public Reset Packet"/>
<link href="#rfc.section.5.6.1" rel="Chapter" title="5.6.1 Public Reset Proof"/>
<link href="#rfc.section.5.7" rel="Chapter" title="5.7 Connection ID"/>
<link href="#rfc.section.5.8" rel="Chapter" title="5.8 Packet Numbers"/>
<link href="#rfc.section.5.8.1" rel="Chapter" title="5.8.1 Initial Packet Number"/>
<link href="#rfc.section.5.9" rel="Chapter" title="5.9 Handling Packets from Different Versions"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Frames and Frame Types"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Life of a Connection"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Version Negotiation"/>
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Using Reserved Versions"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Cryptographic and Transport Handshake"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Transport Parameters"/>
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 Transport Parameter Definitions"/>
<link href="#rfc.section.7.3.2" rel="Chapter" title="7.3.2 Values of Transport Parameters for 0-RTT"/>
<link href="#rfc.section.7.3.3" rel="Chapter" title="7.3.3 New Transport Parameters"/>
<link href="#rfc.section.7.3.4" rel="Chapter" title="7.3.4 Version Negotiation Validation"/>
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Stateless Retries"/>
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Proof of Source Address Ownership"/>
<link href="#rfc.section.7.5.1" rel="Chapter" title="7.5.1 Client Address Validation Procedure"/>
<link href="#rfc.section.7.5.2" rel="Chapter" title="7.5.2 Address Validation on Session Resumption"/>
<link href="#rfc.section.7.5.3" rel="Chapter" title="7.5.3 Address Validation Token Integrity"/>
<link href="#rfc.section.7.6" rel="Chapter" title="7.6 Connection Migration"/>
<link href="#rfc.section.7.6.1" rel="Chapter" title="7.6.1 Privacy Implications of Connection Migration"/>
<link href="#rfc.section.7.6.2" rel="Chapter" title="7.6.2 Address Validation for Migrated Connections"/>
<link href="#rfc.section.7.7" rel="Chapter" title="7.7 Connection Termination"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Frame Types and Formats"/>
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 STREAM Frame"/>
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 ACK Frame"/>
<link href="#rfc.section.8.2.1" rel="Chapter" title="8.2.1 ACK Block Section"/>
<link href="#rfc.section.8.2.2" rel="Chapter" title="8.2.2 Timestamp Section"/>
<link href="#rfc.section.8.2.3" rel="Chapter" title="8.2.3 ACK Frames and Packet Protection"/>
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 MAX_DATA Frame"/>
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 MAX_STREAM_DATA Frame"/>
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 MAX_STREAM_ID Frame"/>
<link href="#rfc.section.8.6" rel="Chapter" title="8.6 BLOCKED Frame"/>
<link href="#rfc.section.8.7" rel="Chapter" title="8.7 STREAM_BLOCKED Frame"/>
<link href="#rfc.section.8.8" rel="Chapter" title="8.8 STREAM_ID_NEEDED Frame"/>
<link href="#rfc.section.8.9" rel="Chapter" title="8.9 RST_STREAM Frame"/>
<link href="#rfc.section.8.10" rel="Chapter" title="8.10 PADDING Frame"/>
<link href="#rfc.section.8.11" rel="Chapter" title="8.11 PING frame"/>
<link href="#rfc.section.8.12" rel="Chapter" title="8.12 NEW_CONNECTION_ID Frame"/>
<link href="#rfc.section.8.13" rel="Chapter" title="8.13 CONNECTION_CLOSE frame"/>
<link href="#rfc.section.8.14" rel="Chapter" title="8.14 GOAWAY Frame"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Packetization and Reliability"/>
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Special Considerations for PMTU Discovery"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Streams: QUIC&#x2019;s Data Structuring Abstraction"/>
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Stream Identifiers"/>
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Life of a Stream"/>
<link href="#rfc.section.10.2.1" rel="Chapter" title="10.2.1 idle"/>
<link href="#rfc.section.10.2.2" rel="Chapter" title="10.2.2 open"/>
<link href="#rfc.section.10.2.3" rel="Chapter" title="10.2.3 half-closed (local)"/>
<link href="#rfc.section.10.2.4" rel="Chapter" title="10.2.4 half-closed (remote)"/>
<link href="#rfc.section.10.2.5" rel="Chapter" title="10.2.5 closed"/>
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Stream Concurrency"/>
<link href="#rfc.section.10.4" rel="Chapter" title="10.4 Sending and Receiving Data"/>
<link href="#rfc.section.10.5" rel="Chapter" title="10.5 Stream Prioritization"/>
<link href="#rfc.section.11" rel="Chapter" title="11 Flow Control"/>
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 Edge Cases and Other Considerations"/>
<link href="#rfc.section.11.1.1" rel="Chapter" title="11.1.1 Response to a RST_STREAM"/>
<link href="#rfc.section.11.1.2" rel="Chapter" title="11.1.2 Data Limit Increments"/>
<link href="#rfc.section.11.2" rel="Chapter" title="11.2 Stream Limit Increment"/>
<link href="#rfc.section.11.2.1" rel="Chapter" title="11.2.1 Blocking on Flow Control"/>
<link href="#rfc.section.11.3" rel="Chapter" title="11.3 Stream Final Offset"/>
<link href="#rfc.section.12" rel="Chapter" title="12 Error Handling"/>
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 Connection Errors"/>
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 Stream Errors"/>
<link href="#rfc.section.12.3" rel="Chapter" title="12.3 Error Codes"/>
<link href="#rfc.section.13" rel="Chapter" title="13 Security and Privacy Considerations"/>
<link href="#rfc.section.13.1" rel="Chapter" title="13.1 Spoofed ACK Attack"/>
<link href="#rfc.section.13.2" rel="Chapter" title="13.2 Slowloris Attacks"/>
<link href="#rfc.section.13.3" rel="Chapter" title="13.3 Stream Fragmentation and Reassembly Attacks"/>
<link href="#rfc.section.13.4" rel="Chapter" title="13.4 Stream Commitment Attack"/>
<link href="#rfc.section.14" rel="Chapter" title="14 IANA Considerations"/>
<link href="#rfc.section.14.1" rel="Chapter" title="14.1 QUIC Transport Parameter Registry"/>
<link href="#rfc.references" rel="Chapter" title="15 References"/>
<link href="#rfc.references.1" rel="Chapter" title="15.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="15.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Contributors"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Acknowledgments"/>
<link href="#rfc.appendix.C" rel="Chapter" title="C Change Log"/>
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Since draft-ietf-quic-transport-03"/>
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Since draft-ietf-quic-transport-02"/>
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 Since draft-ietf-quic-transport-01"/>
<link href="#rfc.appendix.C.4" rel="Chapter" title="C.4 Since draft-ietf-quic-transport-00"/>
<link href="#rfc.appendix.C.5" rel="Chapter" title="C.5 Since draft-hamilton-quic-transport-protocol-01"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Iyengar, J., Ed. and M. Thomson, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-transport-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-6-21" />
  <meta name="dct.abstract" content="This document defines the core of the QUIC transport protocol.  This document describes connection establishment, packet format, multiplexing and reliability.  Accompanying documents describe the cryptographic handshake and loss detection." />
  <meta name="description" content="This document defines the core of the QUIC transport protocol.  This document describes connection establishment, packet format, multiplexing and reliability.  Accompanying documents describe the cryptographic handshake and loss detection." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">QUIC</td>
  <td class="right">J. Iyengar, Ed.</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Google</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">M. Thomson, Ed.</td>
</tr>
<tr>
  <td class="left">Expires: December 23, 2017</td>
  <td class="right">Mozilla</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">June 21, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">QUIC: A UDP-Based Multiplexed and Secure Transport<br />
  <span class="filename">draft-ietf-quic-transport-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document defines the core of the QUIC transport protocol.  This document describes connection establishment, packet format, multiplexing and reliability.  Accompanying documents describe the cryptographic handshake and loss detection.</p>
<h1>
  <a>Note to Readers</a>
</h1>
<p>Discussion of this draft takes place on the QUIC working group mailing list (quic@ietf.org), which is archived at <a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a>.</p>
<p>Working Group information can be found at <a href="https://github.com/quicwg">https://github.com/quicwg</a>; source code and issues list for this draft can be found at <a href="https://github.com/quicwg/base-drafts/labels/transport">https://github.com/quicwg/base-drafts/labels/transport</a>.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 23, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Conventions and Definitions</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Notational Conventions</a></li>
</ul><li>3.   <a href="#rfc.section.3">A QUIC Overview</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Low-Latency Connection Establishment</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Stream Multiplexing</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Rich Signaling for Congestion Control and Loss Recovery</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Stream and Connection Flow Control</a></li>
<li>3.5.   <a href="#rfc.section.3.5">Authenticated and Encrypted Header and Payload</a></li>
<li>3.6.   <a href="#rfc.section.3.6">Connection Migration and Resilience to NAT Rebinding</a></li>
<li>3.7.   <a href="#rfc.section.3.7">Version Negotiation</a></li>
</ul><li>4.   <a href="#rfc.section.4">Versions</a></li>
<li>5.   <a href="#rfc.section.5">Packet Types and Formats</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Long Header</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Short Header</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Version Negotiation Packet</a></li>
<li>5.4.   <a href="#rfc.section.5.4">Cleartext Packets</a></li>
<ul><li>5.4.1.   <a href="#rfc.section.5.4.1">Client Initial Packet</a></li>
<li>5.4.2.   <a href="#rfc.section.5.4.2">Server Stateless Retry Packet</a></li>
<li>5.4.3.   <a href="#rfc.section.5.4.3">Server Cleartext Packet</a></li>
<li>5.4.4.   <a href="#rfc.section.5.4.4">Client Cleartext Packet</a></li>
</ul><li>5.5.   <a href="#rfc.section.5.5">Protected Packets</a></li>
<li>5.6.   <a href="#rfc.section.5.6">Public Reset Packet</a></li>
<ul><li>5.6.1.   <a href="#rfc.section.5.6.1">Public Reset Proof</a></li>
</ul><li>5.7.   <a href="#rfc.section.5.7">Connection ID</a></li>
<li>5.8.   <a href="#rfc.section.5.8">Packet Numbers</a></li>
<ul><li>5.8.1.   <a href="#rfc.section.5.8.1">Initial Packet Number</a></li>
</ul><li>5.9.   <a href="#rfc.section.5.9">Handling Packets from Different Versions</a></li>
</ul><li>6.   <a href="#rfc.section.6">Frames and Frame Types</a></li>
<li>7.   <a href="#rfc.section.7">Life of a Connection</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Version Negotiation</a></li>
<ul><li>7.1.1.   <a href="#rfc.section.7.1.1">Using Reserved Versions</a></li>
</ul><li>7.2.   <a href="#rfc.section.7.2">Cryptographic and Transport Handshake</a></li>
<li>7.3.   <a href="#rfc.section.7.3">Transport Parameters</a></li>
<ul><li>7.3.1.   <a href="#rfc.section.7.3.1">Transport Parameter Definitions</a></li>
<li>7.3.2.   <a href="#rfc.section.7.3.2">Values of Transport Parameters for 0-RTT</a></li>
<li>7.3.3.   <a href="#rfc.section.7.3.3">New Transport Parameters</a></li>
<li>7.3.4.   <a href="#rfc.section.7.3.4">Version Negotiation Validation</a></li>
</ul><li>7.4.   <a href="#rfc.section.7.4">Stateless Retries</a></li>
<li>7.5.   <a href="#rfc.section.7.5">Proof of Source Address Ownership</a></li>
<ul><li>7.5.1.   <a href="#rfc.section.7.5.1">Client Address Validation Procedure</a></li>
<li>7.5.2.   <a href="#rfc.section.7.5.2">Address Validation on Session Resumption</a></li>
<li>7.5.3.   <a href="#rfc.section.7.5.3">Address Validation Token Integrity</a></li>
</ul><li>7.6.   <a href="#rfc.section.7.6">Connection Migration</a></li>
<ul><li>7.6.1.   <a href="#rfc.section.7.6.1">Privacy Implications of Connection Migration</a></li>
<li>7.6.2.   <a href="#rfc.section.7.6.2">Address Validation for Migrated Connections</a></li>
</ul><li>7.7.   <a href="#rfc.section.7.7">Connection Termination</a></li>
</ul><li>8.   <a href="#rfc.section.8">Frame Types and Formats</a></li>
<ul><li>8.1.   <a href="#rfc.section.8.1">STREAM Frame</a></li>
<li>8.2.   <a href="#rfc.section.8.2">ACK Frame</a></li>
<ul><li>8.2.1.   <a href="#rfc.section.8.2.1">ACK Block Section</a></li>
<li>8.2.2.   <a href="#rfc.section.8.2.2">Timestamp Section</a></li>
<li>8.2.3.   <a href="#rfc.section.8.2.3">ACK Frames and Packet Protection</a></li>
</ul><li>8.3.   <a href="#rfc.section.8.3">MAX_DATA Frame</a></li>
<li>8.4.   <a href="#rfc.section.8.4">MAX_STREAM_DATA Frame</a></li>
<li>8.5.   <a href="#rfc.section.8.5">MAX_STREAM_ID Frame</a></li>
<li>8.6.   <a href="#rfc.section.8.6">BLOCKED Frame</a></li>
<li>8.7.   <a href="#rfc.section.8.7">STREAM_BLOCKED Frame</a></li>
<li>8.8.   <a href="#rfc.section.8.8">STREAM_ID_NEEDED Frame</a></li>
<li>8.9.   <a href="#rfc.section.8.9">RST_STREAM Frame</a></li>
<li>8.10.   <a href="#rfc.section.8.10">PADDING Frame</a></li>
<li>8.11.   <a href="#rfc.section.8.11">PING frame</a></li>
<li>8.12.   <a href="#rfc.section.8.12">NEW_CONNECTION_ID Frame</a></li>
<li>8.13.   <a href="#rfc.section.8.13">CONNECTION_CLOSE frame</a></li>
<li>8.14.   <a href="#rfc.section.8.14">GOAWAY Frame</a></li>
</ul><li>9.   <a href="#rfc.section.9">Packetization and Reliability</a></li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Special Considerations for PMTU Discovery</a></li>
</ul><li>10.   <a href="#rfc.section.10">Streams: QUIC&#8217;s Data Structuring Abstraction</a></li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Stream Identifiers</a></li>
<li>10.2.   <a href="#rfc.section.10.2">Life of a Stream</a></li>
<ul><li>10.2.1.   <a href="#rfc.section.10.2.1">idle</a></li>
<li>10.2.2.   <a href="#rfc.section.10.2.2">open</a></li>
<li>10.2.3.   <a href="#rfc.section.10.2.3">half-closed (local)</a></li>
<li>10.2.4.   <a href="#rfc.section.10.2.4">half-closed (remote)</a></li>
<li>10.2.5.   <a href="#rfc.section.10.2.5">closed</a></li>
</ul><li>10.3.   <a href="#rfc.section.10.3">Stream Concurrency</a></li>
<li>10.4.   <a href="#rfc.section.10.4">Sending and Receiving Data</a></li>
<li>10.5.   <a href="#rfc.section.10.5">Stream Prioritization</a></li>
</ul><li>11.   <a href="#rfc.section.11">Flow Control</a></li>
<ul><li>11.1.   <a href="#rfc.section.11.1">Edge Cases and Other Considerations</a></li>
<ul><li>11.1.1.   <a href="#rfc.section.11.1.1">Response to a RST_STREAM</a></li>
<li>11.1.2.   <a href="#rfc.section.11.1.2">Data Limit Increments</a></li>
</ul><li>11.2.   <a href="#rfc.section.11.2">Stream Limit Increment</a></li>
<ul><li>11.2.1.   <a href="#rfc.section.11.2.1">Blocking on Flow Control</a></li>
</ul><li>11.3.   <a href="#rfc.section.11.3">Stream Final Offset</a></li>
</ul><li>12.   <a href="#rfc.section.12">Error Handling</a></li>
<ul><li>12.1.   <a href="#rfc.section.12.1">Connection Errors</a></li>
<li>12.2.   <a href="#rfc.section.12.2">Stream Errors</a></li>
<li>12.3.   <a href="#rfc.section.12.3">Error Codes</a></li>
</ul><li>13.   <a href="#rfc.section.13">Security and Privacy Considerations</a></li>
<ul><li>13.1.   <a href="#rfc.section.13.1">Spoofed ACK Attack</a></li>
<li>13.2.   <a href="#rfc.section.13.2">Slowloris Attacks</a></li>
<li>13.3.   <a href="#rfc.section.13.3">Stream Fragmentation and Reassembly Attacks</a></li>
<li>13.4.   <a href="#rfc.section.13.4">Stream Commitment Attack</a></li>
</ul><li>14.   <a href="#rfc.section.14">IANA Considerations</a></li>
<ul><li>14.1.   <a href="#rfc.section.14.1">QUIC Transport Parameter Registry</a></li>
</ul><li>15.   <a href="#rfc.references">References</a></li>
<ul><li>15.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>15.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Contributors</a></li>
<li>Appendix B.   <a href="#rfc.appendix.B">Acknowledgments</a></li>
<li>Appendix C.   <a href="#rfc.appendix.C">Change Log</a></li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Since draft-ietf-quic-transport-03</a></li>
<li>C.2.   <a href="#rfc.appendix.C.2">Since draft-ietf-quic-transport-02</a></li>
<li>C.3.   <a href="#rfc.appendix.C.3">Since draft-ietf-quic-transport-01</a></li>
<li>C.4.   <a href="#rfc.appendix.C.4">Since draft-ietf-quic-transport-00</a></li>
<li>C.5.   <a href="#rfc.appendix.C.5">Since draft-hamilton-quic-transport-protocol-01</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">QUIC is a multiplexed and secure transport protocol that runs on top of UDP.  QUIC aims to provide a flexible set of features that allow it to be a general-purpose transport for multiple applications.</p>
<p id="rfc.section.1.p.2">QUIC implements techniques learned from experience with TCP, SCTP and other transport protocols.  Using UDP as the substrate, QUIC seeks to be compatible with legacy clients and middleboxes.  QUIC authenticates all of its headers and encrypts most of the data it exchanges, including its signaling.  This allows the protocol to evolve without incurring a dependency on upgrades to middleboxes.  This document describes the core QUIC protocol, including the conceptual design, wire format, and mechanisms of the QUIC protocol for connection establishment, stream multiplexing, stream and connection-level flow control, and data reliability.</p>
<p id="rfc.section.1.p.3">Accompanying documents describe QUIC&#8217;s loss detection and congestion control <a href="#QUIC-RECOVERY">[QUIC-RECOVERY]</a>, and the use of TLS 1.3 for key negotiation <a href="#QUIC-TLS">[QUIC-TLS]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#conventions-and-definitions" id="conventions-and-definitions">Conventions and Definitions</a></h1>
<p id="rfc.section.2.p.1">The words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221;, and &#8220;MAY&#8221; are used in this document.  It&#8217;s not shouting; when they are capitalized, they have the special meaning defined in <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.2.p.2">Definitions of terms that are used in this document:</p>
<p/>

<dl>
  <dt>Client:</dt>
  <dd style="margin-left: 8">The endpoint initiating a QUIC connection.</dd>
  <dt>Server:</dt>
  <dd style="margin-left: 8">The endpoint accepting incoming QUIC connections.</dd>
  <dt>Endpoint:</dt>
  <dd style="margin-left: 8">The client or server end of a connection.</dd>
  <dt>Stream:</dt>
  <dd style="margin-left: 8">A logical, bi-directional channel of ordered bytes within a QUIC connection.</dd>
  <dt>Connection:</dt>
  <dd style="margin-left: 8">A conversation between two QUIC endpoints with a single encryption context that multiplexes streams within it.</dd>
  <dt>Connection ID:</dt>
  <dd style="margin-left: 8">The identifier for a QUIC connection.</dd>
  <dt>QUIC packet:</dt>
  <dd style="margin-left: 8">A well-formed UDP payload that can be parsed by a QUIC receiver.  QUIC packet size in this document refers to the UDP payload size.</dd>
</dl>
<h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a></h2>
<p id="rfc.section.2.1.p.1">Packet and frame diagrams use the format described in <a href="#RFC2360">[RFC2360]</a> Section 3.1, with the following additional conventions:</p>
<p/>

<dl>
  <dt>[x]</dt>
  <dd style="margin-left: 8">Indicates that x is optional</dd>
  <dt>{x}</dt>
  <dd style="margin-left: 8">Indicates that x is encrypted</dd>
  <dt>x (A)</dt>
  <dd style="margin-left: 8">Indicates that x is A bits long</dd>
  <dt>x (A/B/C) &#8230;</dt>
  <dd style="margin-left: 8">Indicates that x is one of A, B, or C bits long</dd>
  <dt>x (*) &#8230;</dt>
  <dd style="margin-left: 8">Indicates that x is variable-length</dd>
</dl>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#a-quic-overview" id="a-quic-overview">A QUIC Overview</a></h1>
<p id="rfc.section.3.p.1">This section briefly describes QUIC&#8217;s key mechanisms and benefits.  Key strengths of QUIC include:</p>
<p/>

<ul>
  <li>Low-latency connection establishment</li>
  <li>Multiplexing without head-of-line blocking</li>
  <li>Authenticated and encrypted header and payload</li>
  <li>Rich signaling for congestion control and loss recovery</li>
  <li>Stream and connection flow control</li>
  <li>Connection migration and resilience to NAT rebinding</li>
  <li>Version negotiation</li>
</ul>
<h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#low-latency-connection-establishment" id="low-latency-connection-establishment">Low-Latency Connection Establishment</a></h2>
<p id="rfc.section.3.1.p.1">QUIC relies on a combined cryptographic and transport handshake for setting up a secure transport connection.  QUIC connections are expected to commonly use 0-RTT handshakes, meaning that for most QUIC connections, data can be sent immediately following the client handshake packet, without waiting for a reply from the server.  QUIC provides a dedicated stream (Stream ID 0) to be used for performing the cryptographic handshake and QUIC options negotiation.  The format of the QUIC options and parameters used during negotiation are described in this document, but the handshake protocol that runs on Stream ID 0 is described in the accompanying cryptographic handshake draft <a href="#QUIC-TLS">[QUIC-TLS]</a>.</p>
<h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#stream-multiplexing" id="stream-multiplexing">Stream Multiplexing</a></h2>
<p id="rfc.section.3.2.p.1">When application messages are transported over TCP, independent application messages can suffer from head-of-line blocking.  When an application multiplexes many streams atop TCP&#8217;s single-bytestream abstraction, a loss of a TCP segment results in blocking of all subsequent segments until a retransmission arrives, irrespective of the application streams that are encapsulated in subsequent segments.  QUIC ensures that lost packets carrying data for an individual stream only impact that specific stream.  Data received on other streams can continue to be reassembled and delivered to the application.</p>
<h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#rich-signaling-for-congestion-control-and-loss-recovery" id="rich-signaling-for-congestion-control-and-loss-recovery">Rich Signaling for Congestion Control and Loss Recovery</a></h2>
<p id="rfc.section.3.3.p.1">QUIC&#8217;s packet framing and acknowledgments carry rich information that help both congestion control and loss recovery in fundamental ways.  Each QUIC packet carries a new packet number, including those carrying retransmitted data.  This obviates the need for a separate mechanism to distinguish acknowledgments for retransmissions from those for original transmissions, avoiding TCP&#8217;s retransmission ambiguity problem.  QUIC acknowledgments also explicitly encode the delay between the receipt of a packet and its acknowledgment being sent, and together with the monotonically-increasing packet numbers, this allows for precise network roundtrip-time (RTT) calculation.  QUIC&#8217;s ACK frames support up to 256 ACK blocks, so QUIC is more resilient to reordering than TCP with SACK support, as well as able to keep more bytes on the wire when there is reordering or loss.</p>
<h2 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#stream-and-connection-flow-control" id="stream-and-connection-flow-control">Stream and Connection Flow Control</a></h2>
<p id="rfc.section.3.4.p.1">QUIC implements stream- and connection-level flow control.  At a high level, a QUIC receiver advertises the maximum amount of data that it is willing to receive on each stream.  As data is sent, received, and delivered on a particular stream, the receiver sends MAX_STREAM_DATA frames that increase the advertised limit for that stream, allowing the peer to send more data on that stream.</p>
<p id="rfc.section.3.4.p.2">In addition to this stream-level flow control, QUIC implements connection-level flow control to limit the aggregate buffer that a QUIC receiver is willing to allocate to all streams on a connection.  Connection-level flow control works in the same way as stream-level flow control, but the bytes delivered and the limits are aggregated across all streams.</p>
<h2 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> <a href="#authenticated-and-encrypted-header-and-payload" id="authenticated-and-encrypted-header-and-payload">Authenticated and Encrypted Header and Payload</a></h2>
<p id="rfc.section.3.5.p.1">TCP headers appear in plaintext on the wire and are not authenticated, causing a plethora of injection and header manipulation issues for TCP, such as receive-window manipulation and sequence-number overwriting.  While some of these are mechanisms used by middleboxes to improve TCP performance, others are active attacks.  Even &#8220;performance-enhancing&#8221; middleboxes that routinely interpose on the transport state machine end up limiting the evolvability of the transport protocol, as has been observed in the design of MPTCP <a href="#RFC6824">[RFC6824]</a> and in its subsequent deployability issues.</p>
<p id="rfc.section.3.5.p.2">Generally, QUIC packets are always authenticated and the payload is typically fully encrypted.  The parts of the packet header which are not encrypted are still authenticated by the receiver, so as to thwart any packet injection or manipulation by third parties.  Some early handshake packets, such as the Version Negotiation packet, are not encrypted, but information sent in these unencrypted handshake packets is later verified as part of cryptographic processing.</p>
<p id="rfc.section.3.5.p.3">PUBLIC_RESET packets that reset a connection are currently not authenticated.</p>
<h2 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6.</a> <a href="#connection-migration-and-resilience-to-nat-rebinding" id="connection-migration-and-resilience-to-nat-rebinding">Connection Migration and Resilience to NAT Rebinding</a></h2>
<p id="rfc.section.3.6.p.1">QUIC connections are identified by a 64-bit Connection ID, randomly generated by the client.  QUIC&#8217;s consistent connection ID allows connections to survive changes to the client&#8217;s IP and port, such as those caused by NAT rebindings or by the client changing network connectivity to a new address.  QUIC provides automatic cryptographic verification of a rebound client, since the client continues to use the same session key for encrypting and decrypting packets.  The consistent connection ID can be used to allow migration of the connection to a new server IP address as well, since the Connection ID remains consistent across changes in the client&#8217;s and the server&#8217;s network addresses.</p>
<h2 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7.</a> <a href="#benefit-version-negotiation" id="benefit-version-negotiation">Version Negotiation</a></h2>
<p id="rfc.section.3.7.p.1">QUIC version negotiation allows for multiple versions of the protocol to be deployed and used concurrently. Version negotiation is described in <a href="#version-negotiation">Section 7.1</a>.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#versions" id="versions">Versions</a></h1>
<p id="rfc.section.4.p.1">QUIC versions are identified using a 32-bit value.</p>
<p id="rfc.section.4.p.2">The version 0x00000000 is reserved to represent an invalid version.  This version of the specification is identified by the number 0x00000001.</p>
<p id="rfc.section.4.p.3">Version 0x00000001 of QUIC uses TLS as a cryptographic handshake protocol, as described in <a href="#QUIC-TLS">[QUIC-TLS]</a>.</p>
<p id="rfc.section.4.p.4">Versions with the most significant 16 bits of the version number cleared are reserved for use in future IETF consensus documents.</p>
<p id="rfc.section.4.p.5">Versions that follow the pattern 0x?a?a?a?a are reserved for use in forcing version negotiation to be exercised.  That is, any version number where the low four bits of all octets is 1010 (in binary).  A client or server MAY advertise support for any of these reserved versions.</p>
<p id="rfc.section.4.p.6">Reserved version numbers will probably never represent a real protocol; a client MAY use one of these version numbers with the expectation that the server will initiate version negotiation; a server MAY advertise support for one of these versions and can expect that clients ignore the value.</p>
<p id="rfc.section.4.p.7">[[RFC editor: please remove the remainder of this section before publication.]]</p>
<p id="rfc.section.4.p.8">The version number for the final version of this specification (0x00000001), is reserved for the version of the protocol that is published as an RFC.</p>
<p id="rfc.section.4.p.9">Version numbers used to identify IETF drafts are created by adding the draft number to 0xff000000.  For example, draft-ietf-quic-transport-13 would be identified as 0xff00000D.</p>
<p id="rfc.section.4.p.10">Implementors are encouraged to register version numbers of QUIC that they are using for private experimentation on the <a href="https://github.com/quicwg/base-drafts/wiki/QUIC-Versions">github wiki</a>.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#packet-types-and-formats" id="packet-types-and-formats">Packet Types and Formats</a></h1>
<p id="rfc.section.5.p.1">We first describe QUIC&#8217;s packet types and their formats, since some are referenced in subsequent mechanisms.</p>
<p id="rfc.section.5.p.2">All numeric values are encoded in network byte order (that is, big-endian) and all field sizes are in bits.  When discussing individual bits of fields, the least significant bit is referred to as bit 0.  Hexadecimal notation is used for describing the value of fields.</p>
<p id="rfc.section.5.p.3">Any QUIC packet has either a long or a short header, as indicated by the Header Form bit. Long headers are expected to be used early in the connection before version negotiation and establishment of 1-RTT keys, and for public resets.  Short headers are minimal version-specific headers, which can be used after version negotiation and 1-RTT keys are established.</p>
<h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#long-header" id="long-header">Long Header</a></h2>
<div id="rfc.figure.1"/>
<div id="fig-long-header"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|1|   Type (7)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                       Connection ID (64)                      +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Packet Number (32)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Version (32)                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Payload (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 1: Long Header Format</p>
<p id="rfc.section.5.1.p.1">Long headers are used for packets that are sent prior to the completion of version negotiation and establishment of 1-RTT keys. Once both conditions are met, a sender SHOULD switch to sending short-form headers. While inefficient, long headers MAY be used for packets encrypted with 1-RTT keys. The long form allows for special packets, such as the Version Negotiation and the Public Reset packets to be represented in this uniform fixed-length packet format. A long header contains the following fields:</p>
<p/>

<dl>
  <dt>Header Form:</dt>
  <dd style="margin-left: 8">The most significant bit (0x80) of the first octet is set to 1 for long headers and 0 for short headers.</dd>
  <dt>Long Packet Type:</dt>
  <dd style="margin-left: 8">The remaining seven bits of first octet of a long packet is the packet type.  This field can indicate one of 128 packet types.  The types specified for this version are listed in <a href="#long-packet-types">Table 1</a>.</dd>
  <dt>Connection ID:</dt>
  <dd style="margin-left: 8">Octets 1 through 8 contain the connection ID. <a href="#connection-id">Section 5.7</a> describes the use of this field in more detail.</dd>
  <dt>Packet Number:</dt>
  <dd style="margin-left: 8">Octets 9 to 12 contain the packet number.  <a href="#packet-numbers">Section 5.8</a> describes the use of packet numbers.</dd>
  <dt>Version:</dt>
  <dd style="margin-left: 8">Octets 13 to 16 contain the selected protocol version.  This field indicates which version of QUIC is in use and determines how the rest of the protocol fields are interpreted.</dd>
  <dt>Payload:</dt>
  <dd style="margin-left: 8">Octets from 17 onwards (the rest of QUIC packet) are the payload of the packet.</dd>
</dl>
<p id="rfc.section.5.1.p.3">The following packet types are defined:</p>
<div id="rfc.table.1"/>
<div id="long-packet-types"/>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>Long Header Packet Types</caption>
  <thead>
    <tr>
      <th class="left">Type</th>
      <th class="left">Name</th>
      <th class="left">Section</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">01</td>
      <td class="left">Version Negotiation</td>
      <td class="left">
        <a href="#packet-version">Section 5.3</a>
      </td>
    </tr>
    <tr>
      <td class="left">02</td>
      <td class="left">Client Initial</td>
      <td class="left">
        <a href="#packet-client-initial">Section 5.4.1</a>
      </td>
    </tr>
    <tr>
      <td class="left">03</td>
      <td class="left">Server Stateless Retry</td>
      <td class="left">
        <a href="#packet-server-stateless">Section 5.4.2</a>
      </td>
    </tr>
    <tr>
      <td class="left">04</td>
      <td class="left">Server Cleartext</td>
      <td class="left">
        <a href="#packet-server-cleartext">Section 5.4.3</a>
      </td>
    </tr>
    <tr>
      <td class="left">05</td>
      <td class="left">Client Cleartext</td>
      <td class="left">
        <a href="#packet-client-cleartext">Section 5.4.4</a>
      </td>
    </tr>
    <tr>
      <td class="left">06</td>
      <td class="left">0-RTT Protected</td>
      <td class="left">
        <a href="#packet-protected">Section 5.5</a>
      </td>
    </tr>
    <tr>
      <td class="left">07</td>
      <td class="left">1-RTT Protected (key phase 0)</td>
      <td class="left">
        <a href="#packet-protected">Section 5.5</a>
      </td>
    </tr>
    <tr>
      <td class="left">08</td>
      <td class="left">1-RTT Protected (key phase 1)</td>
      <td class="left">
        <a href="#packet-protected">Section 5.5</a>
      </td>
    </tr>
    <tr>
      <td class="left">09</td>
      <td class="left">Public Reset</td>
      <td class="left">
        <a href="#packet-public-reset">Section 5.6</a>
      </td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.5.1.p.4">The header form, packet type, connection ID, packet number and version fields of a long header packet are version-independent. The types of packets defined in <a href="#long-packet-types">Table 1</a> are version-specific.  See <a href="#version-specific">Section 5.9</a> for details on how packets from different versions of QUIC are interpreted.</p>
<p id="rfc.section.5.1.p.5">(TODO: Should the list of packet types be version-independent?)</p>
<p id="rfc.section.5.1.p.6">The interpretation of the fields and the payload are specific to a version and packet type.  Type-specific semantics for this version are described in the following sections.</p>
<h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#short-header" id="short-header">Short Header</a></h2>
<div id="rfc.figure.2"/>
<div id="fig-short-header"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|0|C|K| Type (5)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                     [Connection ID (64)]                      +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Packet Number (8/16/32)                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Protected Payload (*)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 2: Short Header Format</p>
<p id="rfc.section.5.2.p.1">The short header can be used after the version and 1-RTT keys are negotiated.  This header form has the following fields:</p>
<p/>

<dl>
  <dt>Header Form:</dt>
  <dd style="margin-left: 8">The most significant bit (0x80) of the first octet of a packet is the header form.  This bit is set to 0 for the short header.</dd>
  <dt>Connection ID Flag:</dt>
  <dd style="margin-left: 8">The second bit (0x40) of the first octet indicates whether the Connection ID field is present.  If set to 1, then the Connection ID field is present; if set to 0, the Connection ID field is omitted.</dd>
  <dt>Key Phase Bit:</dt>
  <dd style="margin-left: 8">The third bit (0x20) of the first octet indicates the key phase, which allows a recipient of a packet to identify the packet protection keys that are used to protect the packet.  See <a href="#QUIC-TLS">[QUIC-TLS]</a> for details.</dd>
  <dt>Short Packet Type:</dt>
  <dd style="margin-left: 8">The remaining 5 bits of the first octet include one of 32 packet types.  <a href="#short-packet-types">Table 2</a> lists the types that are defined for short packets.</dd>
  <dt>Connection ID:</dt>
  <dd style="margin-left: 8">If the Connection ID Flag is set, a connection ID occupies octets 1 through 8 of the packet.  See <a href="#connection-id">Section 5.7</a> for more details.</dd>
  <dt>Packet Number:</dt>
  <dd style="margin-left: 8">The length of the packet number field depends on the packet type.  This field can be 1, 2 or 4 octets long depending on the short packet type.</dd>
  <dt>Protected Payload:</dt>
  <dd style="margin-left: 8">Packets with a short header always include a 1-RTT protected payload.</dd>
</dl>
<p id="rfc.section.5.2.p.3">The packet type in a short header currently determines only the size of the packet number field.  Additional types can be used to signal the presence of other fields.</p>
<div id="rfc.table.2"/>
<div id="short-packet-types"/>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>Short Header Packet Types</caption>
  <thead>
    <tr>
      <th class="left">Type</th>
      <th class="left">Packet Number Size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">01</td>
      <td class="left">1 octet</td>
    </tr>
    <tr>
      <td class="left">02</td>
      <td class="left">2 octets</td>
    </tr>
    <tr>
      <td class="left">03</td>
      <td class="left">4 octets</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.5.2.p.4">The header form, connection ID flag and connection ID of a short header packet are version-independent.  The remaining fields are specific to the selected QUIC version.  See <a href="#version-specific">Section 5.9</a> for details on how packets from different versions of QUIC are interpreted.</p>
<h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#packet-version" id="packet-version">Version Negotiation Packet</a></h2>
<p id="rfc.section.5.3.p.1">A Version Negotiation packet has long headers with a type value of 0x01 and is sent only by servers.  The Version Negotiation packet is a response to a client packet that contains a version that is not supported by the server.</p>
<p id="rfc.section.5.3.p.2">The packet number, connection ID and version fields echo corresponding values from the triggering client packet.  This allows clients some assurance that the server received the packet and that the Version Negotiation packet was not carried in a packet with a spoofed source address.</p>
<p id="rfc.section.5.3.p.3">The payload of the Version Negotiation packet is a list of 32-bit versions which the server supports, as shown below.</p>
<div id="rfc.figure.3"/>
<div id="version-negotiation-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Supported Version 1 (32)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   [Supported Version 2 (32)]                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   [Supported Version N (32)]                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 3: Version Negotiation Packet</p>
<p id="rfc.section.5.3.p.4">See <a href="#version-negotiation">Section 7.1</a> for a description of the version negotiation process.</p>
<h2 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a> <a href="#cleartext-packet" id="cleartext-packet">Cleartext Packets</a></h2>
<p id="rfc.section.5.4.p.1">Cleartext packets are sent during the handshake prior to key negotiation.</p>
<p id="rfc.section.5.4.p.2">All cleartext packets contain the current QUIC version in the version field.</p>
<p id="rfc.section.5.4.p.3">The payload of cleartext packets also includes an integrity check, which is described in <a href="#QUIC-TLS">[QUIC-TLS]</a>.</p>
<h3 id="rfc.section.5.4.1"><a href="#rfc.section.5.4.1">5.4.1.</a> <a href="#packet-client-initial" id="packet-client-initial">Client Initial Packet</a></h3>
<p id="rfc.section.5.4.1.p.1">The Client Initial packet uses long headers with a type value of 0x02.  It carries the first cryptographic handshake message sent by the client.</p>
<p id="rfc.section.5.4.1.p.2">The client populates the connection ID field with randomly selected values, unless it has received a packet from the server.  If the client has received a packet from the server, the connection ID field uses the value provided by the server.</p>
<p id="rfc.section.5.4.1.p.3">The packet number used for Client Initial packets is initialized with a random value each time the new contents are created for the packet.  Retransmissions of the packet contents increment the packet number by one, see (<a href="#packet-numbers">Section 5.8</a>).</p>
<p id="rfc.section.5.4.1.p.4">The payload of a Client Initial packet consists of a STREAM frame (or frames) for stream 0 containing a cryptographic handshake message, plus any PADDING frames necessary to ensure that the packet is at least the minimum PMTU size (see <a href="#packetization">Section 9</a>).  The stream in this packet always starts at an offset of 0 (see <a href="#stateless-retry">Section 7.4</a>) and the complete cyptographic handshake message MUST fit in a single packet (see <a href="#handshake">Section 7.2</a>).</p>
<p id="rfc.section.5.4.1.p.5">The client uses the Client Initial Packet type for any packet that contains an initial cryptographic handshake message.  This includes all cases where a new packet containing the initial cryptographic message needs to be created, this includes the packets sent after receiving a Version Negotiation (<a href="#packet-version">Section 5.3</a>) or Server Stateless Retry packet (<a href="#packet-server-stateless">Section 5.4.2</a>).</p>
<h3 id="rfc.section.5.4.2"><a href="#rfc.section.5.4.2">5.4.2.</a> <a href="#packet-server-stateless" id="packet-server-stateless">Server Stateless Retry Packet</a></h3>
<p id="rfc.section.5.4.2.p.1">A Server Stateless Retry packet uses long headers with a type value of 0x03.  It carries cryptographic handshake messages and acknowledgments.  It is used by a server that wishes to perform a stateless retry (see <a href="#stateless-retry">Section 7.4</a>).</p>
<p id="rfc.section.5.4.2.p.2">The packet number and connection ID fields echo the corresponding fields from the triggering client packet.  This allows a client to verify that the server received its packet.</p>
<p id="rfc.section.5.4.2.p.3">After receiving a Server Stateless Retry packet, the client uses a new Client Initial packet containing the next cryptographic handshake message.  The client retains the state of its cryptographic handshake, but discards all transport state.  In effect, the next cryptographic handshake message is sent on a new connection.  The new Client Initial packet is sent in a packet with a newly randomized packet number and starting at a stream offset of 0.</p>
<p id="rfc.section.5.4.2.p.4">Continuing the cryptographic handshake is necessary to ensure that an attacker cannot force a downgrade of any cryptographic parameters.  In addition to continuing the cryptographic handshake, the client MUST remember the results of any version negotiation that occurred (see <a href="#version-negotiation">Section 7.1</a>).  The client MAY also retain any observed RTT or congestion state that it has accumulated for the flow, but other transport state MUST be discarded.</p>
<p id="rfc.section.5.4.2.p.5">The payload of the Server Stateless Retry packet contains STREAM frames and could contain PADDING and ACK frames.  A server can only send a single Server Stateless Retry packet in response to each Client Initial packet that is receives.</p>
<h3 id="rfc.section.5.4.3"><a href="#rfc.section.5.4.3">5.4.3.</a> <a href="#packet-server-cleartext" id="packet-server-cleartext">Server Cleartext Packet</a></h3>
<p id="rfc.section.5.4.3.p.1">A Server Cleartext packet uses long headers with a type value of 0x04.  It is used to carry acknowledgments and cryptographic handshake messages from the server.</p>
<p id="rfc.section.5.4.3.p.2">The connection ID field in a Server Cleartext packet contains a connection ID that is chosen by the server (see <a href="#connection-id">Section 5.7</a>).</p>
<p id="rfc.section.5.4.3.p.3">The first Server Cleartext packet contains a randomized packet number.  This value is increased for each subsequent packet sent by the server as described in <a href="#packet-numbers">Section 5.8</a>.</p>
<p id="rfc.section.5.4.3.p.4">The payload of this packet contains STREAM frames and could contain PADDING and ACK frames.</p>
<h3 id="rfc.section.5.4.4"><a href="#rfc.section.5.4.4">5.4.4.</a> <a href="#packet-client-cleartext" id="packet-client-cleartext">Client Cleartext Packet</a></h3>
<p id="rfc.section.5.4.4.p.1">A Client Cleartext packet uses long headers with a type value of 0x05, and is sent when the client has received a Server Cleartext packet from the server.</p>
<p id="rfc.section.5.4.4.p.2">The connection ID field in a Client Cleartext packet contains a server-selected connection ID, see <a href="#connection-id">Section 5.7</a>.</p>
<p id="rfc.section.5.4.4.p.3">The Client Cleartext packet includes a packet number that is one higher than the last Client Initial, 0-RTT Protected or Client Cleartext packet that was sent.  The packet number is incremented for each subsequent packet, see <a href="#packet-numbers">Section 5.8</a>.</p>
<p id="rfc.section.5.4.4.p.4">The payload of this packet contains STREAM frames and could contain PADDING and ACK frames.</p>
<h2 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a> <a href="#packet-protected" id="packet-protected">Protected Packets</a></h2>
<p id="rfc.section.5.5.p.1">Packets that are protected with 0-RTT keys are sent with long headers.  Packets that are protected with 1-RTT keys MAY be sent with long headers.  The different packet types explicitly indicate the encryption level and therefore the keys that are used to remove packet protection.</p>
<p id="rfc.section.5.5.p.2">Packets protected with 0-RTT keys use a type value of 0x06.  The connection ID field for a 0-RTT packet is selected by the client.</p>
<p id="rfc.section.5.5.p.3">The client can send 0-RTT packets after having received a packet from the server if that packet does not complete the handshake.  Even if the client receives a different connection ID from the server, it MUST NOT update the connection ID it uses for 0-RTT packets.  This enables consistent routing for all 0-RTT packets.</p>
<p id="rfc.section.5.5.p.4">Packets protected with 1-RTT keys that use long headers use a type value of 0x07 for key phase 0 and 0x08 for key phase 1; see <a href="#QUIC-TLS">[QUIC-TLS]</a> for more details on the use of key phases.  The connection ID field for these packet types MUST contain the value selected by the server, see <a href="#connection-id">Section 5.7</a>.</p>
<p id="rfc.section.5.5.p.5">The version field for protected packets is the current QUIC version.</p>
<p id="rfc.section.5.5.p.6">The packet number field contains a packet number, which increases with each packet sent, see <a href="#packet-numbers">Section 5.8</a> for details.</p>
<p id="rfc.section.5.5.p.7">The payload is protected using authenticated encryption.  <a href="#QUIC-TLS">[QUIC-TLS]</a> describes packet protection in detail.  After decryption, the plaintext consists of a sequence of frames, as described in <a href="#frames">Section 6</a>.</p>
<h2 id="rfc.section.5.6"><a href="#rfc.section.5.6">5.6.</a> <a href="#packet-public-reset" id="packet-public-reset">Public Reset Packet</a></h2>
<p id="rfc.section.5.6.p.1">A Public Reset packet is only sent by servers and is used to abruptly terminate communications. Public Reset is provided as an option of last resort for a server that does not have access to the state of a connection.  This is intended for use by a server that has lost state (for example, through a crash or outage). A server that wishes to communicate a fatal connection error MUST use a CONNECTION_CLOSE frame if it has sufficient state to do so.</p>
<p id="rfc.section.5.6.p.2">A Public Reset packet uses long headers with a type value of 0x09.</p>
<p id="rfc.section.5.6.p.3">The connection ID and packet number of fields together contain octets 1 through 12 from the packet that triggered the reset.  For a client that sends a connection ID on every packet, the Connection ID field is simply an echo of the client&#8217;s Connection ID, and the Packet Number field includes an echo of the client&#8217;s packet number.  Depending on the client&#8217;s packet number length it might also include 0, 2, or 3 additional octets from the protected payload of the client packet.</p>
<p id="rfc.section.5.6.p.4">The version field contains the current QUIC version.</p>
<p id="rfc.section.5.6.p.5">A Public Reset packet sent by a server indicates that it does not have the state necessary to continue with a connection.  In this case, the server will include the fields that prove that it originally participated in the connection (see <a href="#public-reset-proof">Section 5.6.1</a> for details).</p>
<p id="rfc.section.5.6.p.6">Upon receipt of a Public Reset packet that contains a valid proof, a client MUST tear down state associated with the connection.  The client MUST then cease sending packets on the connection and SHOULD discard any subsequent packets that arrive. A Public Reset that does not contain a valid proof MUST be ignored.</p>
<h3 id="rfc.section.5.6.1"><a href="#rfc.section.5.6.1">5.6.1.</a> <a href="#public-reset-proof" id="public-reset-proof">Public Reset Proof</a></h3>
<p id="rfc.section.5.6.1.p.1">TODO: Details to be added.</p>
<h2 id="rfc.section.5.7"><a href="#rfc.section.5.7">5.7.</a> <a href="#connection-id" id="connection-id">Connection ID</a></h2>
<p id="rfc.section.5.7.p.1">QUIC connections are identified by their 64-bit Connection ID.  All long headers contain a Connection ID.  Short headers indicate the presence of a Connection ID using the CONNECTION_ID flag.  When present, the Connection ID is in the same location in all packet headers, making it straightforward for middleboxes, such as load balancers, to locate and use it.</p>
<p id="rfc.section.5.7.p.2">The client MUST choose a random connection ID and use it in Client Initial packets (<a href="#packet-client-initial">Section 5.4.1</a>) and 0-RTT packets (<a href="#packet-protected">Section 5.5</a>).  If the client has received any packet from the server, it uses the connection ID it received from the server for all packets other than 0-RTT packets.</p>
<p id="rfc.section.5.7.p.3">When the server receives a Client Initial packet and decides to proceed with the handshake, it chooses a new value for the connection ID and sends that in a Server Cleartext packet.  The server MAY choose to use the value that the client initially selects.</p>
<p id="rfc.section.5.7.p.4">Once the client receives the connection ID that the server has chosen, it uses this for all subsequent packets that it sends, except for any 0-RTT packets, which all have the same connection ID.</p>
<h2 id="rfc.section.5.8"><a href="#rfc.section.5.8">5.8.</a> <a href="#packet-numbers" id="packet-numbers">Packet Numbers</a></h2>
<p id="rfc.section.5.8.p.1">The packet number is a 64-bit unsigned number and is used as part of a cryptographic nonce for packet encryption.  Each endpoint maintains a separate packet number for sending and receiving.  The packet number for sending MUST increase by at least one after sending any packet, unless otherwise specified (see <a href="#initial-packet-number">Section 5.8.1</a>).</p>
<p id="rfc.section.5.8.p.2">A QUIC endpoint MUST NOT reuse a packet number within the same connection (that is, under the same cryptographic keys).  If the packet number for sending reaches 2^64 - 1, the sender MUST close the connection by sending a CONNECTION_CLOSE frame with the error code QUIC_SEQUENCE_NUMBER_LIMIT_REACHED (connection termination is described in <a href="#termination">Section 7.7</a>.)</p>
<p id="rfc.section.5.8.p.3">To reduce the number of bits required to represent the packet number over the wire, only the least significant bits of the packet number are transmitted over the wire, up to 32 bits.  The actual packet number for each packet is reconstructed at the receiver based on the largest packet number received on a successfully authenticated packet.</p>
<p id="rfc.section.5.8.p.4">A packet number is decoded by finding the packet number value that is closest to the next expected packet.  The next expected packet is the highest received packet number plus one.  For example, if the highest successfully authenticated packet had a packet number of 0xaa82f30e, then a packet containing a 16-bit value of 0x1f94 will be decoded as 0xaa831f94.</p>
<p id="rfc.section.5.8.p.5">The sender MUST use a packet number size able to represent more than twice as large a range than the difference between the largest acknowledged packet and packet number being sent.  A peer receiving the packet will then correctly decode the packet number, unless the packet is delayed in transit such that it arrives after many higher-numbered packets have been received.  An endpoint MAY use a larger packet number size to safeguard against such reordering.</p>
<p id="rfc.section.5.8.p.6">As a result, the size of the packet number encoding is at least one more than the base 2 logarithm of the number of contiguous unacknowledged packet numbers, including the new packet.</p>
<p id="rfc.section.5.8.p.7">For example, if an endpoint has received an acknowledgment for packet 0x6afa2f, sending a packet with a number of 0x6b4264 requires a 16-bit or larger packet number encoding; whereas a 32-bit packet number is needed to send a packet with a number of 0x6bc107.</p>
<p id="rfc.section.5.8.p.8">Version Negotiation (<a href="#packet-version">Section 5.3</a>), Server Stateless Retry (<a href="#packet-server-stateless">Section 5.4.2</a>), and Public Reset (<a href="#packet-public-reset">Section 5.6</a>) packets have special rules for populating the packet number field.</p>
<h3 id="rfc.section.5.8.1"><a href="#rfc.section.5.8.1">5.8.1.</a> <a href="#initial-packet-number" id="initial-packet-number">Initial Packet Number</a></h3>
<p id="rfc.section.5.8.1.p.1">The initial value for packet number MUST be selected from an uniform random distribution between 0 and 2^31-1.  That is, the lower 31 bits of the packet number are randomized.  <a href="#RFC4086">[RFC4086]</a> provides guidance on the generation of random values.</p>
<p id="rfc.section.5.8.1.p.2">The first set of packets sent by an endpoint MUST include the low 32-bits of the packet number.  Once any packet has been acknowledged, subsequent packets can use a shorter packet number encoding.</p>
<p id="rfc.section.5.8.1.p.3">A client that receives a Version Negotiation (<a href="#packet-version">Section 5.3</a>) or Server Stateless Retry packet (<a href="#packet-server-stateless">Section 5.4.2</a>) MUST generate a new initial packet number.  This ensures that the first transmission attempt for a Client Initial packet (<a href="#packet-client-initial">Section 5.4.1</a>) always contains a randomized packet number, but packets that contain retransmissions increment the packet number.</p>
<p id="rfc.section.5.8.1.p.4">A client MUST NOT generate a new initial packet number if it discards the server packet.  This might happen if the information the client retransmits its Client Initial packet.</p>
<h2 id="rfc.section.5.9"><a href="#rfc.section.5.9">5.9.</a> <a href="#version-specific" id="version-specific">Handling Packets from Different Versions</a></h2>
<p id="rfc.section.5.9.p.1">Between different versions the following things are guaranteed to remain constant:</p>
<p/>

<ul>
  <li>the location of the header form flag,</li>
  <li>the location of the Connection ID flag in short headers,</li>
  <li>the location and size of the Connection ID field in both header forms,</li>
  <li>the location and size of the Version field in long headers, and</li>
  <li>the location and size of the Packet Number field in long headers.</li>
</ul>
<p id="rfc.section.5.9.p.3">Implementations MUST assume that an unsupported version uses an unknown packet format. All other fields MUST be ignored when processing a packet that contains an unsupported version.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#frames" id="frames">Frames and Frame Types</a></h1>
<p id="rfc.section.6.p.1">The payload of cleartext packets and the plaintext after decryption of protected payloads consists of a sequence of frames, as shown in <a href="#packet-frames">Figure 4</a>.</p>
<div id="rfc.figure.4"/>
<div id="packet-frames"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame 1 (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame 2 (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame N (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 4: Contents of Protected Payload</p>
<p id="rfc.section.6.p.2">Protected payloads MUST contain at least one frame, and MAY contain multiple frames and multiple frame types.</p>
<p id="rfc.section.6.p.3">Frames MUST fit within a single QUIC packet and MUST NOT span a QUIC packet boundary. Each frame begins with a Frame Type byte, indicating its type, followed by additional type-dependent fields:</p>
<div id="rfc.figure.5"/>
<div id="frame-layout"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type (8)    |           Type-Dependent Fields (*)         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 5: Generic Frame Layout</p>
<p id="rfc.section.6.p.4">Frame types are listed in <a href="#frame-types">Table 3</a>. Note that the Frame Type byte in STREAM and ACK frames is used to carry other frame-specific flags.  For all other frames, the Frame Type byte simply identifies the frame.  These frames are explained in more detail as they are referenced later in the document.</p>
<div id="rfc.table.3"/>
<div id="frame-types"/>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>Frame Types</caption>
  <thead>
    <tr>
      <th class="left">Type Value</th>
      <th class="left">Frame Type Name</th>
      <th class="left">Definition</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">0x00</td>
      <td class="left">PADDING</td>
      <td class="left">
        <a href="#frame-padding">Section 8.10</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x01</td>
      <td class="left">RST_STREAM</td>
      <td class="left">
        <a href="#frame-rst-stream">Section 8.9</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x02</td>
      <td class="left">CONNECTION_CLOSE</td>
      <td class="left">
        <a href="#frame-connection-close">Section 8.13</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x03</td>
      <td class="left">GOAWAY</td>
      <td class="left">
        <a href="#frame-goaway">Section 8.14</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x04</td>
      <td class="left">MAX_DATA</td>
      <td class="left">
        <a href="#frame-max-data">Section 8.3</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x05</td>
      <td class="left">MAX_STREAM_DATA</td>
      <td class="left">
        <a href="#frame-max-stream-data">Section 8.4</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x06</td>
      <td class="left">MAX_STREAM_ID</td>
      <td class="left">
        <a href="#frame-max-stream-id">Section 8.5</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x07</td>
      <td class="left">PING</td>
      <td class="left">
        <a href="#frame-ping">Section 8.11</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x08</td>
      <td class="left">BLOCKED</td>
      <td class="left">
        <a href="#frame-blocked">Section 8.6</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x09</td>
      <td class="left">STREAM_BLOCKED</td>
      <td class="left">
        <a href="#frame-stream-blocked">Section 8.7</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x0a</td>
      <td class="left">STREAM_ID_NEEDED</td>
      <td class="left">
        <a href="#frame-stream-id-needed">Section 8.8</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x0b</td>
      <td class="left">NEW_CONNECTION_ID</td>
      <td class="left">
        <a href="#frame-new-connection-id">Section 8.12</a>
      </td>
    </tr>
    <tr>
      <td class="left">0xa0 - 0xbf</td>
      <td class="left">ACK</td>
      <td class="left">
        <a href="#frame-ack">Section 8.2</a>
      </td>
    </tr>
    <tr>
      <td class="left">0xc0 - 0xff</td>
      <td class="left">STREAM</td>
      <td class="left">
        <a href="#frame-stream">Section 8.1</a>
      </td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#life-of-a-connection" id="life-of-a-connection">Life of a Connection</a></h1>
<p id="rfc.section.7.p.1">A QUIC connection is a single conversation between two QUIC endpoints.  QUIC&#8217;s connection establishment intertwines version negotiation with the cryptographic and transport handshakes to reduce connection establishment latency, as described in <a href="#handshake">Section 7.2</a>.  Once established, a connection may migrate to a different IP or port at either endpoint, due to NAT rebinding or mobility, as described in <a href="#migration">Section 7.6</a>.  Finally a connection may be terminated by either endpoint, as described in <a href="#termination">Section 7.7</a>.</p>
<h2 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#version-negotiation" id="version-negotiation">Version Negotiation</a></h2>
<p id="rfc.section.7.1.p.1">QUIC&#8217;s connection establishment begins with version negotiation, since all communication between the endpoints, including packet and frame formats, relies on the two endpoints agreeing on a version.</p>
<p id="rfc.section.7.1.p.2">A QUIC connection begins with a client sending a handshake packet. The details of the handshake mechanisms are described in <a href="#handshake">Section 7.2</a>, but all of the initial packets sent from the client to the server MUST use the long header format and MUST specify the version of the protocol being used.</p>
<p id="rfc.section.7.1.p.3">When the server receives a packet from a client with the long header format, it compares the client&#8217;s version to the versions it supports.</p>
<p id="rfc.section.7.1.p.4">If the version selected by the client is not acceptable to the server, the server discards the incoming packet and responds with a Version Negotiation packet (<a href="#packet-version">Section 5.3</a>).  This includes a list of versions that the server will accept.</p>
<p id="rfc.section.7.1.p.5">A server sends a Version Negotiation packet for every packet that it receives with an unacceptable version.  This allows a server to process packets with unsupported versions without retaining state.  Though either the initial client packet or the version negotiation packet that is sent in response could be lost, the client will send new packets until it successfully receives a response.</p>
<p id="rfc.section.7.1.p.6">If the packet contains a version that is acceptable to the server, the server proceeds with the handshake (<a href="#handshake">Section 7.2</a>).  This commits the server to the version that the client selected.</p>
<p id="rfc.section.7.1.p.7">When the client receives a Version Negotiation packet from the server, it should select an acceptable protocol version.  If the server lists an acceptable version, the client selects that version and reattempts to create a connection using that version.  Though the contents of a packet might not change in response to version negotiation, a client MUST increase the packet number it uses on every packet it sends.  Packets MUST continue to use long headers and MUST include the new negotiated protocol version.</p>
<p id="rfc.section.7.1.p.8">The client MUST use the long header format and include its selected version on all packets until it has 1-RTT keys and it has received a packet from the server which is not a Version Negotiation packet.</p>
<p id="rfc.section.7.1.p.9">A client MUST NOT change the version it uses unless it is in response to a Version Negotiation packet from the server.  Once a client receives a packet from the server which is not a Version Negotiation packet, it MUST ignore other Version Negotiation packets on the same connection.  Similarly, a client MUST ignore a Version Negotiation packet if it has already received and acted on a Version Negotiation packet.</p>
<p id="rfc.section.7.1.p.10">A client MUST ignore a Version Negotiation packet that lists the client&#8217;s chosen version.</p>
<p id="rfc.section.7.1.p.11">Version negotiation uses unprotected data. The result of the negotiation MUST be revalidated as part of the cryptographic handshake (see <a href="#version-validation">Section 7.3.4</a>).</p>
<h3 id="rfc.section.7.1.1"><a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#using-reserved-versions" id="using-reserved-versions">Using Reserved Versions</a></h3>
<p id="rfc.section.7.1.1.p.1">For a server to use a new version in the future, clients must correctly handle unsupported versions. To help ensure this, a server SHOULD include a reserved version (see <a href="#versions">Section 4</a>) while generating a Version Negotiation packet.</p>
<p id="rfc.section.7.1.1.p.2">The design of version negotiation permits a server to avoid maintaining state for packets that it rejects in this fashion.  However, when the server generates a Version Negotiation packet, it cannot randomly generate a reserved version number. This is because the server is required to include the same value in its transport parameters (see <a href="#version-validation">Section 7.3.4</a>).  To avoid the selected version number changing during connection establishment, the reserved version SHOULD be generated as a function of values that will be available to the server when later generating its handshake packets.</p>
<p id="rfc.section.7.1.1.p.3">A pseudorandom function that takes client address information (IP and port) and the client selected version as input would ensure that there is sufficient variability in the values that a server uses.</p>
<p id="rfc.section.7.1.1.p.4">A client MAY send a packet using a reserved version number.  This can be used to solicit a list of supported versions from a server.</p>
<h2 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#handshake" id="handshake">Cryptographic and Transport Handshake</a></h2>
<p id="rfc.section.7.2.p.1">QUIC relies on a combined cryptographic and transport handshake to minimize connection establishment latency.  QUIC allocates stream 0 for the cryptographic handshake.  Version 0x00000001 of QUIC uses TLS 1.3 as described in <a href="#QUIC-TLS">[QUIC-TLS]</a>; a different QUIC version number could indicate that a different cryptographic handshake protocol is in use.</p>
<p id="rfc.section.7.2.p.2">QUIC provides this stream with reliable, ordered delivery of data.  In return, the cryptographic handshake provides QUIC with:</p>
<p/>

<ul>
  <li>authenticated key exchange, where  <ul><li>a server is always authenticated,</li><li>a client is optionally authenticated,</li><li>every connection produces distinct and unrelated keys,</li><li>keying material is usable for packet protection for both 0-RTT and 1-RTT packets, and</li><li>1-RTT keys have forward secrecy</li></ul></li>
  <li>authenticated values for the transport parameters of the peer (see <a href="#transport-parameters">Section 7.3</a>)</li>
  <li>authenticated confirmation of version negotiation (see <a href="#version-validation">Section 7.3.4</a>)</li>
  <li>authenticated negotiation of an application protocol (TLS uses ALPN <a href="#RFC7301">[RFC7301]</a> for this purpose)</li>
  <li>for the server, the ability to carry data that provides assurance that the client can receive packets that are addressed with the transport address that is claimed by the client (see <a href="#address-validation">Section 7.5</a>)</li>
</ul>
<p id="rfc.section.7.2.p.4">The initial cryptographic handshake message MUST be sent in a single packet.  Any second attempt that is triggered by address validation MUST also be sent within a single packet.  This avoids having to reassemble a message from multiple packets.  Reassembling messages requires that a server maintain state prior to establishing a connection, exposing the server to a denial of service risk.</p>
<p id="rfc.section.7.2.p.5">The first client packet of the cryptographic handshake protocol MUST fit within a 1232 octet QUIC packet payload.  This includes overheads that reduce the space available to the cryptographic handshake protocol.</p>
<p id="rfc.section.7.2.p.6">Details of how TLS is integrated with QUIC is provided in more detail in <a href="#QUIC-TLS">[QUIC-TLS]</a>.</p>
<h2 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> <a href="#transport-parameters" id="transport-parameters">Transport Parameters</a></h2>
<p id="rfc.section.7.3.p.1">During connection establishment, both endpoints make authenticated declarations of their transport parameters.  These declarations are made unilaterally by each endpoint.  Endpoints are required to comply with the restrictions implied by these parameters; the description of each parameter includes rules for its handling.</p>
<p id="rfc.section.7.3.p.2">The format of the transport parameters is the TransportParameters struct from <a href="#figure-transport-parameters">Figure 6</a>.  This is described using the presentation language from Section 3 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>.</p>
<div id="rfc.figure.6"/>
<div id="figure-transport-parameters"/>
<pre>
   uint32 QuicVersion;

   enum {
      initial_max_stream_data(0),
      initial_max_data(1),
      initial_max_stream_id(2),
      idle_timeout(3),
      truncate_connection_id(4),
      max_packet_size(5),
      (65535)
   } TransportParameterId;

   struct {
      TransportParameterId parameter;
      opaque value&lt;0..2^16-1&gt;;
   } TransportParameter;

   struct {
      select (Handshake.msg_type) {
         case client_hello:
            QuicVersion negotiated_version;
            QuicVersion initial_version;

         case encrypted_extensions:
            QuicVersion supported_versions&lt;2..2^8-4&gt;;
      };
      TransportParameter parameters&lt;30..2^16-1&gt;;
   } TransportParameters;
</pre>
<p class="figure">Figure 6: Definition of TransportParameters</p>
<p id="rfc.section.7.3.p.3">The <samp>extension_data</samp> field of the quic_transport_parameters extension defined in <a href="#QUIC-TLS">[QUIC-TLS]</a> contains a TransportParameters value.  TLS encoding rules are therefore used to encode the transport parameters.</p>
<p id="rfc.section.7.3.p.4">QUIC encodes transport parameters into a sequence of octets, which are then included in the cryptographic handshake.  Once the handshake completes, the transport parameters declared by the peer are available.  Each endpoint validates the value provided by its peer.  In particular, version negotiation MUST be validated (see <a href="#version-validation">Section 7.3.4</a>) before the connection establishment is considered properly complete.</p>
<p id="rfc.section.7.3.p.5">Definitions for each of the defined transport parameters are included in <a href="#transport-parameter-definitions">Section 7.3.1</a>.</p>
<h3 id="rfc.section.7.3.1"><a href="#rfc.section.7.3.1">7.3.1.</a> <a href="#transport-parameter-definitions" id="transport-parameter-definitions">Transport Parameter Definitions</a></h3>
<p id="rfc.section.7.3.1.p.1">An endpoint MUST include the following parameters in its encoded TransportParameters:</p>
<p/>

<dl>
  <dt>initial_max_stream_data (0x0000):</dt>
  <dd style="margin-left: 8">The initial stream maximum data parameter contains the initial value for the maximum data that can be sent on any newly created stream.  This parameter is encoded as an unsigned 32-bit integer in units of octets.  This is equivalent to an implicit MAX_STREAM_DATA frame (<a href="#frame-max-stream-data">Section 8.4</a>) being sent on all streams immediately after opening.</dd>
  <dt>initial_max_data (0x0001):</dt>
  <dd style="margin-left: 8">The initial maximum data parameter contains the initial value for the maximum amount of data that can be sent on the connection.  This parameter is encoded as an unsigned 32-bit integer in units of 1024 octets.  That is, the value here is multiplied by 1024 to determine the actual maximum value.  This is equivalent to sending a MAX_DATA (<a href="#frame-max-data">Section 8.3</a>) for the connection immediately after completing the handshake.</dd>
  <dt>initial_max_stream_id (0x0002):</dt>
  <dd style="margin-left: 8">The initial maximum stream ID parameter contains the initial maximum stream number the peer may initiate, encoded as an unsigned 32-bit integer.  This is equivalent to sending a MAX_STREAM_ID (<a href="#frame-max-stream-id">Section 8.5</a>) immediately after completing the handshake.</dd>
  <dt>idle_timeout (0x0003):</dt>
  <dd style="margin-left: 8">The idle timeout is a value in seconds that is encoded as an unsigned 16-bit integer.  The maximum value is 600 seconds (10 minutes).</dd>
</dl>
<p id="rfc.section.7.3.1.p.3">An endpoint MAY use the following transport parameters:</p>
<p/>

<dl>
  <dt>truncate_connection_id (0x0004):</dt>
  <dd style="margin-left: 8">The truncated connection identifier parameter indicates that packets sent to the peer can omit the connection ID.  This can be used by an endpoint where the 5-tuple is sufficient to identify a connection.  This parameter is zero length.  Omitting the parameter indicates that the endpoint relies on the connection ID being present in every packet.</dd>
  <dt>max_packet_size (0x0005):</dt>
  <dd style="margin-left: 8">The maximum packet size parameter places a limit on the size of packets that the endpoint is willing to receive, encoded as an unsigned 16-bit integer.  This indicates that packets larger than this limit will be dropped.  The default for this parameter is the maximum permitted UDP payload of 65527.  Values below 1252 are invalid.  This limit only applies to protected packets (<a href="#packet-protected">Section 5.5</a>).</dd>
</dl>
<h3 id="rfc.section.7.3.2"><a href="#rfc.section.7.3.2">7.3.2.</a> <a href="#zerortt-parameters" id="zerortt-parameters">Values of Transport Parameters for 0-RTT</a></h3>
<p id="rfc.section.7.3.2.p.1">Transport parameters from the server MUST be remembered by the client for use with 0-RTT data.  If the TLS NewSessionTicket message includes the quic_transport_parameters extension, then those values are used for the server values when establishing a new connection using that ticket.  Otherwise, the transport parameters that the server advertises during connection establishment are used.</p>
<p id="rfc.section.7.3.2.p.2">A server can remember the transport parameters that it advertised, or store an integrity-protected copy of the values in the ticket and recover the information when accepting 0-RTT data.  A server uses the transport parameters in determining whether to accept 0-RTT data.</p>
<p id="rfc.section.7.3.2.p.3">A server MAY accept 0-RTT and subsequently provide different values for transport parameters for use in the new connection.  If 0-RTT data is accepted by the server, the server MUST NOT reduce any limits or alter any values that might be violated by the client with its 0-RTT data.  In particular, a server that accepts 0-RTT data MUST NOT set values for initial_max_data or initial_max_stream_data that are smaller than the remembered value of those parameters.  Similarly, a server MUST NOT reduce the value of initial_max_stream_id.</p>
<p id="rfc.section.7.3.2.p.4">A server MUST reject 0-RTT data or even abort a handshake if the implied values for transport parameters cannot be supported.</p>
<h3 id="rfc.section.7.3.3"><a href="#rfc.section.7.3.3">7.3.3.</a> <a href="#new-transport-parameters" id="new-transport-parameters">New Transport Parameters</a></h3>
<p id="rfc.section.7.3.3.p.1">New transport parameters can be used to negotiate new protocol behavior.  An endpoint MUST ignore transport parameters that it does not support.  Absence of a transport parameter therefore disables any optional protocol feature that is negotiated using the parameter.</p>
<p id="rfc.section.7.3.3.p.2">New transport parameters can be registered according to the rules in <a href="#iana-transport-parameters">Section 14.1</a>.</p>
<h3 id="rfc.section.7.3.4"><a href="#rfc.section.7.3.4">7.3.4.</a> <a href="#version-validation" id="version-validation">Version Negotiation Validation</a></h3>
<p id="rfc.section.7.3.4.p.1">The transport parameters include three fields that encode version information.  These retroactively authenticate the version negotiation (see <a href="#version-negotiation">Section 7.1</a>) that is performed prior to the cryptographic handshake.</p>
<p id="rfc.section.7.3.4.p.2">The cryptographic handshake provides integrity protection for the negotiated version as part of the transport parameters (see <a href="#transport-parameters">Section 7.3</a>).  As a result, modification of version negotiation packets by an attacker can be detected.</p>
<p id="rfc.section.7.3.4.p.3">The client includes two fields in the transport parameters:</p>
<p/>

<ul>
  <li>The negotiated_version is the version that was finally selected for use.  This MUST be identical to the value that is on the packet that carries the ClientHello.  A server that receives a negotiated_version that does not match the version of QUIC that is in use MUST terminate the connection with a QUIC_VERSION_NEGOTIATION_MISMATCH error code.</li>
  <li>The initial_version is the version that the client initially attempted to use.  If the server did not send a version negotiation packet <a href="#packet-version">Section 5.3</a>, this will be identical to the negotiated_version.</li>
</ul>
<p id="rfc.section.7.3.4.p.5">A server that processes all packets in a stateful fashion can remember how version negotiation was performed and validate the initial_version value.</p>
<p id="rfc.section.7.3.4.p.6">A server that does not maintain state for every packet it receives (i.e., a stateless server) uses a different process. If the initial and negotiated versions are the same, a stateless server can accept the value.</p>
<p id="rfc.section.7.3.4.p.7">If the initial version is different from the negotiated_version, a stateless server MUST check that it would have sent a version negotiation packet if it had received a packet with the indicated initial_version.  If a server would have accepted the version included in the initial_version and the value differs from the value of negotiated_version, the server MUST terminate the connection with a QUIC_VERSION_NEGOTIATION_MISMATCH error.</p>
<p id="rfc.section.7.3.4.p.8">The server includes a list of versions that it would send in any version negotiation packet (<a href="#packet-version">Section 5.3</a>) in supported_versions.  This value is set even if it did not send a version negotiation packet.</p>
<p id="rfc.section.7.3.4.p.9">The client can validate that the negotiated_version is included in the supported_versions list and - if version negotiation was performed - that it would have selected the negotiated version.  A client MUST terminate the connection with a QUIC_VERSION_NEGOTIATION_MISMATCH error code if the negotiated_version value is not included in the supported_versions list.  A client MUST terminate with a QUIC_VERSION_NEGOTIATION_MISMATCH error code if version negotiation occurred but it would have selected a different version based on the value of the supported_versions list.</p>
<h2 id="rfc.section.7.4"><a href="#rfc.section.7.4">7.4.</a> <a href="#stateless-retry" id="stateless-retry">Stateless Retries</a></h2>
<p id="rfc.section.7.4.p.1">A server can process an initial cryptographic handshake messages from a client without committing any state. This allows a server to perform address validation (<a href="#address-validation">Section 7.5</a>, or to defer connection establishment costs.</p>
<p id="rfc.section.7.4.p.2">A server that generates a response to an initial packet without retaining connection state MUST use the Server Stateless Retry packet (<a href="#packet-server-stateless">Section 5.4.2</a>).  This packet causes a client to reset its transport state and to continue the connection attempt with new connection state while maintaining the state of the cryptographic handshake.</p>
<p id="rfc.section.7.4.p.3">A server MUST NOT send multiple Server Stateless Retry packets in response to a client handshake packet.  Thus, any cryptographic handshake message that is sent MUST fit within a single packet.</p>
<p id="rfc.section.7.4.p.4">In TLS, the Server Stateless Retry packet type is used to carry the HelloRetryRequest message.</p>
<h2 id="rfc.section.7.5"><a href="#rfc.section.7.5">7.5.</a> <a href="#address-validation" id="address-validation">Proof of Source Address Ownership</a></h2>
<p id="rfc.section.7.5.p.1">Transport protocols commonly spend a round trip checking that a client owns the transport address (IP and port) that it claims.  Verifying that a client can receive packets sent to its claimed transport address protects against spoofing of this information by malicious clients.</p>
<p id="rfc.section.7.5.p.2">This technique is used primarily to avoid QUIC from being used for traffic amplification attack.  In such an attack, a packet is sent to a server with spoofed source address information that identifies a victim.  If a server generates more or larger packets in response to that packet, the attacker can use the server to send more data toward the victim than it would be able to send on its own.</p>
<p id="rfc.section.7.5.p.3">Several methods are used in QUIC to mitigate this attack.  Firstly, the initial handshake packet is padded to at least 1280 octets.  This allows a server to send a similar amount of data without risking causing an amplification attack toward an unproven remote address.</p>
<p id="rfc.section.7.5.p.4">A server eventually confirms that a client has received its messages when the cryptographic handshake successfully completes.  This might be insufficient, either because the server wishes to avoid the computational cost of completing the handshake, or it might be that the size of the packets that are sent during the handshake is too large.  This is especially important for 0-RTT, where the server might wish to provide application data traffic - such as a response to a request - in response to the data carried in the early data from the client.</p>
<p id="rfc.section.7.5.p.5">To send additional data prior to completing the cryptographic handshake, the server then needs to validate that the client owns the address that it claims.</p>
<p id="rfc.section.7.5.p.6">Source address validation is therefore performed during the establishment of a connection.  TLS provides the tools that support the feature, but basic validation is performed by the core transport protocol.</p>
<h3 id="rfc.section.7.5.1"><a href="#rfc.section.7.5.1">7.5.1.</a> <a href="#client-address-validation-procedure" id="client-address-validation-procedure">Client Address Validation Procedure</a></h3>
<p id="rfc.section.7.5.1.p.1">QUIC uses token-based address validation.  Any time the server wishes to validate a client address, it provides the client with a token.  As long as the token cannot be easily guessed (see <a href="#token-integrity">Section 7.5.3</a>), if the client is able to return that token, it proves to the server that it received the token.</p>
<p id="rfc.section.7.5.1.p.2">During the processing of the cryptographic handshake messages from a client, TLS will request that QUIC make a decision about whether to proceed based on the information it has.  TLS will provide QUIC with any token that was provided by the client.  For an initial packet, QUIC can decide to abort the connection, allow it to proceed, or request address validation.</p>
<p id="rfc.section.7.5.1.p.3">If QUIC decides to request address validation, it provides the cryptographic handshake with a token.  The contents of this token are consumed by the server that generates the token, so there is no need for a single well-defined format.  A token could include information about the claimed client address (IP and port), a timestamp, and any other supplementary information the server will need to validate the token in the future.</p>
<p id="rfc.section.7.5.1.p.4">The cryptographic handshake is responsible for enacting validation by sending the address validation token to the client.  A legitimate client will include a copy of the token when it attempts to continue the handshake.  The cryptographic handshake extracts the token then asks QUIC a second time whether the token is acceptable.  In response, QUIC can either abort the connection or permit it to proceed.</p>
<p id="rfc.section.7.5.1.p.5">A connection MAY be accepted without address validation - or with only limited validation - but a server SHOULD limit the data it sends toward an unvalidated address.  Successful completion of the cryptographic handshake implicitly provides proof that the client has received packets from the server.</p>
<h3 id="rfc.section.7.5.2"><a href="#rfc.section.7.5.2">7.5.2.</a> <a href="#address-validation-on-session-resumption" id="address-validation-on-session-resumption">Address Validation on Session Resumption</a></h3>
<p id="rfc.section.7.5.2.p.1">A server MAY provide clients with an address validation token during one connection that can be used on a subsequent connection.  Address validation is especially important with 0-RTT because a server potentially sends a significant amount of data to a client in response to 0-RTT data.</p>
<p id="rfc.section.7.5.2.p.2">A different type of token is needed when resuming.  Unlike the token that is created during a handshake, there might be some time between when the token is created and when the token is subsequently used.  Thus, a resumption token SHOULD include an expiration time.  It is also unlikely that the client port number is the same on two different connections; validating the port is therefore unlikely to be successful.</p>
<p id="rfc.section.7.5.2.p.3">This token can be provided to the cryptographic handshake immediately after establishing a connection.  QUIC might also generate an updated token if significant time passes or the client address changes for any reason (see <a href="#migration">Section 7.6</a>).  The cryptographic handshake is responsible for providing the client with the token.  In TLS the token is included in the ticket that is used for resumption and 0-RTT, which is carried in a NewSessionTicket message.</p>
<h3 id="rfc.section.7.5.3"><a href="#rfc.section.7.5.3">7.5.3.</a> <a href="#token-integrity" id="token-integrity">Address Validation Token Integrity</a></h3>
<p id="rfc.section.7.5.3.p.1">An address validation token MUST be difficult to guess.  Including a large enough random value in the token would be sufficient, but this depends on the server remembering the value it sends to clients.</p>
<p id="rfc.section.7.5.3.p.2">A token-based scheme allows the server to offload any state associated with validation to the client.  For this design to work, the token MUST be covered by integrity protection against modification or falsification by clients.  Without integrity protection, malicious clients could generate or guess values for tokens that would be accepted by the server.  Only the server requires access to the integrity protection key for tokens.</p>
<p id="rfc.section.7.5.3.p.3">In TLS the address validation token is often bundled with the information that TLS requires, such as the resumption secret.  In this case, adding integrity protection can be delegated to the cryptographic handshake protocol, avoiding redundant protection.  If integrity protection is delegated to the cryptographic handshake, an integrity failure will result in immediate cryptographic handshake failure.  If integrity protection is performed by QUIC, QUIC MUST abort the connection if the integrity check fails with a QUIC_ADDRESS_VALIDATION_FAILURE error code.</p>
<h2 id="rfc.section.7.6"><a href="#rfc.section.7.6">7.6.</a> <a href="#migration" id="migration">Connection Migration</a></h2>
<p id="rfc.section.7.6.p.1">QUIC connections are identified by their 64-bit Connection ID.  QUIC&#8217;s consistent connection ID allows connections to survive changes to the client&#8217;s IP and/or port, such as those caused by client or server migrating to a new network.  Connection migration allows a client to retain any shared state with a connection when they move networks.  This includes state that can be hard to recover such as outstanding requests, which might otherwise be lost with no easy way to retry them.</p>
<h3 id="rfc.section.7.6.1"><a href="#rfc.section.7.6.1">7.6.1.</a> <a href="#migration-linkability" id="migration-linkability">Privacy Implications of Connection Migration</a></h3>
<p id="rfc.section.7.6.1.p.1">Using a stable connection ID on multiple network paths allows a passive observer to correlate activity between those paths.  A client that moves between networks might not wish to have their activity correlated by any entity other than a server. The NEW_CONNECTION_ID message can be sent by a server to provide an unlinkable connection ID for use in case the client wishes to explicitly break linkability between two points of network attachment.</p>
<p id="rfc.section.7.6.1.p.2">A client which wishes to break linkability upon changing networks MUST use the NEW_CONNECTION_ID as well as incrementing the packet sequence number by an externally unpredictable value computed as described in <a href="#packet-number-gap">Section 7.6.1.1</a>. Packet number gaps are cumulative.  A client might skip connection IDs, but it MUST ensure that it applies the associated packet number gaps in addition to the packet number gap associated with the connection ID that it does use.</p>
<p id="rfc.section.7.6.1.p.3">A client might need to send packets on multiple networks without receiving any response from the server.  To ensure that the client is not linkable across each of these changes, a new connection ID and packet number gap are needed for each network.  To support this, a server sends multiple NEW_CONNECTION_ID messages.  Each NEW_CONNECTION_ID is marked with a sequence number.  Connection IDs MUST be used in the order in which they are numbered.</p>
<p id="rfc.section.7.6.1.p.4">A server that receives a packet that is marked with a new connection ID recovers the packet number by adding the cumulative packet number gap to its expected packet number.  A server SHOULD discard packets that contain a smaller gap than it advertised.</p>
<p id="rfc.section.7.6.1.p.5">For instance, a server might provide a packet number gap of 7 associated with a new connection ID.  If the server received packet 10 using the previous connection ID, it should expect packets on the new connection ID to start at 18.  A packet with the new connection ID and a packet number of 17 is discarded as being in error.</p>
<h4 id="rfc.section.7.6.1.1"><a href="#rfc.section.7.6.1.1">7.6.1.1.</a> <a href="#packet-number-gap" id="packet-number-gap">Packet Number Gap</a></h4>
<p id="rfc.section.7.6.1.1.p.1">In order to avoid linkage, the packet number gap MUST be externally indistinguishable from random. The packet number gap for a connection ID with sequence number is computed by encoding the sequence number as a 32-bit integer in big-endian format, and then computing:</p>
<pre>
Gap = HKDF-Expand-Label(packet_number_secret,
                        "QUIC packet sequence gap", sequence, 4)
</pre>
<p id="rfc.section.7.6.1.1.p.2">The output of HKDF-Expand-Label is interpreted as a big-endian number. &#8220;packet_number_secret&#8221; is derived from the TLS key exchange, as described in <a href="#QUIC-TLS">[QUIC-TLS]</a> Section 5.6.</p>
<h3 id="rfc.section.7.6.2"><a href="#rfc.section.7.6.2">7.6.2.</a> <a href="#address-validation-for-migrated-connections" id="address-validation-for-migrated-connections">Address Validation for Migrated Connections</a></h3>
<p id="rfc.section.7.6.2.p.1">TODO: see issue #161</p>
<h2 id="rfc.section.7.7"><a href="#rfc.section.7.7">7.7.</a> <a href="#termination" id="termination">Connection Termination</a></h2>
<p id="rfc.section.7.7.p.1">Connections should remain open until they become idle for a pre-negotiated period of time.  A QUIC connection, once established, can be terminated in one of three ways:</p>
<p/>

<ol>
  <li>Explicit Shutdown: An endpoint sends a CONNECTION_CLOSE frame to initiate a connection termination.  An endpoint may send a GOAWAY frame to the peer prior to a CONNECTION_CLOSE to indicate that the connection will soon be terminated.  A GOAWAY frame signals to the peer that any active streams will continue to be processed, but the sender of the GOAWAY will not initiate any additional streams and will not accept any new incoming streams.  On termination of the active streams, a CONNECTION_CLOSE may be sent.  If an endpoint sends a CONNECTION_CLOSE frame while unterminated streams are active (no FIN bit or RST_STREAM frames have been sent or received for one or more streams), then the peer must assume that the streams were incomplete and were abnormally terminated.</li>
  <li>Implicit Shutdown: The default idle timeout is a required parameter in connection negotiation.  The maximum is 10 minutes.  If there is no network activity for the duration of the idle timeout, the connection is closed.  By default a CONNECTION_CLOSE frame will be sent.  A silent close option can be enabled when it is expensive to send an explicit close, such as mobile networks that must wake up the radio.</li>
  <li>Abrupt Shutdown: An endpoint may send a Public Reset packet at any time during the connection to abruptly terminate an active connection.  A Public Reset packet SHOULD only be used as a final recourse.  Commonly, a public reset is expected to be sent when a packet on an established connection is received by an endpoint that is unable decrypt the packet.  For instance, if a server reboots mid-connection and loses any cryptographic state associated with open connections, and then receives a packet on an open connection, it should send a Public Reset packet in return.  (TODO: articulate rules around when a public reset should be sent.)</li>
</ol>
<p id="rfc.section.7.7.p.3">TODO: Connections that are terminated are added to a TIME_WAIT list at the server, so as to absorb any straggler packets in the network.  Discuss TIME_WAIT list.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#frame-types-and-formats" id="frame-types-and-formats">Frame Types and Formats</a></h1>
<p id="rfc.section.8.p.1">As described in <a href="#frames">Section 6</a>, Regular packets contain one or more frames.  We now describe the various QUIC frame types that can be present in a Regular packet. The use of these frames and various frame header bits are described in subsequent sections.</p>
<h2 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> <a href="#frame-stream" id="frame-stream">STREAM Frame</a></h2>
<p id="rfc.section.8.1.p.1">STREAM frames implicitly create a stream and carry stream data. The type byte for a STREAM frame contains embedded flags, and is formatted as <samp>11FSSOOD</samp>.  These bits are parsed as follows:</p>
<p/>

<ul>
  <li>The first two bits must be set to 11, indicating that this is a STREAM frame.</li>
  <li><samp>F</samp> is the FIN bit, which is used for stream termination.</li>
  <li>The <samp>SS</samp> bits encode the length of the Stream ID header field.  The values 00, 01, 02, and 03 indicate lengths of 8, 16, 24, and 32 bits long respectively.</li>
  <li>The <samp>OO</samp> bits encode the length of the Offset header field.  The values 00, 01, 02, and 03 indicate lengths of 0, 16, 32, and 64 bits long respectively.</li>
  <li>The <samp>D</samp> bit indicates whether a Data Length field is present in the STREAM header.  When set to 0, this field indicates that the Stream Data field extends to the end of the packet.  When set to 1, this field indicates that Data Length field contains the length (in bytes) of the Stream Data field.  The option to omit the length should only be used when the packet is a &#8220;full-sized&#8221; packet, to avoid the risk of corruption via padding.</li>
</ul>
<p id="rfc.section.8.1.p.3">A STREAM frame is shown below.</p>
<div id="rfc.figure.7"/>
<div id="stream-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Stream ID (8/16/24/32)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Offset (0/16/32/64)                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       [Data Length (16)]      |        Stream Data (*)      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 7: STREAM Frame Format</p>
<p id="rfc.section.8.1.p.4">The STREAM frame contains the following fields:</p>
<p/>

<dl>
  <dt>Stream ID:</dt>
  <dd style="margin-left: 8">The stream ID of the stream (see <a href="#stream-id">Section 10.1</a>).</dd>
  <dt>Offset:</dt>
  <dd style="margin-left: 8">A variable-sized unsigned number specifying the byte offset in the stream for the data in this STREAM frame.  When the offset length is 0, the offset is 0.  The first byte in the stream has an offset of 0.  The largest offset delivered on a stream - the sum of the re-constructed offset and data length - MUST be less than 2^64.</dd>
  <dt>Data Length:</dt>
  <dd style="margin-left: 8">An optional 16-bit unsigned number specifying the length of the Stream Data field in this STREAM frame.  This field is present when the <samp>D</samp> bit is set to 1.</dd>
  <dt>Stream Data:</dt>
  <dd style="margin-left: 8">The bytes from the designated stream to be delivered.</dd>
</dl>
<p id="rfc.section.8.1.p.6">A STREAM frame MUST have either non-zero data length or the FIN bit set.  When the FIN flag is sent on an empty STREAM frame, the offset in the STREAM frame MUST be one greater than the last data byte sent on this stream.</p>
<p id="rfc.section.8.1.p.7">Stream multiplexing is achieved by interleaving STREAM frames from multiple streams into one or more QUIC packets.  A single QUIC packet can include multiple STREAM frames from one or more streams.</p>
<p id="rfc.section.8.1.p.8">Implementation note: One of the benefits of QUIC is avoidance of head-of-line blocking across multiple streams.  When a packet loss occurs, only streams with data in that packet are blocked waiting for a retransmission to be received, while other streams can continue making progress.  Note that when data from multiple streams is bundled into a single QUIC packet, loss of that packet blocks all those streams from making progress.  An implementation is therefore advised to bundle as few streams as necessary in outgoing packets without losing transmission efficiency to underfilled packets.</p>
<h2 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a> <a href="#frame-ack" id="frame-ack">ACK Frame</a></h2>
<p id="rfc.section.8.2.p.1">Receivers send ACK frames to inform senders which packets they have received and processed, as well as which packets are considered missing.  The ACK frame contains between 1 and 256 ACK blocks.  ACK blocks are ranges of acknowledged packets.</p>
<p id="rfc.section.8.2.p.2">To limit ACK blocks to those that have not yet been received by the sender, the receiver SHOULD track which ACK frames have been acknowledged by its peer.  Once an ACK frame has been acknowledged, the packets it acknowledges SHOULD not be acknowledged again.</p>
<p id="rfc.section.8.2.p.3">A receiver that is only sending ACK frames will not receive acknowledgments for its packets.  Sending an occasional MAX_DATA or MAX_STREAM_DATA frame as data is received will ensure that acknowledgements are generated by a peer.  Otherwise, an endpoint MAY send a PING frame once per RTT to solicit an acknowledgment.</p>
<p id="rfc.section.8.2.p.4">To limit receiver state or the size of ACK frames, a receiver MAY limit the number of ACK blocks it sends.  A receiver can do this even without receiving acknowledgment of its ACK frames, with the knowledge this could cause the sender to unnecessarily retransmit some data.  When this is necessary, the receiver SHOULD acknowledge newly received packets and stop acknowledging packets received in the past.</p>
<p id="rfc.section.8.2.p.5">Unlike TCP SACKs, QUIC ACK blocks are cumulative and therefore irrevocable.  Once a packet has been acknowledged, even if it does not appear in a future ACK frame, it is assumed to be acknowledged.</p>
<p id="rfc.section.8.2.p.6">QUIC ACK frames contain a timestamp section with up to 255 timestamps.  Timestamps enable better congestion control, but are not required for correct loss recovery, and old timestamps are less valuable, so it is not guaranteed every timestamp will be received by the sender.  A receiver SHOULD send a timestamp exactly once for each received packet containing retransmittable frames. A receiver MAY send timestamps for non-retransmittable packets.  A receiver MUST not send timestamps in unprotected packets.</p>
<p id="rfc.section.8.2.p.7">A sender MAY intentionally skip packet numbers to introduce entropy into the connection, to avoid opportunistic acknowledgement attacks.  The sender SHOULD close the connection if an unsent packet number is acknowledged.  The format of the ACK frame is efficient at expressing blocks of missing packets; skipping packet numbers between 1 and 255 effectively provides up to 8 bits of efficient entropy on demand, which should be adequate protection against most opportunistic acknowledgement attacks.</p>
<p id="rfc.section.8.2.p.8">The type byte for a ACK frame contains embedded flags, and is formatted as <samp>101NLLMM</samp>.  These bits are parsed as follows:</p>
<p/>

<ul>
  <li>The first three bits must be set to 101 indicating that this is an ACK frame.</li>
  <li>The <samp>N</samp> bit indicates whether the frame contains a Num Blocks field.</li>
  <li>The two <samp>LL</samp> bits encode the length of the Largest Acknowledged field.  The values 00, 01, 02, and 03 indicate lengths of 8, 16, 32, and 64 bits respectively.</li>
  <li>The two <samp>MM</samp> bits encode the length of the ACK Block Length fields.  The values 00, 01, 02, and 03 indicate lengths of 8, 16, 32, and 64 bits respectively.</li>
</ul>
<p id="rfc.section.8.2.p.10">An ACK frame is shown below.</p>
<div id="rfc.figure.8"/>
<div id="ack-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|[Num Blocks(8)]|   NumTS (8)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Largest Acknowledged (8/16/32/64)            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        ACK Delay (16)         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     ACK Block Section (*)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Timestamp Section (*)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 8: ACK Frame Format</p>
<p id="rfc.section.8.2.p.11">The fields in the ACK frame are as follows:</p>
<p/>

<dl>
  <dt>Num Blocks (opt):</dt>
  <dd style="margin-left: 8">An optional 8-bit unsigned value specifying the number of additional ACK blocks (besides the required First ACK Block) in this ACK frame.  Only present if the &#8216;N&#8217; flag bit is 1.</dd>
  <dt>Num Timestamps:</dt>
  <dd style="margin-left: 8">An unsigned 8-bit number specifying the total number of &lt;packet number, timestamp&gt; pairs in the Timestamp Section.</dd>
  <dt>Largest Acknowledged:</dt>
  <dd style="margin-left: 8">A variable-sized unsigned value representing the largest packet number the peer is acknowledging in this packet (typically the largest that the peer has seen thus far.)</dd>
  <dt>ACK Delay:</dt>
  <dd style="margin-left: 8">The time from when the largest acknowledged packet, as indicated in the Largest Acknowledged field, was received by this peer to when this ACK was sent.</dd>
  <dt>ACK Block Section:</dt>
  <dd style="margin-left: 8">Contains one or more blocks of packet numbers which have been successfully received, see <a href="#ack-block-section">Section 8.2.1</a>.</dd>
  <dt>Timestamp Section:</dt>
  <dd style="margin-left: 8">Contains zero or more timestamps reporting transit delay of received packets.  See <a href="#timestamp-section">Section 8.2.2</a>.</dd>
</dl>
<h3 id="rfc.section.8.2.1"><a href="#rfc.section.8.2.1">8.2.1.</a> <a href="#ack-block-section" id="ack-block-section">ACK Block Section</a></h3>
<p id="rfc.section.8.2.1.p.1">The ACK Block Section contains between one and 256 blocks of packet numbers which have been successfully received. If the Num Blocks field is absent, only the First ACK Block length is present in this section. Otherwise, the Num Blocks field indicates how many additional blocks follow the First ACK Block Length field.</p>
<div id="rfc.figure.9"/>
<div id="ack-block-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              First ACK Block Length (8/16/32/64)            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  [Gap 1 (8)]  |       [ACK Block 1 Length (8/16/32/64)]     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  [Gap 2 (8)]  |       [ACK Block 2 Length (8/16/32/64)]     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                             ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  [Gap N (8)]  |       [ACK Block N Length (8/16/32/64)]     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 9: ACK Block Section</p>
<p id="rfc.section.8.2.1.p.2">The fields in the ACK Block Section are:</p>
<p/>

<dl>
  <dt>First ACK Block Length:</dt>
  <dd style="margin-left: 8">An unsigned packet number delta that indicates the number of contiguous additional packets being acknowledged starting at the Largest Acknowledged.</dd>
  <dt>Gap To Next Block (opt, repeated):</dt>
  <dd style="margin-left: 8">An unsigned number specifying the number of contiguous missing packets from the end of the previous ACK block to the start of the next.  Repeated &#8220;Num Blocks&#8221; times.</dd>
  <dt>ACK Block Length (opt, repeated):</dt>
  <dd style="margin-left: 8">An unsigned packet number delta that indicates the number of contiguous packets being acknowledged starting after the end of the previous gap.  Repeated &#8220;Num Blocks&#8221; times.</dd>
</dl>
<h3 id="rfc.section.8.2.2"><a href="#rfc.section.8.2.2">8.2.2.</a> <a href="#timestamp-section" id="timestamp-section">Timestamp Section</a></h3>
<p id="rfc.section.8.2.2.p.1">The Timestamp Section contains between zero and 255 measurements of packet receive times relative to the beginning of the connection.</p>
<div id="rfc.figure.10"/>
<div id="timestamp-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
| [Delta LA (8)]|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    [First Timestamp (32)]                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|[Delta LA 1(8)]| [Time Since Previous 1 (16)]  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|[Delta LA 2(8)]| [Time Since Previous 2 (16)]  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                       ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|[Delta LA N(8)]| [Time Since Previous N (16)]  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 10: Timestamp Section</p>
<p id="rfc.section.8.2.2.p.2">The fields in the Timestamp Section are:</p>
<p/>

<dl>
  <dt>Delta Largest Acknowledged (opt):</dt>
  <dd style="margin-left: 8">An optional 8-bit unsigned packet number delta specifying the delta between the largest acknowledged and the first packet whose timestamp is being reported.  In other words, this first packet number may be computed as (Largest Acknowledged - Delta Largest Acknowledged.)</dd>
  <dt>First Timestamp (opt):</dt>
  <dd style="margin-left: 8">An optional 32-bit unsigned value specifying the time delta in microseconds, from the beginning of the connection to the arrival of the packet indicated by Delta Largest Acknowledged.</dd>
  <dt>Delta Largest Acked 1..N (opt, repeated):</dt>
  <dd style="margin-left: 8">This field has the same semantics and format as &#8220;Delta Largest Acknowledged&#8221;.  Repeated &#8220;Num Timestamps - 1&#8221; times.</dd>
  <dt>Time Since Previous Timestamp 1..N(opt, repeated):</dt>
  <dd style="margin-left: 8">An optional 16-bit unsigned value specifying time delta from the previous reported timestamp.  It is encoded in the same format as the ACK Delay.  Repeated &#8220;Num Timestamps - 1&#8221; times.</dd>
</dl>
<p id="rfc.section.8.2.2.p.4">The timestamp section lists packet receipt timestamps ordered by timestamp.</p>
<h4 id="rfc.section.8.2.2.1"><a href="#rfc.section.8.2.2.1">8.2.2.1.</a> <a href="#time-format" id="time-format">Time Format</a></h4>
<p id="rfc.section.8.2.2.1.p.1">DISCUSS_AND_REPLACE: Perhaps make this format simpler.</p>
<p id="rfc.section.8.2.2.1.p.2">The time format used in the ACK frame above is a 16-bit unsigned float with 11 explicit bits of mantissa and 5 bits of explicit exponent, specifying time in microseconds.  The bit format is loosely modeled after IEEE 754.  For example, 1 microsecond is represented as 0x1, which has an exponent of zero, presented in the 5 high order bits, and mantissa of 1, presented in the 11 low order bits.  When the explicit exponent is greater than zero, an implicit high-order 12th bit of 1 is assumed in the mantissa.  For example, a floating value of 0x800 has an explicit exponent of 1, as well as an explicit mantissa of 0, but then has an effective mantissa of 4096 (12th bit is assumed to be 1).  Additionally, the actual exponent is one-less than the explicit exponent, and the value represents 4096 microseconds.  Any values larger than the representable range are clamped to 0xFFFF.</p>
<h3 id="rfc.section.8.2.3"><a href="#rfc.section.8.2.3">8.2.3.</a> <a href="#ack-frames-and-packet-protection" id="ack-frames-and-packet-protection">ACK Frames and Packet Protection</a></h3>
<p id="rfc.section.8.2.3.p.1">ACK frames that acknowledge protected packets MUST be carried in a packet that has an equivalent or greater level of packet protection.</p>
<p id="rfc.section.8.2.3.p.2">Packets that are protected with 1-RTT keys MUST be acknowledged in packets that are also protected with 1-RTT keys.</p>
<p id="rfc.section.8.2.3.p.3">A packet that is not protected and claims to acknowledge a packet number that was sent with packet protection is not valid.  An unprotected packet that carries acknowledgments for protected packets MUST be discarded in its entirety.</p>
<p id="rfc.section.8.2.3.p.4">Packets that a client sends with 0-RTT packet protection MUST be acknowledged by the server in packets protected by 1-RTT keys.  This can mean that the client is unable to use these acknowledgments if the server cryptographic handshake messages are delayed or lost.  Note that the same limitation applies to other data sent by the server protected by the 1-RTT keys.</p>
<p id="rfc.section.8.2.3.p.5">Unprotected packets, such as those that carry the initial cryptographic handshake messages, MAY be acknowledged in unprotected packets.  Unprotected packets are vulnerable to falsification or modification.  Unprotected packets can be acknowledged along with protected packets in a protected packet.</p>
<p id="rfc.section.8.2.3.p.6">An endpoint SHOULD acknowledge packets containing cryptographic handshake messages in the next unprotected packet that it sends, unless it is able to acknowledge those packets in later packets protected by 1-RTT keys.  At the completion of the cryptographic handshake, both peers send unprotected packets containing cryptographic handshake messages followed by packets protected by 1-RTT keys. An endpoint SHOULD acknowledge the unprotected packets that complete the cryptographic handshake in a protected packet, because its peer is guaranteed to have access to 1-RTT packet protection keys.</p>
<p id="rfc.section.8.2.3.p.7">For instance, a server acknowledges a TLS ClientHello in the packet that carries the TLS ServerHello; similarly, a client can acknowledge a TLS HelloRetryRequest in the packet containing a second TLS ClientHello.  The complete set of server handshake messages (TLS ServerHello through to Finished) might be acknowledged by a client in protected packets, because it is certain that the server is able to decipher the packet.</p>
<h2 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3.</a> <a href="#frame-max-data" id="frame-max-data">MAX_DATA Frame</a></h2>
<p id="rfc.section.8.3.p.1">The MAX_DATA frame (type=0x04) is used in flow control to inform the peer of the maximum amount of data that can be sent on the connection as a whole.</p>
<p id="rfc.section.8.3.p.2">The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                        Maximum Data (64)                      +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.3.p.3">The fields in the MAX_DATA frame are as follows:</p>
<p/>

<dl>
  <dt>Maximum Data:</dt>
  <dd style="margin-left: 8">A 64-bit unsigned integer indicating the maximum amount of data that can be sent on the entire connection, in units of 1024 octets.  That is, the updated connection-level data limit is determined by multiplying the encoded value by 1024.</dd>
</dl>
<p id="rfc.section.8.3.p.5">All data sent in STREAM frames counts toward this limit, with the exception of data on stream 0.  The sum of the largest received offsets on all streams - including closed streams, but excluding stream 0 - MUST NOT exceed the value advertised by a receiver.  An endpoint MUST terminate a connection with a QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA error if it receives more data than the maximum data value that it has sent, unless this is a result of a change in the initial limits (see <a href="#zerortt-parameters">Section 7.3.2</a>).</p>
<h2 id="rfc.section.8.4"><a href="#rfc.section.8.4">8.4.</a> <a href="#frame-max-stream-data" id="frame-max-stream-data">MAX_STREAM_DATA Frame</a></h2>
<p id="rfc.section.8.4.p.1">The MAX_STREAM_DATA frame (type=0x05) is used in flow control to inform a peer of the maximum amount of data that can be sent on a stream.</p>
<p id="rfc.section.8.4.p.2">The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (32)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                    Maximum Stream Data (64)                   +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.4.p.3">The fields in the MAX_STREAM_DATA frame are as follows:</p>
<p/>

<dl>
  <dt>Stream ID:</dt>
  <dd style="margin-left: 8">The stream ID of the stream that is affected.</dd>
  <dt>Maximum Stream Data:</dt>
  <dd style="margin-left: 8">A 64-bit unsigned integer indicating the maximum amount of data that can be sent on the identified stream, in units of octets.</dd>
</dl>
<p id="rfc.section.8.4.p.5">When counting data toward this limit, an endpoint accounts for the largest received offset of data that is sent or received on the stream.  Loss or reordering can mean that the largest received offset on a stream can be greater than the total size of data received on that stream.  Receiving STREAM frames might not increase the largest received offset.</p>
<p id="rfc.section.8.4.p.6">The data sent on a stream MUST NOT exceed the largest maximum stream data value advertised by the receiver.  An endpoint MUST terminate a connection with a QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA error if it receives more data than the largest maximum stream data that it has sent for the affected stream, unless this is a result of a change in the initial limits (see <a href="#zerortt-parameters">Section 7.3.2</a>).</p>
<h2 id="rfc.section.8.5"><a href="#rfc.section.8.5">8.5.</a> <a href="#frame-max-stream-id" id="frame-max-stream-id">MAX_STREAM_ID Frame</a></h2>
<p id="rfc.section.8.5.p.1">The MAX_STREAM_ID frame (type=0x06) informs the peer of the maximum stream ID that they are permitted to open.</p>
<p id="rfc.section.8.5.p.2">The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Maximum Stream ID (32)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.5.p.3">The fields in the MAX_STREAM_ID frame are as follows:</p>
<p/>

<dl>
  <dt>Maximum Stream ID:</dt>
  <dd style="margin-left: 8">ID of the maximum peer-initiated stream ID for the connection.</dd>
</dl>
<p id="rfc.section.8.5.p.5">Loss or reordering can mean that a MAX_STREAM_ID frame can be received which states a lower stream limit than the client has previously received.  MAX_STREAM_ID frames which do not increase the maximum stream ID MUST be ignored.</p>
<p id="rfc.section.8.5.p.6">A peer MUST NOT initiate a stream with a higher stream ID than the greatest maximum stream ID it has received.  An endpoint MUST terminate a connection with a QUIC_TOO_MANY_OPEN_STREAMS error if a peer initiates a stream with a higher stream ID than it has sent, unless this is a result of a change in the initial limits (see <a href="#zerortt-parameters">Section 7.3.2</a>).</p>
<h2 id="rfc.section.8.6"><a href="#rfc.section.8.6">8.6.</a> <a href="#frame-blocked" id="frame-blocked">BLOCKED Frame</a></h2>
<p id="rfc.section.8.6.p.1">A sender sends a BLOCKED frame (type=0x08) when it wishes to send data, but is unable to due to connection-level flow control (see <a href="#blocking">Section 11.2.1</a>). BLOCKED frames can be used as input to tuning of flow control algorithms (see <a href="#fc-credit">Section 11.1.2</a>).</p>
<p id="rfc.section.8.6.p.2">The BLOCKED frame does not contain a payload.</p>
<h2 id="rfc.section.8.7"><a href="#rfc.section.8.7">8.7.</a> <a href="#frame-stream-blocked" id="frame-stream-blocked">STREAM_BLOCKED Frame</a></h2>
<p id="rfc.section.8.7.p.1">A sender sends a STREAM_BLOCKED frame (type=0x09) when it wishes to send data, but is unable to due to stream-level flow control.  This frame is analogous to BLOCKED (<a href="#frame-blocked">Section 8.6</a>).</p>
<p id="rfc.section.8.7.p.2">The STREAM_BLOCKED frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (32)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.7.p.3">The STREAM_BLOCKED frame contains a single field:</p>
<p/>

<dl>
  <dt>Stream ID:</dt>
  <dd style="margin-left: 8">A 32-bit unsigned number indicating the stream which is flow control blocked.</dd>
</dl>
<p id="rfc.section.8.7.p.5">An endpoint MAY send a STREAM_BLOCKED frame for a stream that exceeds the maximum stream ID set by its peer (see <a href="#frame-max-stream-id">Section 8.5</a>).  This does not open the stream, but informs the peer that a new stream was needed, but the stream limit prevented the creation of the stream.</p>
<h2 id="rfc.section.8.8"><a href="#rfc.section.8.8">8.8.</a> <a href="#frame-stream-id-needed" id="frame-stream-id-needed">STREAM_ID_NEEDED Frame</a></h2>
<p id="rfc.section.8.8.p.1">A sender sends a STREAM_ID_NEEDED frame (type=0x0a) when it wishes to open a stream, but is unable to due to the maximum stream ID limit.</p>
<p id="rfc.section.8.8.p.2">The STREAM_ID_NEEDED frame does not contain a payload.</p>
<h2 id="rfc.section.8.9"><a href="#rfc.section.8.9">8.9.</a> <a href="#frame-rst-stream" id="frame-rst-stream">RST_STREAM Frame</a></h2>
<p id="rfc.section.8.9.p.1">An endpoint may use a RST_STREAM frame (type=0x01) to abruptly terminate a stream.</p>
<p id="rfc.section.8.9.p.2">After sending a RST_STREAM, an endpoint ceases transmission of STREAM frames on the identified stream.  A receiver of RST_STREAM can discard any data that it already received on that stream.  An endpoint sends a RST_STREAM in response to a RST_STREAM unless the stream is already closed.</p>
<p id="rfc.section.8.9.p.3">The RST_STREAM frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (32)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Error Code (32)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                       Final Offset (64)                       +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.9.p.4">The fields are:</p>
<p/>

<dl>
  <dt>Stream ID:</dt>
  <dd style="margin-left: 8">The 32-bit Stream ID of the stream being terminated.</dd>
  <dt>Error code:</dt>
  <dd style="margin-left: 8">A 32-bit error code which indicates why the stream is being closed.</dd>
  <dt>Final offset:</dt>
  <dd style="margin-left: 8">A 64-bit unsigned integer indicating the absolute byte offset of the end of data written on this stream by the RST_STREAM sender.</dd>
</dl>
<h2 id="rfc.section.8.10"><a href="#rfc.section.8.10">8.10.</a> <a href="#frame-padding" id="frame-padding">PADDING Frame</a></h2>
<p id="rfc.section.8.10.p.1">The PADDING frame (type=0x00) has no semantic value.  PADDING frames can be used to increase the size of a packet.  Padding can be used to increase an initial client packet to the minimum required size, or to provide protection against traffic analysis for protected packets.</p>
<p id="rfc.section.8.10.p.2">A PADDING frame has no content.  That is, a PADDING frame consists of the single octet that identifies the frame as a PADDING frame.</p>
<h2 id="rfc.section.8.11"><a href="#rfc.section.8.11">8.11.</a> <a href="#frame-ping" id="frame-ping">PING frame</a></h2>
<p id="rfc.section.8.11.p.1">Endpoints can use PING frames (type=0x07) to verify that their peers are still alive or to check reachability to the peer. The PING frame contains no additional fields. The receiver of a PING frame simply needs to acknowledge the packet containing this frame. The PING frame SHOULD be used to keep a connection alive when a stream is open. The default is to send a PING frame after 15 seconds of quiescence. A PING frame has no additional fields.</p>
<h2 id="rfc.section.8.12"><a href="#rfc.section.8.12">8.12.</a> <a href="#frame-new-connection-id" id="frame-new-connection-id">NEW_CONNECTION_ID Frame</a></h2>
<p id="rfc.section.8.12.p.1">A server sends a NEW_CONNECTION_ID to provide the client with alternative connection IDs that can be used to break linkability when migrating connections (see <a href="#migration-linkability">Section 7.6.1</a>).</p>
<p id="rfc.section.8.12.p.2">The NEW_CONNECTION_ID is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Sequence (16)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                        Connection ID (64)                     +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.12.p.3">The fields are:</p>
<p/>

<dl>
  <dt>Sequence:</dt>
  <dd style="margin-left: 8">A 16-bit sequence number.  This value starts at 0 and increases by 1 for each connection ID that is provided by the server.  The sequence value can wrap; the value 65535 is followed by 0.  When wrapping the sequence field, the server MUST ensure that a value with the same sequence has been received and acknowledged by the client.  The connection ID that is assigned during the handshake is assumed to have a sequence of 65535.</dd>
  <dt>Connection ID:</dt>
  <dd style="margin-left: 8">A 64-bit connection ID.</dd>
</dl>
<h2 id="rfc.section.8.13"><a href="#rfc.section.8.13">8.13.</a> <a href="#frame-connection-close" id="frame-connection-close">CONNECTION_CLOSE frame</a></h2>
<p id="rfc.section.8.13.p.1">An endpoint sends a CONNECTION_CLOSE frame (type=0x02) to notify its peer that the connection is being closed.  If there are open streams that haven&#8217;t been explicitly closed, they are implicitly closed when the connection is closed.  (Ideally, a GOAWAY frame would be sent with enough time that all streams are torn down.)  The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Error Code (32)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Reason Phrase Length (16)   |      [Reason Phrase (*)]    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.13.p.2">The fields of a CONNECTION_CLOSE frame are as follows:</p>
<p/>

<dl>
  <dt>Error Code:</dt>
  <dd style="margin-left: 8">A 32-bit error code which indicates the reason for closing this connection.</dd>
  <dt>Reason Phrase Length:</dt>
  <dd style="margin-left: 8">A 16-bit unsigned number specifying the length of the reason phrase.  Note that a CONNECTION_CLOSE frame cannot be split between packets, so in practice any limits on packet size will also limit the space available for a reason phrase.</dd>
  <dt>Reason Phrase:</dt>
  <dd style="margin-left: 8">A human-readable explanation for why the connection was closed.  This can be zero length if the sender chooses to not give details beyond the Error Code.  This SHOULD be a UTF-8 encoded string <a href="#RFC3629">[RFC3629]</a>.</dd>
</dl>
<h2 id="rfc.section.8.14"><a href="#rfc.section.8.14">8.14.</a> <a href="#frame-goaway" id="frame-goaway">GOAWAY Frame</a></h2>
<p id="rfc.section.8.14.p.1">An endpoint uses a GOAWAY frame (type=0x03) to initiate a graceful shutdown of a connection.  The endpoints will continue to use any active streams, but the sender of the GOAWAY will not initiate or accept any additional streams beyond those indicated.  The GOAWAY frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Largest Client Stream ID (32)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Largest Server Stream ID (32)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.14.p.2">The fields of a GOAWAY frame are:</p>
<p/>

<dl>
  <dt>Largest Client Stream ID:</dt>
  <dd style="margin-left: 8">The highest-numbered, client-initiated stream on which the endpoint sending the GOAWAY frame either sent data, or received and delivered data.  All higher-numbered, client-initiated streams (that is, odd-numbered streams) are implicitly reset by sending or receiving the GOAWAY frame.</dd>
  <dt>Largest Server Stream ID:</dt>
  <dd style="margin-left: 8">The highest-numbered, server-initiated stream on which the endpoint sending the GOAWAY frame either sent data, or received and delivered data.  All higher-numbered, server-initiated streams (that is, even-numbered streams) are implicitly reset by sending or receiving the GOAWAY frame.</dd>
</dl>
<p id="rfc.section.8.14.p.4">A GOAWAY frame indicates that any application layer actions on streams with higher numbers than those indicated can be safely retried because no data was exchanged.  An endpoint MUST set the value of the Largest Client or Server Stream ID to be at least as high as the highest-numbered stream on which it either sent data or received and delivered data to the application protocol that uses QUIC.</p>
<p id="rfc.section.8.14.p.5">An endpoint MAY choose a larger stream identifier if it wishes to allow for a number of streams to be created.  This is especially valuable for peer-initiated streams where packets creating new streams could be in transit; using a larger stream number allows those streams to complete.</p>
<p id="rfc.section.8.14.p.6">In addition to initiating a graceful shutdown of a connection, GOAWAY MAY be sent immediately prior to sending a CONNECTION_CLOSE frame that is sent as a result of detecting a fatal error.  Higher-numbered streams than those indicated in the GOAWAY frame can then be retried.</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#packetization" id="packetization">Packetization and Reliability</a></h1>
<p id="rfc.section.9.p.1">The Path Maximum Transmission Unit (PMTU) is the maximum size of the entire IP header, UDP header, and UDP payload. The UDP payload includes the QUIC public header, protected payload, and any authentication fields.</p>
<p id="rfc.section.9.p.2">All QUIC packets SHOULD be sized to fit within the estimated PMTU to avoid IP fragmentation or packet drops. To optimize bandwidth efficiency, endpoints SHOULD use Packetization Layer PMTU Discovery (<a href="#RFC4821">[RFC4821]</a>) and MAY use PMTU Discovery (<a href="#RFC1191">[RFC1191]</a>, <a href="#RFC1981">[RFC1981]</a>) for detecting the PMTU, setting the PMTU appropriately, and storing the result of previous PMTU determinations.</p>
<p id="rfc.section.9.p.3">In the absence of these mechanisms, QUIC endpoints SHOULD NOT send IP packets larger than 1280 octets. Assuming the minimum IP header size, this results in a QUIC packet size of 1232 octets for IPv6 and 1252 octets for IPv4.</p>
<p id="rfc.section.9.p.4">QUIC endpoints that implement any kind of PMTU discovery SHOULD maintain an estimate for each combination of local and remote IP addresses (as each pairing could have a different maximum MTU in the path).</p>
<p id="rfc.section.9.p.5">QUIC depends on the network path supporting a MTU of at least 1280 octets. This is the IPv6 minimum and therefore also supported by most modern IPv4 networks.  An endpoint MUST NOT reduce their MTU below this number, even if it receives signals that indicate a smaller limit might exist.</p>
<p id="rfc.section.9.p.6">Clients MUST ensure that the first packet in a connection, and any retransmissions of those octets, has a QUIC packet size of least 1232 octets for an IPv6 packet and 1252 octets for an IPv4 packet.  In the absence of extensions to the IP header, padding to exactly these values will result in an IP packet that is 1280 octets.</p>
<p id="rfc.section.9.p.7">The initial client packet SHOULD be padded to exactly these values unless the client has a reasonable assurance that the PMTU is larger.  Sending a packet of this size ensures that the network path supports an MTU of this size and helps reduce the amplitude of amplification attacks caused by server responses toward an unverified client address.</p>
<p id="rfc.section.9.p.8">Servers MUST ignore an initial plaintext packet from a client if its total size is less than 1232 octets for IPv6 or 1252 octets for IPv4.</p>
<p id="rfc.section.9.p.9">If a QUIC endpoint determines that the PMTU between any pair of local and remote IP addresses has fallen below 1280 octets, it MUST immediately cease sending QUIC packets on the affected path.  This could result in termination of the connection if an alternative path cannot be found.</p>
<p id="rfc.section.9.p.10">A sender bundles one or more frames in a Regular QUIC packet (see <a href="#frames">Section 6</a>).</p>
<p id="rfc.section.9.p.11">A sender SHOULD minimize per-packet bandwidth and computational costs by bundling as many frames as possible within a QUIC packet.  A sender MAY wait for a short period of time to bundle multiple frames before sending a packet that is not maximally packed, to avoid sending out large numbers of small packets.  An implementation may use heuristics about expected application sending behavior to determine whether and for how long to wait.  This waiting period is an implementation decision, and an implementation should be careful to delay conservatively, since any delay is likely to increase application-visible latency.</p>
<p id="rfc.section.9.p.12">Regular QUIC packets are &#8220;containers&#8221; of frames; a packet is never retransmitted whole.  How an endpoint handles the loss of the frame depends on the type of the frame.  Some frames are simply retransmitted, some have their contents moved to new frames, and others are never retransmitted.</p>
<p id="rfc.section.9.p.13">When a packet is detected as lost, the sender re-sends any frames as necessary:</p>
<p/>

<ul>
  <li>All application data sent in STREAM frames MUST be retransmitted, unless the endpoint has sent a RST_STREAM for that stream.  When an endpoint sends a RST_STREAM frame, data outstanding on that stream SHOULD NOT be retransmitted, since subsequent data on this stream is expected to not be delivered by the receiver.</li>
  <li>ACK and PADDING frames MUST NOT be retransmitted.  ACK frames are cumulative, so new frames containing updated information will be sent as described in <a href="#frame-ack">Section 8.2</a>.</li>
  <li>All other frames MUST be retransmitted.</li>
</ul>
<p id="rfc.section.9.p.15">Upon detecting losses, a sender MUST take appropriate congestion control action.  The details of loss detection and congestion control are described in <a href="#QUIC-RECOVERY">[QUIC-RECOVERY]</a>.</p>
<p id="rfc.section.9.p.16">A packet MUST NOT be acknowledged until packet protection has been successfully removed and all frames contained in the packet have been processed.  For STREAM frames, this means the data has been queued (but not necessarily delivered to the application).  This also means that any stream state transitions triggered by STREAM or RST_STREAM frames have occurred. Once the packet has been fully processed, a receiver acknowledges receipt by sending one or more ACK frames containing the packet number of the received packet.</p>
<p id="rfc.section.9.p.17">To avoid creating an indefinite feedback loop, an endpoint MUST NOT generate an ACK frame in response to a packet containing only ACK or PADDING frames.</p>
<p id="rfc.section.9.p.18">Strategies and implications of the frequency of generating acknowledgments are discussed in more detail in <a href="#QUIC-RECOVERY">[QUIC-RECOVERY]</a>.</p>
<h2 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a> <a href="#special-considerations-for-pmtu-discovery" id="special-considerations-for-pmtu-discovery">Special Considerations for PMTU Discovery</a></h2>
<p id="rfc.section.9.1.p.1">Traditional ICMP-based path MTU discovery in IPv4 <a href="#RFC1191">[RFC1191]</a> is potentially vulnerable to off-path attacks that successfully guess the IP/port 4-tuple and reduce the MTU to a bandwidth-inefficient value. TCP connections mitigate this risk by using the (at minimum) 8 bytes of transport header echoed in the ICMP message to validate the TCP sequence number as valid for the current connection. However, as QUIC operates over UDP, in IPv4 the echoed information could consist only of the IP and UDP headers, which usually has insufficient entropy to mitigate off-path attacks.</p>
<p id="rfc.section.9.1.p.2">As a result, endpoints that implement PMTUD in IPv4 SHOULD take steps to mitigate this risk. For instance, an application could:</p>
<p/>

<ul>
  <li>Set the IPv4 Don&#8217;t Fragment (DF) bit on a small proportion of packets, so that most invalid ICMP messages arrive when there are no DF packets outstanding, and can therefore be identified as spurious.</li>
  <li>Store additional information from the IP or UDP headers from DF packets (for example, the IP ID or UDP checksum) to further authenticate incoming Datagram Too Big messages.</li>
  <li>Any reduction in PMTU due to a report contained in an ICMP packet is provisional until QUIC&#8217;s loss detection algorithm determines that the packet is actually lost.</li>
</ul>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#streams" id="streams">Streams: QUIC&#8217;s Data Structuring Abstraction</a></h1>
<p id="rfc.section.10.p.1">Streams in QUIC provide a lightweight, ordered, and bidirectional byte-stream abstraction modeled closely on HTTP/2 streams <a href="#RFC7540">[RFC7540]</a>.</p>
<p id="rfc.section.10.p.2">Streams can be created either by the client or the server, can concurrently send data interleaved with other streams, and can be cancelled.</p>
<p id="rfc.section.10.p.3">Data that is received on a stream is delivered in order within that stream, but there is no particular delivery order across streams.  Transmit ordering among streams is left to the implementation.</p>
<p id="rfc.section.10.p.4">The creation and destruction of streams are expected to have minimal bandwidth and computational cost.  A single STREAM frame may create, carry data for, and terminate a stream, or a stream may last the entire duration of a connection.</p>
<p id="rfc.section.10.p.5">Streams are individually flow controlled, allowing an endpoint to limit memory commitment and to apply back pressure.  The creation of streams is also flow controlled, with each peer declaring the maximum stream ID it is willing to accept at a given time.</p>
<p id="rfc.section.10.p.6">An alternative view of QUIC streams is as an elastic &#8220;message&#8221; abstraction, similar to the way ephemeral streams are used in SST <a href="#SST">[SST]</a>, which may be a more appealing description for some applications.</p>
<h2 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> <a href="#stream-id" id="stream-id">Stream Identifiers</a></h2>
<p id="rfc.section.10.1.p.1">Streams are identified by an unsigned 32-bit integer, referred to as the Stream ID.  To avoid Stream ID collision, clients initiate streams using odd-numbered Stream IDs; streams initiated by the server use even-numbered Stream IDs.</p>
<p id="rfc.section.10.1.p.2">Stream ID 0 (0x0) is reserved for the cryptographic handshake.  Stream 0 MUST NOT be used for application data, and is the first client-initiated stream.</p>
<p id="rfc.section.10.1.p.3">A QUIC endpoint cannot reuse a Stream ID.  Streams MUST be created in sequential order.  Open streams can be used in any order.  Streams that are used out of order result in lower-numbered streams in the same direction being counted as open.</p>
<p id="rfc.section.10.1.p.4">Stream IDs are usually encoded as a 32-bit integer, though the STREAM frame (<a href="#frame-stream">Section 8.1</a>) permits a shorter encoding when the leading bits of the stream ID are zero.</p>
<h2 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a> <a href="#life-of-a-stream" id="life-of-a-stream">Life of a Stream</a></h2>
<p id="rfc.section.10.2.p.1">The semantics of QUIC streams is based on HTTP/2 streams, and the lifecycle of a QUIC stream therefore closely follows that of an HTTP/2 stream <a href="#RFC7540">[RFC7540]</a>, with some differences to accommodate the possibility of out-of-order delivery due to the use of multiple streams in QUIC.  The lifecycle of a QUIC stream is shown in the following figure and described below.</p>
<div id="rfc.figure.11"/>
<div id="stream-lifecycle"/>
<pre>
                            +--------+
                            |        |
                            |  idle  |
                            |        |
                            +--------+
                                 |
                        send/recv STREAM/RST
                             recv MSD/SB
                                 |
                                 v
                 recv FIN/  +--------+    send FIN/
                 recv RST   |        |    send RST
                  ,---------|  open  |-----------.
                 /          |        |            \
                v           +--------+             v
         +----------+                          +----------+
         |   half   |                          |   half   |
         |  closed  |                          |  closed  |
         | (remote) |                          |  (local) |
         +----------+                          +----------+
             |                                        |
             |   send FIN/  +--------+    recv FIN/   |
              \  send RST   |        |    recv RST   /
               `-----------&gt;| closed |&lt;-------------'
                            |        |
                            +--------+

   send:   endpoint sends this frame
   recv:   endpoint receives this frame

   STREAM: a STREAM frame
   FIN:    FIN flag in a STREAM frame
   RST:    RST_STREAM frame
   MSD:    MAX_STREAM_DATA frame
   SB:     STREAM_BLOCKED frame
</pre>
<p class="figure">Figure 11: Lifecycle of a stream</p>
<p id="rfc.section.10.2.p.2">Note that this diagram shows stream state transitions and the frames and flags that affect those transitions only.  It is possible for a single frame to cause two transitions: receiving a RST_STREAM frame, or a STREAM frame with the FIN flag cause the stream state to move from &#8220;idle&#8221; to &#8220;open&#8221; and then immediately to one of the &#8220;half-closed&#8221; states.</p>
<p id="rfc.section.10.2.p.3">The recipient of a frame that changes stream state will have a delayed view of the state of a stream while the frame is in transit.  Endpoints do not coordinate the creation of streams; they are created unilaterally by either endpoint.  Endpoints can use acknowledgments to understand the peer&#8217;s subjective view of stream state at any given time.</p>
<p id="rfc.section.10.2.p.4">In the absence of more specific guidance elsewhere in this document, implementations SHOULD treat the receipt of a frame that is not expressly permitted in the description of a state as a connection error (see <a href="#error-handling">Section 12</a>).</p>
<h3 id="rfc.section.10.2.1"><a href="#rfc.section.10.2.1">10.2.1.</a> <a href="#idle" id="idle">idle</a></h3>
<p id="rfc.section.10.2.1.p.1">All streams start in the &#8220;idle&#8221; state.</p>
<p id="rfc.section.10.2.1.p.2">The following transitions are valid from this state:</p>
<p id="rfc.section.10.2.1.p.3">Sending or receiving a STREAM or RST_STREAM frame causes the identified stream to become &#8220;open&#8221;.  The stream identifier for a new stream is selected as described in <a href="#stream-id">Section 10.1</a>.  A RST_STREAM frame, or a STREAM frame with the FIN flag set also causes a stream to become &#8220;half-closed&#8221;.</p>
<p id="rfc.section.10.2.1.p.4">An endpoint might receive MAX_STREAM_DATA or STREAM_BLOCKED frames on peer-initiated streams that are &#8220;idle&#8221; if there is loss or reordering of packets.  Receiving these frames also causes the stream to become &#8220;open&#8221;.</p>
<p id="rfc.section.10.2.1.p.5">An endpoint MUST NOT send a STREAM or RST_STREAM frame for a stream ID that is higher than the peers advertised maximum stream ID (see <a href="#frame-max-stream-id">Section 8.5</a>).</p>
<h3 id="rfc.section.10.2.2"><a href="#rfc.section.10.2.2">10.2.2.</a> <a href="#open" id="open">open</a></h3>
<p id="rfc.section.10.2.2.p.1">A stream in the &#8220;open&#8221; state may be used by both peers to send frames of any type.  In this state, endpoints can send MAX_STREAM_DATA and MUST observe the value advertised by its receiving peer (see <a href="#flow-control">Section 11</a>).</p>
<p id="rfc.section.10.2.2.p.2">Opening a stream causes all lower-numbered streams in the same direction to become open.  Thus, opening an odd-numbered stream causes all &#8220;idle&#8221;, odd-numbered streams with a lower identifier to become open and the same applies to even numbered streams.  Endpoints open streams in increasing numeric order, but loss or reordering can cause packets that open streams to arrive out of order.</p>
<p id="rfc.section.10.2.2.p.3">From the &#8220;open&#8221; state, either endpoint can send a frame with the FIN flag set, which causes the stream to transition into one of the &#8220;half-closed&#8221; states.  This flag can be set on the frame that opens the stream, which causes the stream to immediately become &#8220;half-closed&#8221;.  Once an endpoint has completed sending all stream data and a STREAM frame with a FIN flag, the stream state becomes &#8220;half-closed (local)&#8221;.  When an endpoint receives all stream data a FIN flag the stream state becomes &#8220;half-closed (remote)&#8221;.  An endpoint MUST NOT consider the stream state to have changed until all data has been sent, received or discarded.</p>
<p id="rfc.section.10.2.2.p.4">A RST_STREAM frame on an &#8220;open&#8221; stream causes the stream to become &#8220;half-closed&#8221;.  A stream that becomes &#8220;open&#8221; as a result of sending or receiving RST_STREAM immediately becomes &#8220;half-closed&#8221;.  Sending a RST_STREAM frame causes the stream to become &#8220;half-closed (local)&#8221;; receiving RST_STREAM causes the stream to become &#8220;half-closed (remote)&#8221;.</p>
<p id="rfc.section.10.2.2.p.5">Any frame type that mentions a stream ID can be sent in this state.</p>
<h3 id="rfc.section.10.2.3"><a href="#rfc.section.10.2.3">10.2.3.</a> <a href="#half-closed-local" id="half-closed-local">half-closed (local)</a></h3>
<p id="rfc.section.10.2.3.p.1">A stream that is in the &#8220;half-closed (local)&#8221; state MUST NOT be used for sending on new STREAM frames.  Retransmission of data that has already been sent on STREAM frames is permitted.  An endpoint MAY also send MAX_STREAM_DATA and RST_STREAM in this state.</p>
<p id="rfc.section.10.2.3.p.2">An endpoint that closes a stream MUST NOT send data beyond the final offset that it has chosen, see <a href="#state-closed">Section 10.2.5</a> for details.</p>
<p id="rfc.section.10.2.3.p.3">A stream transitions from this state to &#8220;closed&#8221; when a STREAM frame that contains a FIN flag is received and all prior data has arrived, or when a RST_STREAM frame is received.</p>
<p id="rfc.section.10.2.3.p.4">An endpoint can receive any frame that mentions a stream ID in this state.  Providing flow-control credit using MAX_STREAM_DATA frames is necessary to continue receiving flow-controlled frames.  In this state, a receiver MAY ignore MAX_STREAM_DATA frames for this stream, which might arrive for a short period after a frame bearing the FIN flag is sent.</p>
<h3 id="rfc.section.10.2.4"><a href="#rfc.section.10.2.4">10.2.4.</a> <a href="#state-hc-remote" id="state-hc-remote">half-closed (remote)</a></h3>
<p id="rfc.section.10.2.4.p.1">A stream is &#8220;half-closed (remote)&#8221; when the stream is no longer being used by the peer to send any data.  An endpoint will have either received all data that a peer has sent or will have received a RST_STREAM frame and discarded any received data.</p>
<p id="rfc.section.10.2.4.p.2">Once all data has been either received or discarded, a sender is no longer obligated to update the maximum received data for the connection.</p>
<p id="rfc.section.10.2.4.p.3">An endpoint that receives a RST_STREAM frame (and which has not sent a FIN or a RST_STREAM) MUST immediately respond with a RST_STREAM frame, and MUST NOT send any more data on the stream.</p>
<p id="rfc.section.10.2.4.p.4">Due to reordering, an endpoint could continue receiving frames for the stream even after the stream is closed for sending.  Frames received after a peer closes a stream SHOULD be discarded.  An endpoint MAY choose to limit the period over which it ignores frames and treat frames that arrive after this time as being in error.</p>
<p id="rfc.section.10.2.4.p.5">An endpoint will know the final offset of the data it receives on a stream when it reaches the &#8220;half-closed (remote)&#8221; state, see <a href="#final-offset">Section 11.3</a> for details.</p>
<p id="rfc.section.10.2.4.p.6">A stream in this state can be used by the endpoint to send any frame that mentions a stream ID.  In this state, the endpoint MUST observe advertised stream and connection data limits (see <a href="#flow-control">Section 11</a>).</p>
<p id="rfc.section.10.2.4.p.7">A stream transitions from this state to &#8220;closed&#8221; by completing transmission of all data.  This includes sending all data carried in STREAM frames up including the terminal STREAM frame that contains a FIN flag.</p>
<p id="rfc.section.10.2.4.p.8">A stream becomes &#8220;closed&#8221; when the endpoint sends and receives acknowledgment of a RST_STREAM frame.</p>
<h3 id="rfc.section.10.2.5"><a href="#rfc.section.10.2.5">10.2.5.</a> <a href="#state-closed" id="state-closed">closed</a></h3>
<p id="rfc.section.10.2.5.p.1">The &#8220;closed&#8221; state is the terminal state for a stream.</p>
<p id="rfc.section.10.2.5.p.2">Once a stream reaches this state, no frames can be sent that mention the stream.  Reordering might cause frames to be received after closing, see <a href="#state-hc-remote">Section 10.2.4</a>.</p>
<h2 id="rfc.section.10.3"><a href="#rfc.section.10.3">10.3.</a> <a href="#stream-concurrency" id="stream-concurrency">Stream Concurrency</a></h2>
<p id="rfc.section.10.3.p.1">An endpoint limits the number of concurrently active incoming streams by adjusting the maximum stream ID.  An initial value is set in the transport parameters (see <a href="#transport-parameter-definitions">Section 7.3.1</a>) and is subsequently increased by MAX_STREAM_ID frames (see <a href="#frame-max-stream-id">Section 8.5</a>).</p>
<p id="rfc.section.10.3.p.2">The maximum stream ID is specific to each endpoint and applies only to the peer that receives the setting. That is, clients specify the maximum stream ID the server can initiate, and servers specify the maximum stream ID the client can initiate.  Each endpoint may respond on streams initiated by the other peer, regardless of whether it is permitted to initiated new streams.</p>
<p id="rfc.section.10.3.p.3">Endpoints MUST NOT exceed the limit set by their peer.  An endpoint that receives a STREAM frame with an ID greater than the limit it has sent MUST treat this as a stream error of type QUIC_TOO_MANY_OPEN_STREAMS (<a href="#error-handling">Section 12</a>), unless this is a result of a change in the initial offsets (see <a href="#zerortt-parameters">Section 7.3.2</a>).</p>
<p id="rfc.section.10.3.p.4">A receiver MUST NOT renege on an advertisement; that is, once a receiver advertises a stream ID via a MAX_STREAM_ID frame, it MUST NOT subsequently advertise a smaller maximum ID.  A sender may receive MAX_STREAM_ID frames out of order; a sender MUST therefore ignore any MAX_STREAM_ID that does not increase the maximum.</p>
<h2 id="rfc.section.10.4"><a href="#rfc.section.10.4">10.4.</a> <a href="#sending-and-receiving-data" id="sending-and-receiving-data">Sending and Receiving Data</a></h2>
<p id="rfc.section.10.4.p.1">Once a stream is created, endpoints may use the stream to send and receive data.  Each endpoint may send a series of STREAM frames encapsulating data on a stream until the stream is terminated in that direction.  Streams are an ordered byte-stream abstraction, and they have no other structure within them.  STREAM frame boundaries are not expected to be preserved in retransmissions from the sender or during delivery to the application at the receiver.</p>
<p id="rfc.section.10.4.p.2">When new data is to be sent on a stream, a sender MUST set the encapsulating STREAM frame&#8217;s offset field to the stream offset of the first byte of this new data.  The first byte of data that is sent on a stream has the stream offset 0.  The largest offset delivered on a stream MUST be less than 2^64. A receiver MUST ensure that received stream data is delivered to the application as an ordered byte-stream.  Data received out of order MUST be buffered for later delivery, as long as it is not in violation of the receiver&#8217;s flow control limits.</p>
<p id="rfc.section.10.4.p.3">An endpoint MUST NOT send data on any stream without ensuring that it is within the data limits set by its peer.  The cryptographic handshake stream, Stream 0, is exempt from the connection-level data limits established by MAX_DATA.  Stream 0 is still subject to stream-level data limits and MAX_STREAM_DATA.</p>
<p id="rfc.section.10.4.p.4">Flow control is described in detail in <a href="#flow-control">Section 11</a>, and congestion control is described in the companion document <a href="#QUIC-RECOVERY">[QUIC-RECOVERY]</a>.</p>
<h2 id="rfc.section.10.5"><a href="#rfc.section.10.5">10.5.</a> <a href="#stream-prioritization" id="stream-prioritization">Stream Prioritization</a></h2>
<p id="rfc.section.10.5.p.1">Stream multiplexing has a significant effect on application performance if resources allocated to streams are correctly prioritized.  Experience with other multiplexed protocols, such as HTTP/2 <a href="#RFC7540">[RFC7540]</a>, shows that effective prioritization strategies have a significant positive impact on performance.</p>
<p id="rfc.section.10.5.p.2">QUIC does not provide frames for exchanging prioritization information.  Instead it relies on receiving priority information from the application that uses QUIC.  Protocols that use QUIC are able to define any prioritization scheme that suits their application semantics.  A protocol might define explicit messages for signaling priority, such as those defined in HTTP/2; it could define rules that allow an endpoint to determine priority based on context; or it could leave the determination to the application.</p>
<p id="rfc.section.10.5.p.3">A QUIC implementation SHOULD provide ways in which an application can indicate the relative priority of streams.  When deciding which streams to dedicate resources to, QUIC SHOULD use the information provided by the application.  Failure to account for priority of streams can result in suboptimal performance.</p>
<p id="rfc.section.10.5.p.4">Stream priority is most relevant when deciding which stream data will be transmitted.  Often, there will be limits on what can be transmitted as a result of connection flow control or the current congestion controller state.</p>
<p id="rfc.section.10.5.p.5">Giving preference to the transmission of its own management frames ensures that the protocol functions efficiently.  That is, prioritizing frames other than STREAM frames ensures that loss recovery, congestion control, and flow control operate effectively.</p>
<p id="rfc.section.10.5.p.6">Stream 0 MUST be prioritized over other streams prior to the completion of the cryptographic handshake.  This includes the retransmission of the second flight of client handshake messages, that is, the TLS Finished and any client authentication messages.</p>
<p id="rfc.section.10.5.p.7">STREAM frames that are determined to be lost SHOULD be retransmitted before sending new data, unless application priorities indicate otherwise.  Retransmitting lost STREAM frames can fill in gaps, which allows the peer to consume already received data and free up flow control window.</p>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> <a href="#flow-control" id="flow-control">Flow Control</a></h1>
<p id="rfc.section.11.p.1">It is necessary to limit the amount of data that a sender may have outstanding at any time, so as to prevent a fast sender from overwhelming a slow receiver, or to prevent a malicious sender from consuming significant resources at a receiver.  This section describes QUIC&#8217;s flow-control mechanisms.</p>
<p id="rfc.section.11.p.2">QUIC employs a credit-based flow-control scheme similar to HTTP/2&#8217;s flow control <a href="#RFC7540">[RFC7540]</a>.  A receiver advertises the number of octets it is prepared to receive on a given stream and for the entire connection.  This leads to two levels of flow control in QUIC: (i) Connection flow control, which prevents senders from exceeding a receiver&#8217;s buffer capacity for the connection, and (ii) Stream flow control, which prevents a single stream from consuming the entire receive buffer for a connection.</p>
<p id="rfc.section.11.p.3">A receiver sends MAX_DATA or MAX_STREAM_DATA frames to the sender to advertise additional credit by sending the absolute byte offset in the connection or stream which it is willing to receive.</p>
<p id="rfc.section.11.p.4">A receiver MAY advertise a larger offset at any point by sending MAX_DATA or MAX_STREAM_DATA frames.  A receiver MUST NOT renege on an advertisement; that is, once a receiver advertises an offset, it MUST NOT subsequently advertise a smaller offset.  A sender could receive MAX_DATA or MAX_STREAM_DATA frames out of order; a sender MUST therefore ignore any flow control offset that does not move the window forward.</p>
<p id="rfc.section.11.p.5">A receiver MUST close the connection with a QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA error (<a href="#error-handling">Section 12</a>) if the peer violates the advertised connection or stream data limits.</p>
<p id="rfc.section.11.p.6">A sender MUST send BLOCKED frames to indicate it has data to write but is blocked by lack of connection or stream flow control credit.  BLOCKED frames are expected to be sent infrequently in common cases, but they are considered useful for debugging and monitoring purposes.</p>
<p id="rfc.section.11.p.7">A receiver advertises credit for a stream by sending a MAX_STREAM_DATA frame with the Stream ID set appropriately. A receiver could use the current offset of data consumed to determine the flow control offset to be advertised.  A receiver MAY send MAX_STREAM_DATA frames in multiple packets in order to make sure that the sender receives an update before running out of flow control credit, even if one of the packets is lost.</p>
<p id="rfc.section.11.p.8">Connection flow control is a limit to the total bytes of stream data sent in STREAM frames on all streams.  A receiver advertises credit for a connection by sending a MAX_DATA frame.  A receiver maintains a cumulative sum of bytes received on all streams, which are used to check for flow control violations. A receiver might use a sum of bytes consumed on all contributing streams to determine the maximum data limit to be advertised.</p>
<h2 id="rfc.section.11.1"><a href="#rfc.section.11.1">11.1.</a> <a href="#edge-cases-and-other-considerations" id="edge-cases-and-other-considerations">Edge Cases and Other Considerations</a></h2>
<p id="rfc.section.11.1.p.1">There are some edge cases which must be considered when dealing with stream and connection level flow control.  Given enough time, both endpoints must agree on flow control state.  If one end believes it can send more than the other end is willing to receive, the connection will be torn down when too much data arrives.</p>
<p id="rfc.section.11.1.p.2">Conversely if a sender believes it is blocked, while endpoint B expects more data can be received, then the connection can be in a deadlock, with the sender waiting for a MAX_DATA or MAX_STREAM_DATA frame which will never come.</p>
<p id="rfc.section.11.1.p.3">On receipt of a RST_STREAM frame, an endpoint will tear down state for the matching stream and ignore further data arriving on that stream.  This could result in the endpoints getting out of sync, since the RST_STREAM frame may have arrived out of order and there may be further bytes in flight.  The data sender would have counted the data against its connection level flow control budget, but a receiver that has not received these bytes would not know to include them as well.  The receiver must learn the number of bytes that were sent on the stream to make the same adjustment in its connection flow controller.</p>
<p id="rfc.section.11.1.p.4">To avoid this de-synchronization, a RST_STREAM sender MUST include the final byte offset sent on the stream in the RST_STREAM frame.  On receiving a RST_STREAM frame, a receiver definitively knows how many bytes were sent on that stream before the RST_STREAM frame, and the receiver MUST use the final offset to account for all bytes sent on the stream in its connection level flow controller.</p>
<h3 id="rfc.section.11.1.1"><a href="#rfc.section.11.1.1">11.1.1.</a> <a href="#response-to-a-rststream" id="response-to-a-rststream">Response to a RST_STREAM</a></h3>
<p id="rfc.section.11.1.1.p.1">Since streams are bidirectional, a sender of a RST_STREAM needs to know how many bytes the peer has sent on the stream.  If an endpoint receives a RST_STREAM frame and has sent neither a FIN nor a RST_STREAM, it MUST send a RST_STREAM in response, bearing the offset of the last byte sent on this stream as the final offset.</p>
<h3 id="rfc.section.11.1.2"><a href="#rfc.section.11.1.2">11.1.2.</a> <a href="#fc-credit" id="fc-credit">Data Limit Increments</a></h3>
<p id="rfc.section.11.1.2.p.1">This document leaves when and how many bytes to advertise in a MAX_DATA or MAX_STREAM_DATA to implementations, but offers a few considerations.  These frames contribute to connection overhead.  Therefore frequently sending frames with small changes is undesirable.  At the same time, infrequent updates require larger increments to limits if blocking is to be avoided.  Thus, larger updates require a receiver to commit to larger resource commitments.  Thus there is a tradeoff between resource commitment and overhead when determining how large a limit is advertised.</p>
<p id="rfc.section.11.1.2.p.2">A receiver MAY use an autotuning mechanism to tune the frequency and amount that it increases data limits based on a roundtrip time estimate and the rate at which the receiving application consumes data, similar to common TCP implementations.</p>
<h2 id="rfc.section.11.2"><a href="#rfc.section.11.2">11.2.</a> <a href="#stream-limit-increment" id="stream-limit-increment">Stream Limit Increment</a></h2>
<p id="rfc.section.11.2.p.1">As with flow control, this document leaves when and how many streams to make available to a peer via MAX_STREAM_ID to implementations, but offers a few considerations.  MAX_STREAM_ID frames constitute minimal overhead, while withholding MAX_STREAM_ID frames can prevent the peer from using the available parallelism.</p>
<p id="rfc.section.11.2.p.2">Implementations will likely want to increase the maximum stream ID as peer-initiated streams close.  A receiver MAY also advance the maximum stream ID based on current activity, system conditions, and other environmental factors.</p>
<h3 id="rfc.section.11.2.1"><a href="#rfc.section.11.2.1">11.2.1.</a> <a href="#blocking" id="blocking">Blocking on Flow Control</a></h3>
<p id="rfc.section.11.2.1.p.1">If a sender does not receive a MAX_DATA or MAX_STREAM_DATA frame when it has run out of flow control credit, the sender will be blocked and MUST send a BLOCKED or STREAM_BLOCKED frame.  These frames are expected to be useful for debugging at the receiver; they do not require any other action.  A receiver SHOULD NOT wait for a BLOCKED or STREAM_BLOCKED frame before sending MAX_DATA or MAX_STREAM_DATA, since doing so will mean that a sender is unable to send for an entire round trip.</p>
<p id="rfc.section.11.2.1.p.2">For smooth operation of the congestion controller, it is generally considered best to not let the sender go into quiescence if avoidable.  To avoid blocking a sender, and to reasonably account for the possibiity of loss, a receiver should send a MAX_DATA or MAX_STREAM_DATA frame at least two roundtrips before it expects the sender to get blocked.</p>
<p id="rfc.section.11.2.1.p.3">A sender sends a single BLOCKED or STREAM_BLOCKED frame only once when it reaches a data limit.  A sender MUST NOT send multiple BLOCKED or STREAM_BLOCKED frames for the same data limit, unless the original frame is determined to be lost.  Another BLOCKED or STREAM_BLOCKED frame can be sent after the data limit is increased.</p>
<h2 id="rfc.section.11.3"><a href="#rfc.section.11.3">11.3.</a> <a href="#final-offset" id="final-offset">Stream Final Offset</a></h2>
<p id="rfc.section.11.3.p.1">The final offset is the count of the number of octets that are transmitted on a stream.  For a stream that is reset, the final offset is carried explicitly in the RST_STREAM frame.  Otherwise, the final offset is the offset of the end of the data carried in STREAM frame marked with a FIN flag.</p>
<p id="rfc.section.11.3.p.2">An endpoint will know the final offset for a stream when the stream enters the &#8220;half-closed (remote)&#8221; state.  However, if there is reordering or loss, an endpoint might learn the final offset prior to entering this state if it is carried on a STREAM frame.</p>
<p id="rfc.section.11.3.p.3">An endpoint MUST NOT send data on a stream at or beyond the final offset.</p>
<p id="rfc.section.11.3.p.4">Once a final offset for a stream is known, it cannot change.  If a RST_STREAM or STREAM frame causes the final offset to change for a stream, an endpoint SHOULD respond with a QUIC_STREAM_DATA_AFTER_TERMINATION error (see <a href="#error-handling">Section 12</a>).  A receiver SHOULD treat receipt of data at or beyond the final offset as a QUIC_STREAM_DATA_AFTER_TERMINATION error, even after a stream is closed.  Generating these errors is not mandatory, but only because requiring that an endpoint generate these errors also means that the endpoint needs to maintain the final offset state for closed streams, which could mean a significant state commitment.</p>
<h1 id="rfc.section.12"><a href="#rfc.section.12">12.</a> <a href="#error-handling" id="error-handling">Error Handling</a></h1>
<p id="rfc.section.12.p.1">An endpoint that detects an error SHOULD signal the existence of that error to its peer.  Errors can affect an entire connection (see <a href="#connection-errors">Section 12.1</a>), or a single stream (see <a href="#stream-errors">Section 12.2</a>).</p>
<p id="rfc.section.12.p.2">The most appropriate error code (<a href="#error-codes">Section 12.3</a>) SHOULD be included in the frame that signals the error.  Where this specification identifies error conditions, it also identifies the error code that is used.</p>
<p id="rfc.section.12.p.3">Public Reset is not suitable for any error that can be signaled with a CONNECTION_CLOSE or RST_STREAM frame.  Public Reset MUST NOT be sent by an endpoint that has the state necessary to send a frame on the connection.</p>
<h2 id="rfc.section.12.1"><a href="#rfc.section.12.1">12.1.</a> <a href="#connection-errors" id="connection-errors">Connection Errors</a></h2>
<p id="rfc.section.12.1.p.1">Errors that result in the connection being unusable, such as an obvious violation of protocol semantics or corruption of state that affects an entire connection, MUST be signaled using a CONNECTION_CLOSE frame (<a href="#frame-connection-close">Section 8.13</a>). An endpoint MAY close the connection in this manner, even if the error only affects a single stream.</p>
<p id="rfc.section.12.1.p.2">A CONNECTION_CLOSE frame could be sent in a packet that is lost.  An endpoint SHOULD be prepared to retransmit a packet containing a CONNECTION_CLOSE frame if it receives more packets on a terminated connection.  Limiting the number of retransmissions and the time over which this final packet is sent limits the effort expended on terminated connections.</p>
<p id="rfc.section.12.1.p.3">An endpoint that chooses not to retransmit packets containing CONNECTION_CLOSE risks a peer missing the first such packet.  The only mechanism available to an endpoint that continues to receive data for a terminated connection is to send a Public Reset packet.</p>
<h2 id="rfc.section.12.2"><a href="#rfc.section.12.2">12.2.</a> <a href="#stream-errors" id="stream-errors">Stream Errors</a></h2>
<p id="rfc.section.12.2.p.1">If the error affects a single stream, but otherwise leaves the connection in a recoverable state, the endpoint can send a RST_STREAM frame (<a href="#frame-rst-stream">Section 8.9</a>) with an appropriate error code to terminate just the affected stream.</p>
<p id="rfc.section.12.2.p.2">Stream 0 is critical to the functioning of the entire connection.  If stream 0 is closed with either a RST_STREAM or STREAM frame bearing the FIN flag, an endpoint MUST generate a connection error of type QUIC_CLOSED_CRITICAL_STREAM.</p>
<p id="rfc.section.12.2.p.3">Some application protocols make other streams critical to that protocol.  An application protocol does not need to inform the transport that a stream is critical; it can instead generate appropriate errors in response to being notified that the critical stream is closed.</p>
<p id="rfc.section.12.2.p.4">An endpoint MAY send a RST_STREAM frame in the same packet as a CONNECTION_CLOSE frame.</p>
<h2 id="rfc.section.12.3"><a href="#rfc.section.12.3">12.3.</a> <a href="#error-codes" id="error-codes">Error Codes</a></h2>
<p id="rfc.section.12.3.p.1">Error codes are 32 bits long, with the first two bits indicating the source of the error code:</p>
<p/>

<dl>
  <dt>0x00000000-0x3FFFFFFF:</dt>
  <dd style="margin-left: 8">Application-specific error codes.  Defined by each application-layer protocol.</dd>
  <dt>0x40000000-0x7FFFFFFF:</dt>
  <dd style="margin-left: 8">Reserved for host-local error codes.  These codes MUST NOT be sent to a peer, but MAY be used in API return codes and logs.</dd>
  <dt>0x80000000-0xBFFFFFFF:</dt>
  <dd style="margin-left: 8">QUIC transport error codes, including packet protection errors.  Applicable to all uses of QUIC.</dd>
  <dt>0xC0000000-0xFFFFFFFF:</dt>
  <dd style="margin-left: 8">Cryptographic error codes.  Defined by the cryptographic handshake protocol in use.</dd>
</dl>
<p id="rfc.section.12.3.p.3">This section lists the defined QUIC transport error codes that may be used in a CONNECTION_CLOSE or RST_STREAM frame. Error codes share a common code space.  Some error codes apply only to either streams or the entire connection and have no defined semantics in the other context.</p>
<p/>

<dl>
  <dt>QUIC_INTERNAL_ERROR (0x80000001):</dt>
  <dd style="margin-left: 8">Connection has reached an invalid state.</dd>
  <dt>QUIC_STREAM_DATA_AFTER_TERMINATION (0x80000002):</dt>
  <dd style="margin-left: 8">There were data frames after the a fin or reset.</dd>
  <dt>QUIC_INVALID_PACKET_HEADER (0x80000003):</dt>
  <dd style="margin-left: 8">Control frame is malformed.</dd>
  <dt>QUIC_INVALID_FRAME_DATA (0x80000004):</dt>
  <dd style="margin-left: 8">Frame data is malformed.</dd>
  <dt>QUIC_MULTIPLE_TERMINATION_OFFSETS (0x80000005):</dt>
  <dd style="margin-left: 8">Multiple final offset values were received on the same stream</dd>
  <dt>QUIC_STREAM_CANCELLED (0x80000006):</dt>
  <dd style="margin-left: 8">The stream was cancelled</dd>
  <dt>QUIC_CLOSED_CRITICAL_STREAM (0x80000007):</dt>
  <dd style="margin-left: 8">A stream that is critical to the protocol was closed.</dd>
  <dt>QUIC_MISSING_PAYLOAD (0x80000030):</dt>
  <dd style="margin-left: 8">The packet contained no payload.</dd>
  <dt>QUIC_INVALID_STREAM_DATA (0x8000002E):</dt>
  <dd style="margin-left: 8">STREAM frame data is malformed.</dd>
  <dt>QUIC_UNENCRYPTED_STREAM_DATA (0x8000003D):</dt>
  <dd style="margin-left: 8">Received STREAM frame data is not encrypted.</dd>
  <dt>QUIC_MAYBE_CORRUPTED_MEMORY (0x80000059):</dt>
  <dd style="margin-left: 8">Received a frame which is likely the result of memory corruption.</dd>
  <dt>QUIC_INVALID_RST_STREAM_DATA (0x80000006):</dt>
  <dd style="margin-left: 8">RST_STREAM frame data is malformed.</dd>
  <dt>QUIC_INVALID_CONNECTION_CLOSE_DATA (0x80000007):</dt>
  <dd style="margin-left: 8">CONNECTION_CLOSE frame data is malformed.</dd>
  <dt>QUIC_INVALID_GOAWAY_DATA (0x80000008):</dt>
  <dd style="margin-left: 8">GOAWAY frame data is malformed.</dd>
  <dt>QUIC_INVALID_WINDOW_UPDATE_DATA (0x80000039):</dt>
  <dd style="margin-left: 8">WINDOW_UPDATE frame data is malformed.</dd>
  <dt>QUIC_INVALID_BLOCKED_DATA (0x8000003A):</dt>
  <dd style="margin-left: 8">BLOCKED frame data is malformed.</dd>
  <dt>QUIC_INVALID_PATH_CLOSE_DATA (0x8000004E):</dt>
  <dd style="margin-left: 8">PATH_CLOSE frame data is malformed.</dd>
  <dt>QUIC_INVALID_ACK_DATA (0x80000009):</dt>
  <dd style="margin-left: 8">ACK frame data is malformed.</dd>
  <dt>QUIC_INVALID_VERSION_NEGOTIATION_PACKET (0x8000000A):</dt>
  <dd style="margin-left: 8">Version negotiation packet is malformed.</dd>
  <dt>QUIC_INVALID_PUBLIC_RST_PACKET (0x8000000b):</dt>
  <dd style="margin-left: 8">Public RST packet is malformed.</dd>
  <dt>QUIC_DECRYPTION_FAILURE (0x8000000c):</dt>
  <dd style="margin-left: 8">There was an error decrypting.</dd>
  <dt>QUIC_ENCRYPTION_FAILURE (0x8000000d):</dt>
  <dd style="margin-left: 8">There was an error encrypting.</dd>
  <dt>QUIC_PACKET_TOO_LARGE (0x8000000e):</dt>
  <dd style="margin-left: 8">The packet exceeded kMaxPacketSize.</dd>
  <dt>QUIC_PEER_GOING_AWAY (0x80000010):</dt>
  <dd style="margin-left: 8">The peer is going away. May be a client or server.</dd>
  <dt>QUIC_INVALID_STREAM_ID (0x80000011):</dt>
  <dd style="margin-left: 8">A stream ID was invalid.</dd>
  <dt>QUIC_INVALID_PRIORITY (0x80000031):</dt>
  <dd style="margin-left: 8">A priority was invalid.</dd>
  <dt>QUIC_TOO_MANY_OPEN_STREAMS (0x80000012):</dt>
  <dd style="margin-left: 8">Too many streams already open.</dd>
  <dt>QUIC_TOO_MANY_AVAILABLE_STREAMS (0x8000004c):</dt>
  <dd style="margin-left: 8">The peer created too many available streams.</dd>
  <dt>QUIC_PUBLIC_RESET (0x80000013):</dt>
  <dd style="margin-left: 8">Received public reset for this connection.</dd>
  <dt>QUIC_INVALID_VERSION (0x80000014):</dt>
  <dd style="margin-left: 8">Invalid protocol version.</dd>
  <dt>QUIC_INVALID_HEADER_ID (0x80000016):</dt>
  <dd style="margin-left: 8">The Header ID for a stream was too far from the previous.</dd>
  <dt>QUIC_INVALID_NEGOTIATED_VALUE (0x80000017):</dt>
  <dd style="margin-left: 8">Negotiable parameter received during handshake had invalid value.</dd>
  <dt>QUIC_DECOMPRESSION_FAILURE (0x80000018):</dt>
  <dd style="margin-left: 8">There was an error decompressing data.</dd>
  <dt>QUIC_NETWORK_IDLE_TIMEOUT (0x80000019):</dt>
  <dd style="margin-left: 8">The connection timed out due to no network activity.</dd>
  <dt>QUIC_HANDSHAKE_TIMEOUT (0x80000043):</dt>
  <dd style="margin-left: 8">The connection timed out waiting for the handshake to complete.</dd>
  <dt>QUIC_ERROR_MIGRATING_ADDRESS (0x8000001a):</dt>
  <dd style="margin-left: 8">There was an error encountered migrating addresses.</dd>
  <dt>QUIC_ERROR_MIGRATING_PORT (0x80000056):</dt>
  <dd style="margin-left: 8">There was an error encountered migrating port only.</dd>
  <dt>QUIC_EMPTY_STREAM_FRAME_NO_FIN (0x80000032):</dt>
  <dd style="margin-left: 8">We received a STREAM_FRAME with no data and no fin flag set.</dd>
  <dt>QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA (0x8000003b):</dt>
  <dd style="margin-left: 8">The peer received too much data, violating flow control.</dd>
  <dt>QUIC_FLOW_CONTROL_SENT_TOO_MUCH_DATA (0x8000003f):</dt>
  <dd style="margin-left: 8">The peer sent too much data, violating flow control.</dd>
  <dt>QUIC_FLOW_CONTROL_INVALID_WINDOW (0x80000040):</dt>
  <dd style="margin-left: 8">The peer received an invalid flow control window.</dd>
  <dt>QUIC_CONNECTION_IP_POOLED (0x8000003e):</dt>
  <dd style="margin-left: 8">The connection has been IP pooled into an existing connection.</dd>
  <dt>QUIC_TOO_MANY_OUTSTANDING_SENT_PACKETS (0x80000044):</dt>
  <dd style="margin-left: 8">The connection has too many outstanding sent packets.</dd>
  <dt>QUIC_TOO_MANY_OUTSTANDING_RECEIVED_PACKETS (0x80000045):</dt>
  <dd style="margin-left: 8">The connection has too many outstanding received packets.</dd>
  <dt>QUIC_CONNECTION_CANCELLED (0x80000046):</dt>
  <dd style="margin-left: 8">The QUIC connection has been cancelled.</dd>
  <dt>QUIC_BAD_PACKET_LOSS_RATE (0x80000047):</dt>
  <dd style="margin-left: 8">Disabled QUIC because of high packet loss rate.</dd>
  <dt>QUIC_PUBLIC_RESETS_POST_HANDSHAKE (0x80000049):</dt>
  <dd style="margin-left: 8">Disabled QUIC because of too many PUBLIC_RESETs post handshake.</dd>
  <dt>QUIC_TIMEOUTS_WITH_OPEN_STREAMS (0x8000004a):</dt>
  <dd style="margin-left: 8">Disabled QUIC because of too many timeouts with streams open.</dd>
  <dt>QUIC_TOO_MANY_RTOS (0x80000055):</dt>
  <dd style="margin-left: 8">QUIC timed out after too many RTOs.</dd>
  <dt>QUIC_ENCRYPTION_LEVEL_INCORRECT (0x8000002c):</dt>
  <dd style="margin-left: 8">A packet was received with the wrong encryption level (i.e. it should have been encrypted but was not.)</dd>
  <dt>QUIC_VERSION_NEGOTIATION_MISMATCH (0x80000037):</dt>
  <dd style="margin-left: 8">This connection involved a version negotiation which appears to have been tampered with.</dd>
  <dt>QUIC_IP_ADDRESS_CHANGED (0x80000050):</dt>
  <dd style="margin-left: 8">IP address changed causing connection close.</dd>
  <dt>QUIC_ADDRESS_VALIDATION_FAILURE (0x80000051):</dt>
  <dd style="margin-left: 8">Client address validation failed.</dd>
  <dt>QUIC_TOO_MANY_FRAME_GAPS (0x8000005d):</dt>
  <dd style="margin-left: 8">Stream frames arrived too discontiguously so that stream sequencer buffer maintains too many gaps.</dd>
  <dt>QUIC_TOO_MANY_SESSIONS_ON_SERVER (0x80000060):</dt>
  <dd style="margin-left: 8">Connection closed because server hit max number of sessions allowed.</dd>
</dl>
<h1 id="rfc.section.13"><a href="#rfc.section.13">13.</a> <a href="#security-and-privacy-considerations" id="security-and-privacy-considerations">Security and Privacy Considerations</a></h1>
<h2 id="rfc.section.13.1"><a href="#rfc.section.13.1">13.1.</a> <a href="#spoofed-ack-attack" id="spoofed-ack-attack">Spoofed ACK Attack</a></h2>
<p id="rfc.section.13.1.p.1">An attacker receives an STK from the server and then releases the IP address on which it received the STK.  The attacker may, in the future, spoof this same address (which now presumably addresses a different endpoint), and initiate a 0-RTT connection with a server on the victim&#8217;s behalf.  The attacker then spoofs ACK frames to the server which cause the server to potentially drown the victim in data.</p>
<p id="rfc.section.13.1.p.2">There are two possible mitigations to this attack.  The simplest one is that a server can unilaterally create a gap in packet-number space.  In the non-attack scenario, the client will send an ACK frame with the larger value for largest acknowledged.  In the attack scenario, the attacker could acknowledge a packet in the gap.  If the server sees an acknowledgment for a packet that was never sent, the connection can be aborted.</p>
<p id="rfc.section.13.1.p.3">The second mitigation is that the server can require that acknowledgments for sent packets match the encryption level of the sent packet.  This mitigation is useful if the connection has an ephemeral forward-secure key that is generated and used for every new connection.  If a packet sent is protected with a forward-secure key, then any acknowledgments that are received for them MUST also be forward-secure protected.  Since the attacker will not have the forward secure key, the attacker will not be able to generate forward-secure protected packets with ACK frames.</p>
<h2 id="rfc.section.13.2"><a href="#rfc.section.13.2">13.2.</a> <a href="#slowloris-attacks" id="slowloris-attacks">Slowloris Attacks</a></h2>
<p id="rfc.section.13.2.p.1">The attacks commonly known as Slowloris <a href="#SLOWLORIS">[SLOWLORIS]</a> try to keep many connections to the target endpoint open and hold them open as long as possible.  These attacks can be executed against a QUIC endpoint by generating the minimum amount of activity necessary to avoid being closed for inactivity.  This might involve sending small amounts of data, gradually opening flow control windows in order to control the sender rate, or manufacturing ACK frames that simulate a high loss rate.</p>
<p id="rfc.section.13.2.p.2">QUIC deployments SHOULD provide mitigations for the Slowloris attacks, such as increasing the maximum number of clients the server will allow, limiting the number of connections a single IP address is allowed to make, imposing restrictions on the minimum transfer speed a connection is allowed to have, and restricting the length of time an endpoint is allowed to stay connected.</p>
<h2 id="rfc.section.13.3"><a href="#rfc.section.13.3">13.3.</a> <a href="#stream-fragmentation-and-reassembly-attacks" id="stream-fragmentation-and-reassembly-attacks">Stream Fragmentation and Reassembly Attacks</a></h2>
<p id="rfc.section.13.3.p.1">An adversarial endpoint might intentionally fragment the data on stream buffers in order to cause disproportionate memory commitment.  An adversarial endpoint could open a stream and send some STREAM frames containing arbitrary fragments of the stream content.</p>
<p id="rfc.section.13.3.p.2">The attack is mitigated if flow control windows correspond to available memory.  However, some receivers will over-commit memory and advertise flow control offsets in the aggregate that exceed actual available memory.  The over-commitment strategy can lead to better performance when endpoints are well behaved, but renders endpoints vulnerable to the stream fragmentation attack.</p>
<p id="rfc.section.13.3.p.3">QUIC deployments SHOULD provide mitigations against the stream fragmentation attack.  Mitigations could consist of avoiding over-committing memory, delaying reassembly of STREAM frames, implementing heuristics based on the age and duration of reassembly holes, or some combination.</p>
<h2 id="rfc.section.13.4"><a href="#rfc.section.13.4">13.4.</a> <a href="#stream-commitment-attack" id="stream-commitment-attack">Stream Commitment Attack</a></h2>
<p id="rfc.section.13.4.p.1">An adversarial endpoint can open lots of streams, exhausting state on an endpoint.  The adversarial endpoint could repeat the process on a large number of connections, in a manner similar to SYN flooding attacks in TCP.</p>
<p id="rfc.section.13.4.p.2">Normally, clients will open streams sequentially, as explained in <a href="#stream-id">Section 10.1</a>.  However, when several streams are initiated at short intervals, transmission error may cause STREAM DATA frames opening streams to be received out of sequence.  A receiver is obligated to open intervening streams if a higher-numbered stream ID is received.  Thus, on a new connection, opening stream 2000001 opens 1 million streams, as required by the specification.</p>
<p id="rfc.section.13.4.p.3">The number of active streams is limited by the concurrent stream limit transport parameter, as explained in <a href="#stream-concurrency">Section 10.3</a>.  If chosen judisciously, this limit mitigates the effect of the stream commitment attack.  However, setting the limit too low could affect performance when applications expect to open large number of streams.</p>
<h1 id="rfc.section.14"><a href="#rfc.section.14">14.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<h2 id="rfc.section.14.1"><a href="#rfc.section.14.1">14.1.</a> <a href="#iana-transport-parameters" id="iana-transport-parameters">QUIC Transport Parameter Registry</a></h2>
<p id="rfc.section.14.1.p.1">IANA [SHALL add/has added] a registry for &#8220;QUIC Transport Parameters&#8221; under a &#8220;QUIC Protocol&#8221; heading.</p>
<p id="rfc.section.14.1.p.2">The &#8220;QUIC Transport Parameters&#8221; registry governs a 16-bit space.  This space is split into two spaces that are governed by different policies.  Values with the first byte in the range 0x00 to 0xfe (in hexadecimal) are assigned via the Specification Required policy <a href="#RFC5226">[RFC5226]</a>.  Values with the first byte 0xff are reserved for Private Use <a href="#RFC5226">[RFC5226]</a>.</p>
<p id="rfc.section.14.1.p.3">Registrations MUST include the following fields:</p>
<p/>

<dl>
  <dt>Value:</dt>
  <dd style="margin-left: 8">The numeric value of the assignment (registrations will be between 0x0000 and 0xfeff).</dd>
  <dt>Parameter Name:</dt>
  <dd style="margin-left: 8">A short mnemonic for the parameter.</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">A reference to a publicly available specification for the value.</dd>
</dl>
<p id="rfc.section.14.1.p.5">The nominated expert(s) verify that a specification exists and is readily accessible.  The expert(s) are encouraged to be biased towards approving registrations unless they are abusive, frivolous, or actively harmful (not merely aesthetically displeasing, or architecturally dubious).</p>
<p id="rfc.section.14.1.p.6">The initial contents of this registry are shown in <a href="#iana-tp-table">Table 4</a>.</p>
<div id="rfc.table.4"/>
<div id="iana-tp-table"/>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>Initial QUIC Transport Parameters Entries</caption>
  <thead>
    <tr>
      <th class="left">Value</th>
      <th class="left">Parameter Name</th>
      <th class="left">Specification</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">0x0000</td>
      <td class="left">initial_max_stream_data</td>
      <td class="left">
        <a href="#transport-parameter-definitions">Section 7.3.1</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x0001</td>
      <td class="left">initial_max_data</td>
      <td class="left">
        <a href="#transport-parameter-definitions">Section 7.3.1</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x0002</td>
      <td class="left">initial_max_stream_id</td>
      <td class="left">
        <a href="#transport-parameter-definitions">Section 7.3.1</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x0003</td>
      <td class="left">idle_timeout</td>
      <td class="left">
        <a href="#transport-parameter-definitions">Section 7.3.1</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x0004</td>
      <td class="left">truncate_connection_id</td>
      <td class="left">
        <a href="#transport-parameter-definitions">Section 7.3.1</a>
      </td>
    </tr>
    <tr>
      <td class="left">0x0005</td>
      <td class="left">max_packet_size</td>
      <td class="left">
        <a href="#transport-parameter-definitions">Section 7.3.1</a>
      </td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references"><a href="#rfc.references">15.</a> References</h1>
<h2 id="rfc.references.1"><a href="#rfc.references.1">15.1.</a> Normative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-tls13-20">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-20, April 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="QUIC-RECOVERY">[QUIC-RECOVERY]</b>
      </td>
      <td class="top"><a title="Google">Iyengar, J.</a> and <a title="Google">I. Swett</a>, "<a href="http://tools.ietf.org/html/draft-ietf-quic-recovery">QUIC Loss Detection and Congestion Control</a>", Internet-Draft draft-ietf-quic-recovery, June 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="QUIC-TLS">[QUIC-TLS]</b>
      </td>
      <td class="top"><a title="Mozilla">Thomson, M.</a> and <a title="sn3rd">S. Turner</a>, "<a href="http://tools.ietf.org/html/draft-ietf-quic-tls">Using Transport Layer Security (TLS) to Secure QUIC</a>", Internet-Draft draft-ietf-quic-tls, June 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC1191">[RFC1191]</b>
      </td>
      <td class="top"><a>Mogul, J.</a> and <a>S. Deering</a>, "<a href="http://tools.ietf.org/html/rfc1191">Path MTU discovery</a>", RFC 1191, DOI 10.17487/RFC1191, November 1990.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC1981">[RFC1981]</b>
      </td>
      <td class="top"><a>McCann, J.</a>, <a>Deering, S.</a> and <a>J. Mogul</a>, "<a href="http://tools.ietf.org/html/rfc1981">Path MTU Discovery for IP version 6</a>", RFC 1981, DOI 10.17487/RFC1981, August 1996.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3629">[RFC3629]</b>
      </td>
      <td class="top"><a>Yergeau, F.</a>, "<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4821">[RFC4821]</b>
      </td>
      <td class="top"><a>Mathis, M.</a> and <a>J. Heffner</a>, "<a href="http://tools.ietf.org/html/rfc4821">Packetization Layer Path MTU Discovery</a>", RFC 4821, DOI 10.17487/RFC4821, March 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5226">[RFC5226]</b>
      </td>
      <td class="top"><a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", RFC 5226, DOI 10.17487/RFC5226, May 2008.</td>
    </tr>
  </tbody>
</table>
<h2 id="rfc.references.2"><a href="#rfc.references.2">15.2.</a> Informative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="EARLY-DESIGN">[EARLY-DESIGN]</b>
      </td>
      <td class="top"><a>Roskind, J.</a>, "<a href="https://goo.gl/dMVtFi">QUIC: Multiplexed Transport Over UDP</a>", December 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2360">[RFC2360]</b>
      </td>
      <td class="top"><a>Scott, G.</a>, "<a href="http://tools.ietf.org/html/rfc2360">Guide for Internet Standards Writers</a>", BCP 22, RFC 2360, DOI 10.17487/RFC2360, June 1998.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4086">[RFC4086]</b>
      </td>
      <td class="top"><a>Eastlake 3rd, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6824">[RFC6824]</b>
      </td>
      <td class="top"><a>Ford, A.</a>, <a>Raiciu, C.</a>, <a>Handley, M.</a> and <a>O. Bonaventure</a>, "<a href="http://tools.ietf.org/html/rfc6824">TCP Extensions for Multipath Operation with Multiple Addresses</a>", RFC 6824, DOI 10.17487/RFC6824, January 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7301">[RFC7301]</b>
      </td>
      <td class="top"><a>Friedl, S.</a>, <a>Popov, A.</a>, <a>Langley, A.</a> and <a>E. Stephan</a>, "<a href="http://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>", RFC 7301, DOI 10.17487/RFC7301, July 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7540">[RFC7540]</b>
      </td>
      <td class="top"><a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SLOWLORIS">[SLOWLORIS]</b>
      </td>
      <td class="top"><a>RSnake Hansen, R.</a>, "<a href="https://web.archive.org/web/20150315054838/http://ha.ckers.org/slowloris/">Welcome to Slowloris...</a>", June 2009.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SST">[SST]</b>
      </td>
      <td class="top"><a>Ford, B.</a>, "<a>Structured streams</a>", ACM SIGCOMM Computer Communication Review Vol. 37, pp. 361, DOI 10.1145/1282427.1282421, October 2007.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#contributors" id="contributors">Contributors</a></h1>
<p id="rfc.section.A.p.1">The original authors of this specification were Ryan Hamilton, Jana Iyengar, Ian Swett, and Alyssa Wilk.</p>
<p id="rfc.section.A.p.2">The original design and rationale behind this protocol draw significantly from work by Jim Roskind <a href="#EARLY-DESIGN">[EARLY-DESIGN]</a>. In alphabetical order, the contributors to the pre-IETF QUIC project at Google are: Britt Cyr, Jeremy Dorfman, Ryan Hamilton, Jana Iyengar, Fedor Kouranov, Charles Krasic, Jo Kulik, Adam Langley, Jim Roskind, Robbie Shade, Satyam Shekhar, Cherie Shi, Ian Swett, Raman Tenneti, Victor Vasiliev, Antonio Vicente, Patrik Westin, Alyssa Wilk, Dale Worley, Fan Yang, Dan Zhang, Daniel Ziegler.</p>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.B.p.1">Special thanks are due to the following for helping shape pre-IETF QUIC and its deployment: Chris Bentzel, Misha Efimov, Roberto Peon, Alistair Riddoch, Siddharth Vijayakrishnan, and Assar Westerlund.</p>
<p id="rfc.section.B.p.2">This document has benefited immensely from various private discussions and public ones on the quic@ietf.org and proto-quic@chromium.org mailing lists. Our thanks to all.</p>
<h1 id="rfc.appendix.C"><a href="#rfc.appendix.C">Appendix C.</a> <a href="#change-log" id="change-log">Change Log</a></h1>
<p/>

<ul class="empty">
  <li><strong>RFC Editor&#8217;s Note:</strong> Please remove this section prior to publication of a final version of this document.</li>
</ul>
<p id="rfc.section.C.p.2">Issue and pull request numbers are listed with a leading octothorp.</p>
<h2 id="rfc.appendix.C.1"><a href="#rfc.appendix.C.1">C.1.</a> <a href="#since-draft-ietf-quic-transport-03" id="since-draft-ietf-quic-transport-03">Since draft-ietf-quic-transport-03</a></h2>
<p/>

<ul>
  <li>Change STREAM and RST_STREAM layout</li>
  <li>Add MAX_STREAM_ID settings</li>
</ul>
<h2 id="rfc.appendix.C.2"><a href="#rfc.appendix.C.2">C.2.</a> <a href="#since-draft-ietf-quic-transport-02" id="since-draft-ietf-quic-transport-02">Since draft-ietf-quic-transport-02</a></h2>
<p/>

<ul>
  <li>The size of the initial packet payload has a fixed minimum (#267, #472)</li>
  <li>Define when Version Negotiation packets are ignored (#284, #294, #241, #143, #474)</li>
  <li>The 64-bit FNV-1a algorithm is used for integrity protection of unprotected packets (#167, #480, #481, #517)</li>
  <li>Rework initial packet types to change how the connection ID is chosen (#482, #442, #493)</li>
  <li>No timestamps are forbidden in unprotected packets (#542, #429)</li>
  <li>Cryptographic handshake is now on stream 0 (#456)</li>
  <li>Remove congestion control exemption for cryptographic handshake (#248, #476)</li>
  <li>Version 1 of QUIC uses TLS; a new version is needed to use a different handshake protocol (#516)</li>
  <li>STREAM frames have a reduced number of offset lengths (#543, #430)</li>
  <li>Split some frames into separate connection- and stream- level frames (#443) <ul><li>WINDOW_UPDATE split into MAX_DATA and MAX_STREAM_DATA (#450)</li><li>BLOCKED split to match WINDOW_UPDATE split (#454)</li><li>Define STREAM_ID_NEEDED frame (#455)</li></ul></li>
  <li>A NEW_CONNECTION_ID frame supports connection migration without linkability (#232, #491, #496)</li>
  <li>Transport parameters for 0-RTT are retained from a previous connection (#512) <ul><li>A client in 0-RTT no longer required to reset excess streams (#425, #479)</li></ul></li>
  <li>Expanded security considerations (#440, #444, #445, #448)</li>
</ul>
<h2 id="rfc.appendix.C.3"><a href="#rfc.appendix.C.3">C.3.</a> <a href="#since-draft-ietf-quic-transport-01" id="since-draft-ietf-quic-transport-01">Since draft-ietf-quic-transport-01</a></h2>
<p/>

<ul>
  <li>Defined short and long packet headers (#40, #148, #361)</li>
  <li>Defined a versioning scheme and stable fields (#51, #361)</li>
  <li>Define reserved version values for &#8220;greasing&#8221; negotiation (#112, #278)</li>
  <li>The initial packet number is randomized (#35, #283)</li>
  <li>Narrow the packet number encoding range requirement (#67, #286, #299, #323, #356)</li>
  <li>Defined client address validation (#52, #118, #120, #275)</li>
  <li>Define transport parameters as a TLS extension (#49, #122)</li>
  <li>SCUP and COPT parameters are no longer valid (#116, #117)</li>
  <li>Transport parameters for 0-RTT are either remembered from before, or assume default values (#126)</li>
  <li>The server chooses connection IDs in its final flight (#119, #349, #361)</li>
  <li>The server echoes the Connection ID and packet number fields when sending a Version Negotiation packet (#133, #295, #244)</li>
  <li>Defined a minimum packet size for the initial handshake packet from the client (#69, #136, #139, #164)</li>
  <li>Path MTU Discovery (#64, #106)</li>
  <li>The initial handshake packet from the client needs to fit in a single packet (#338)</li>
  <li>Forbid acknowledgment of packets containing only ACK and PADDING (#291)</li>
  <li>Require that frames are processed when packets are acknowledged (#381, #341)</li>
  <li>Removed the STOP_WAITING frame (#66)</li>
  <li>Don&#8217;t require retransmission of old timestamps for lost ACK frames (#308)</li>
  <li>Clarified that frames are not retransmitted, but the information in them can be (#157, #298)</li>
  <li>Error handling definitions (#335)</li>
  <li>Split error codes into four sections (#74)</li>
  <li>Forbid the use of Public Reset where CONNECTION_CLOSE is possible (#289)</li>
  <li>Define packet protection rules (#336)</li>
  <li>Require that stream be entirely delivered or reset, including acknowledgment of all STREAM frames or the RST_STREAM, before it closes (#381)</li>
  <li>Remove stream reservation from state machine (#174, #280)</li>
  <li>Only stream 1 does not contribute to connection-level flow control (#204)</li>
  <li>Stream 1 counts towards the maximum concurrent stream limit (#201, #282)</li>
  <li>Remove connection-level flow control exclusion for some streams (except 1) (#246)</li>
  <li>RST_STREAM affects connection-level flow control (#162, #163)</li>
  <li>Flow control accounting uses the maximum data offset on each stream, rather than bytes received (#378)</li>
  <li>Moved length-determining fields to the start of STREAM and ACK (#168, #277)</li>
  <li>Added the ability to pad between frames (#158, #276)</li>
  <li>Remove error code and reason phrase from GOAWAY (#352, #355)</li>
  <li>GOAWAY includes a final stream number for both directions (#347)</li>
  <li>Error codes for RST_STREAM and CONNECTION_CLOSE are now at a consistent offset (#249)</li>
  <li>Defined priority as the responsibility of the application protocol (#104, #303)</li>
</ul>
<h2 id="rfc.appendix.C.4"><a href="#rfc.appendix.C.4">C.4.</a> <a href="#since-draft-ietf-quic-transport-00" id="since-draft-ietf-quic-transport-00">Since draft-ietf-quic-transport-00</a></h2>
<p/>

<ul>
  <li>Replaced DIVERSIFICATION_NONCE flag with KEY_PHASE flag</li>
  <li>Defined versioning</li>
  <li>Reworked description of packet and frame layout</li>
  <li>Error code space is divided into regions for each component</li>
  <li>Use big endian for all numeric values</li>
</ul>
<h2 id="rfc.appendix.C.5"><a href="#rfc.appendix.C.5">C.5.</a> <a href="#since-draft-hamilton-quic-transport-protocol-01" id="since-draft-hamilton-quic-transport-protocol-01">Since draft-hamilton-quic-transport-protocol-01</a></h2>
<p/>

<ul>
  <li>Adopted as base for draft-ietf-quic-tls</li>
  <li>Updated authors/editors list</li>
  <li>Added IANA Considerations section</li>
  <li>Moved Contributors and Acknowledgments to appendices</li>
</ul>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jana Iyengar</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Iyengar</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jri@google.com">jri@google.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/quicwg/base-drafts">Fork me on GitHub</a></div></div>
</body>
</html>
