<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>QUIC Loss Detection and Congestion Control</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Notational Conventions"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Design of the QUIC Transmission Machinery"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Relevant Differences Between QUIC and TCP"/>
<link href="#rfc.section.2.1.1" rel="Chapter" title="2.1.1 Monotonically Increasing Packet Numbers"/>
<link href="#rfc.section.2.1.2" rel="Chapter" title="2.1.2 No Reneging"/>
<link href="#rfc.section.2.1.3" rel="Chapter" title="2.1.3 More ACK Ranges"/>
<link href="#rfc.section.2.1.4" rel="Chapter" title="2.1.4 Explicit Correction For Delayed Acks"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Loss Detection"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Constants of interest"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Variables of interest"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Initialization"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Setting the Loss Detection Alarm"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 On Sending a Packet"/>
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 On Ack Receipt"/>
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 On Packet Acknowledgment"/>
<link href="#rfc.section.3.8" rel="Chapter" title="3.8 Setting the Loss Detection Alarm"/>
<link href="#rfc.section.3.8.1" rel="Chapter" title="3.8.1 Handshake Packets"/>
<link href="#rfc.section.3.8.2" rel="Chapter" title="3.8.2 Psuedocode"/>
<link href="#rfc.section.3.9" rel="Chapter" title="3.9 On Alarm Firing"/>
<link href="#rfc.section.3.10" rel="Chapter" title="3.10 Detecting Lost Packets"/>
<link href="#rfc.section.3.10.1" rel="Chapter" title="3.10.1 Handshake Packets"/>
<link href="#rfc.section.3.10.2" rel="Chapter" title="3.10.2 Psuedocode"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Congestion Control"/>
<link href="#rfc.section.5" rel="Chapter" title="5 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="6 References"/>
<link href="#rfc.references.1" rel="Chapter" title="6.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="6.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Acknowledgments"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Change Log"/>
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Since draft-ietf-quic-recovery-00:"/>
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Since draft-iyengar-quic-loss-recovery-01:"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Iyengar, J., Ed. and I. Swett, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-recovery-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-2-23" />
  <meta name="dct.abstract" content="QUIC is a new multiplexed and secure transport atop UDP.  QUIC builds on decades of transport and security experience, and implements mechanisms that make it attractive as a modern general-purpose transport.  QUIC implements the spirit of known TCP loss detection mechanisms, described in RFCs, various Internet-drafts, and also those prevalent in the Linux TCP implementation.  This document describes QUIC loss detection and congestion control, and attributes the TCP equivalent in RFCs, Internet-drafts, academic papers, and TCP implementations." />
  <meta name="description" content="QUIC is a new multiplexed and secure transport atop UDP.  QUIC builds on decades of transport and security experience, and implements mechanisms that make it attractive as a modern general-purpose transport.  QUIC implements the spirit of known TCP loss detection mechanisms, described in RFCs, various Internet-drafts, and also those prevalent in the Linux TCP implementation.  This document describes QUIC loss detection and congestion control, and attributes the TCP equivalent in RFCs, Internet-drafts, academic papers, and TCP implementations." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">QUIC</td>
  <td class="right">J. Iyengar, Ed.</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">I. Swett, Ed.</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">Google</td>
</tr>
<tr>
  <td class="left">Expires: August 27, 2017</td>
  <td class="right">February 23, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">QUIC Loss Detection and Congestion Control<br />
  <span class="filename">draft-ietf-quic-recovery-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>QUIC is a new multiplexed and secure transport atop UDP.  QUIC builds on decades of transport and security experience, and implements mechanisms that make it attractive as a modern general-purpose transport.  QUIC implements the spirit of known TCP loss detection mechanisms, described in RFCs, various Internet-drafts, and also those prevalent in the Linux TCP implementation.  This document describes QUIC loss detection and congestion control, and attributes the TCP equivalent in RFCs, Internet-drafts, academic papers, and TCP implementations.</p>
<h1>
  <a>Note to Readers</a>
</h1>
<p>Discussion of this draft takes place on the QUIC working group mailing list (quic@ietf.org), which is archived at <a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a>.</p>
<p>Working Group information can be found at <a href="https://github.com/quicwg">https://github.com/quicwg</a>; source code and issues list for this draft can be found at <a href="https://github.com/quicwg/base-drafts/labels/recovery">https://github.com/quicwg/base-drafts/labels/recovery</a>.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 27, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Notational Conventions</a></li>
</ul><li>2.   <a href="#rfc.section.2">Design of the QUIC Transmission Machinery</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Relevant Differences Between QUIC and TCP</a></li>
<ul><li>2.1.1.   <a href="#rfc.section.2.1.1">Monotonically Increasing Packet Numbers</a></li>
<li>2.1.2.   <a href="#rfc.section.2.1.2">No Reneging</a></li>
<li>2.1.3.   <a href="#rfc.section.2.1.3">More ACK Ranges</a></li>
<li>2.1.4.   <a href="#rfc.section.2.1.4">Explicit Correction For Delayed Acks</a></li>
</ul></ul><li>3.   <a href="#rfc.section.3">Loss Detection</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Constants of interest</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Variables of interest</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Initialization</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Setting the Loss Detection Alarm</a></li>
<li>3.5.   <a href="#rfc.section.3.5">On Sending a Packet</a></li>
<li>3.6.   <a href="#rfc.section.3.6">On Ack Receipt</a></li>
<li>3.7.   <a href="#rfc.section.3.7">On Packet Acknowledgment</a></li>
<li>3.8.   <a href="#rfc.section.3.8">Setting the Loss Detection Alarm</a></li>
<ul><li>3.8.1.   <a href="#rfc.section.3.8.1">Handshake Packets</a></li>
<li>3.8.2.   <a href="#rfc.section.3.8.2">Psuedocode</a></li>
</ul><li>3.9.   <a href="#rfc.section.3.9">On Alarm Firing</a></li>
<li>3.10.   <a href="#rfc.section.3.10">Detecting Lost Packets</a></li>
<ul><li>3.10.1.   <a href="#rfc.section.3.10.1">Handshake Packets</a></li>
<li>3.10.2.   <a href="#rfc.section.3.10.2">Psuedocode</a></li>
</ul></ul><li>4.   <a href="#rfc.section.4">Congestion Control</a></li>
<li>5.   <a href="#rfc.section.5">IANA Considerations</a></li>
<li>6.   <a href="#rfc.references">References</a></li>
<ul><li>6.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>6.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Acknowledgments</a></li>
<li>Appendix B.   <a href="#rfc.appendix.B">Change Log</a></li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Since draft-ietf-quic-recovery-00:</a></li>
<li>B.2.   <a href="#rfc.appendix.B.2">Since draft-iyengar-quic-loss-recovery-01:</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">QUIC is a new multiplexed and secure transport atop UDP.  QUIC builds on decades of transport and security experience, and implements mechanisms that make it attractive as a modern general-purpose transport.  The QUIC protocol is described in <a href="#QUIC-TRANSPORT">[QUIC-TRANSPORT]</a>.</p>
<p id="rfc.section.1.p.2">QUIC implements the spirit of known TCP loss recovery mechanisms, described in RFCs, various Internet-drafts, and also those prevalent in the Linux TCP implementation.  This document describes QUIC congestion control and loss recovery, and where applicable, attributes the TCP equivalent in RFCs, Internet-drafts, academic papers, and/or TCP implementations.</p>
<p id="rfc.section.1.p.3">This document first describes pre-requisite parts of the QUIC transmission machinery, then discusses QUIC&#8217;s default congestion control and loss detection mechanisms, and finally lists the various TCP mechanisms that QUIC loss detection implements (in spirit.)</p>
<h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a></h2>
<p id="rfc.section.1.1.p.1">The words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221;, and &#8220;MAY&#8221; are used in this document.  It&#8217;s not shouting; when they are capitalized, they have the special meaning defined in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#design-of-the-quic-transmission-machinery" id="design-of-the-quic-transmission-machinery">Design of the QUIC Transmission Machinery</a></h1>
<p id="rfc.section.2.p.1">All transmissions in QUIC are sent with a packet-level header, which includes a packet sequence number (referred to below as a packet number).  These packet numbers never repeat in the lifetime of a connection, and are monotonically increasing, which makes duplicate detection trivial.  This fundamental design decision obviates the need for disambiguating between transmissions and retransmissions and eliminates significant complexity from QUIC&#8217;s interpretation of TCP loss detection mechanisms.</p>
<p id="rfc.section.2.p.2">Every packet may contain several frames.  We outline the frames that are important to the loss detection and congestion control machinery below.</p>
<p/>

<ul>
  <li>Retransmittable frames are frames requiring reliable delivery.  The most common are STREAM frames, which typically contain application data.</li>
  <li>Crypto handshake data is also sent as STREAM data, and uses the reliability machinery of QUIC underneath.</li>
  <li>ACK frames contain acknowledgment information.  QUIC uses a SACK-based scheme, where acks express up to 256 ranges.  The ACK frame also includes a receive timestamp for each packet newly acked.</li>
</ul>
<h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#relevant-differences-between-quic-and-tcp" id="relevant-differences-between-quic-and-tcp">Relevant Differences Between QUIC and TCP</a></h2>
<p id="rfc.section.2.1.p.1">There are some notable differences between QUIC and TCP which are important for reasoning about the differences between the loss recovery mechanisms employed by the two protocols.  We briefly describe these differences below.</p>
<h3 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1.</a> <a href="#monotonically-increasing-packet-numbers" id="monotonically-increasing-packet-numbers">Monotonically Increasing Packet Numbers</a></h3>
<p id="rfc.section.2.1.1.p.1">TCP conflates transmission sequence number at the sender with delivery sequence number at the receiver, which results in retransmissions of the same data carrying the same sequence number, and consequently to problems caused by &#8220;retransmission ambiguity&#8221;.  QUIC separates the two: QUIC uses a packet sequence number (referred to as the &#8220;packet number&#8221;) for transmissions, and any data that is to be delivered to the receiving application(s) is sent in one or more streams, with stream offsets encoded within STREAM frames inside of packets that determine delivery order.</p>
<p id="rfc.section.2.1.1.p.2">QUIC&#8217;s packet number is strictly increasing, and directly encodes transmission order.  A higher QUIC packet number signifies that the packet was sent later, and a lower QUIC packet number signifies that the packet was sent earlier.  When a packet containing frames is deemed lost, QUIC rebundles necessary frames in a new packet with a new packet number, removing ambiguity about which packet is acknowledged when an ACK is received.  Consequently, more accurate RTT measurements can be made, spurious retransmissions are trivially detected, and mechanisms such as Fast Retransmit can be applied universally, based only on packet number.</p>
<p id="rfc.section.2.1.1.p.3">This design point significantly simplifies loss detection mechanisms for QUIC.  Most TCP mechanisms implicitly attempt to infer transmission ordering based on TCP sequence numbers - a non-trivial task, especially when TCP timestamps are not available.</p>
<h3 id="rfc.section.2.1.2"><a href="#rfc.section.2.1.2">2.1.2.</a> <a href="#no-reneging" id="no-reneging">No Reneging</a></h3>
<p id="rfc.section.2.1.2.p.1">QUIC ACKs contain information that is equivalent to TCP SACK, but QUIC does not allow any acked packet to be reneged, greatly simplifying implementations on both sides and reducing memory pressure on the sender.</p>
<h3 id="rfc.section.2.1.3"><a href="#rfc.section.2.1.3">2.1.3.</a> <a href="#more-ack-ranges" id="more-ack-ranges">More ACK Ranges</a></h3>
<p id="rfc.section.2.1.3.p.1">QUIC supports up to 256 ACK ranges, opposed to TCP&#8217;s 3 SACK ranges.  In high loss environments, this speeds recovery.</p>
<h3 id="rfc.section.2.1.4"><a href="#rfc.section.2.1.4">2.1.4.</a> <a href="#explicit-correction-for-delayed-acks" id="explicit-correction-for-delayed-acks">Explicit Correction For Delayed Acks</a></h3>
<p id="rfc.section.2.1.4.p.1">QUIC ACKs explicitly encode the delay incurred at the receiver between when a packet is received and when the corresponding ACK is sent.  This allows the receiver of the ACK to adjust for receiver delays, specifically the delayed ack timer, when estimating the path RTT.  This mechanism also allows a receiver to measure and report the delay from when a packet was received by the OS kernel, which is useful in receivers which may incur delays such as context-switch latency before a userspace QUIC receiver processes a received packet.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#loss-detection" id="loss-detection">Loss Detection</a></h1>
<p id="rfc.section.3.p.1">We now describe QUIC&#8217;s loss detection as functions that should be called on packet transmission, when a packet is acked, and timer expiration events.</p>
<h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#constants-of-interest" id="constants-of-interest">Constants of interest</a></h2>
<p id="rfc.section.3.1.p.1">Constants used in loss recovery and congestion control are based on a combination of RFCs, papers, and common practice.  Some may need to be changed or negotiated in order to better suit a variety of environments.</p>
<p/>

<dl>
  <dt>kMaxTLPs (default 2):</dt>
  <dd style="margin-left: 8">Maximum number of tail loss probes before an RTO fires.</dd>
  <dt>kReorderingThreshold (default 3):</dt>
  <dd style="margin-left: 8">Maximum reordering in packet number space before FACK style loss detection considers a packet lost.</dd>
  <dt>kTimeReorderingThreshold (default 1/8):</dt>
  <dd style="margin-left: 8">Maximum reordering in time sapce before time based loss detection considers a packet lost.  In fraction of an RTT.</dd>
  <dt>kMinTLPTimeout (default 10ms):</dt>
  <dd style="margin-left: 8">Minimum time in the future a tail loss probe alarm may be set for.</dd>
  <dt>kMinRTOTimeout (default 200ms):</dt>
  <dd style="margin-left: 8">Minimum time in the future an RTO alarm may be set for.</dd>
  <dt>kDelayedAckTimeout (default 25ms):</dt>
  <dd style="margin-left: 8">The length of the peer&#8217;s delayed ack timer.</dd>
  <dt>kDefaultInitialRtt (default 200ms):</dt>
  <dd style="margin-left: 8">The default RTT used before an RTT sample is taken.</dd>
</dl>
<h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#variables-of-interest" id="variables-of-interest">Variables of interest</a></h2>
<p id="rfc.section.3.2.p.1">We first describe the variables required to implement the loss detection mechanisms described in this section.</p>
<p/>

<dl>
  <dt>loss_detection_alarm:</dt>
  <dd style="margin-left: 8">Multi-modal alarm used for loss detection.</dd>
  <dt>alarm_mode:</dt>
  <dd style="margin-left: 8">QUIC maintains a single loss detection alarm, which switches between various modes.  This mode is used to determine the duration of the alarm.</dd>
  <dt>handshake_count:</dt>
  <dd style="margin-left: 8">The number of times the handshake packets have been retransmitted without receiving an ack.</dd>
  <dt>tlp_count:</dt>
  <dd style="margin-left: 8">The number of times a tail loss probe has been sent without receiving an ack.</dd>
  <dt>rto_count:</dt>
  <dd style="margin-left: 8">The number of times an rto has been sent without receiving an ack.</dd>
  <dt>smoothed_rtt:</dt>
  <dd style="margin-left: 8">The smoothed RTT of the connection, computed as described in <a href="#RFC6298">[RFC6298]</a></dd>
  <dt>rttvar:</dt>
  <dd style="margin-left: 8">The RTT variance, computed as described in <a href="#RFC6298">[RFC6298]</a></dd>
  <dt>initial_rtt:</dt>
  <dd style="margin-left: 8">The initial RTT used before any RTT measurements have been made.</dd>
  <dt>reordering_threshold:</dt>
  <dd style="margin-left: 8">The largest delta between the largest acked retransmittable packet and a packet containing retransmittable frames before it&#8217;s declared lost.</dd>
  <dt>use_time_loss:</dt>
  <dd style="margin-left: 8">When true, loss detection operates solely based on reordering threshold in time, rather than in packet number gaps.</dd>
  <dt>sent_packets:</dt>
  <dd style="margin-left: 8">An association of packet numbers to information about them.</dd>
</dl>
<h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#initialization" id="initialization">Initialization</a></h2>
<p id="rfc.section.3.3.p.1">At the beginning of the connection, initialize the loss detection variables as follows:</p>
<pre>
   loss_detection_alarm.reset()
   handshake_count = 0
   tlp_count = 0
   rto_count = 0
   reordering_threshold = kReorderingThreshold
   use_time_loss = false
   smoothed_rtt = 0
   rttvar = 0
   initial_rtt = kDefaultInitialRtt
</pre>
<h2 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#setting-the-loss-detection-alarm" id="setting-the-loss-detection-alarm">Setting the Loss Detection Alarm</a></h2>
<p id="rfc.section.3.4.p.1">QUIC loss detection uses a single alarm for all timer-based loss detection.  The duration of the alarm is based on the alarm&#8217;s mode, which is set in the packet and timer events further below.  The function SetLossDetectionAlarm defined below shows how the single timer is set based on the alarm mode.</p>
<p id="rfc.section.3.4.p.2">Pseudocode for SetLossDetectionAlarm follows:</p>
<pre>
 SetLossDetectionAlarm():
    if (retransmittable packets are not outstanding):
      loss_detection_alarm.cancel()
      return

    if (handshake packets are outstanding):
      // Handshake retransmission alarm.
      alarm_duration = max(1.5 * smoothed_rtt, kMinTLPTimeout)
                         &lt;&lt; handshake_count
      handshake_count++;
    else if (largest sent packet is acked):
      // Early retransmit {{!RFC 5827}}
      // with an alarm to reduce spurious retransmits.
      alarm_duration = 0.25 * smoothed_rtt
    else if (tlp_count &lt; kMaxTLPs):
      // Tail Loss Probe alarm.
      if (retransmittable_packets_outstanding = 1):
        alarm_duration = max(
                           1.5 * smoothed_rtt + kDelayedAckTimeout,
                           2 * smoothed_rtt)
      else:
        alarm_duration = max (kMinTLPTimeout, 2 * smoothed_rtt)
      tlp_count++;
    else:
      // RTO alarm.
      if (rto_count = 0):
        alarm_duration = max(kMinRTOTimeout,
                             smoothed_rtt + 4 * rttvar)
      else:
        alarm_duration = loss_detection_alarm.get_delay() &lt;&lt; 1
      rto_count++

    loss_detection_alarm.set(now + alarm_duration)
</pre>
<h2 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> <a href="#on-sending-a-packet" id="on-sending-a-packet">On Sending a Packet</a></h2>
<p id="rfc.section.3.5.p.1">After any packet is sent, be it a new transmission or a rebundled transmission, the following OnPacketSent function is called.  The parameters to OnPacketSent are as follows:</p>
<p/>

<ul>
  <li>packet_number: The packet number of the sent packet.</li>
  <li>is_retransmittble: A boolean that indicates whether the packet contains at least one frame requiring reliable deliver.  The retransmittability of various QUIC frames is described in <a href="#QUIC-TRANSPORT">[QUIC-TRANSPORT]</a>.  If false, it is still acceptable for an ack to be received for this packet.  However, a caller MUST NOT set is_retransmittable to true if an ack is not expected.</li>
  <li>sent_bytes: The number of bytes sent in the packet.</li>
</ul>
<p id="rfc.section.3.5.p.3">Pseudocode for OnPacketSent follows:</p>
<pre>
 OnPacketSent(packet_number, is_retransmittable, sent_bytes):
   # TODO: Clarify the data in sent_packets.
   sent_packets[packet_number].time = now
   if is_retransmittable:
     sent_packets[packet_number].bytes = sent_bytes
     SetLossDetectionAlarm()
</pre>
<h2 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6.</a> <a href="#on-ack-receipt" id="on-ack-receipt">On Ack Receipt</a></h2>
<p id="rfc.section.3.6.p.1">When an ack is received, it may acknowledge 0 or more packets.</p>
<p id="rfc.section.3.6.p.2">Pseudocode for OnAckReceived and UpdateRtt follow:</p>
<pre>
   OnAckReceived(ack):
     // If the largest acked is newly acked, update the RTT.
     if (sent_packets[ack.largest_acked]):
       rtt_sample = now - sent_packets[ack.largest_acked].time
       if (rtt_sample &gt; ack.ack_delay):
         rtt_sample -= ack.delay
       UpdateRtt(rtt_sample)
     // Find all newly acked packets.
     for acked_packet in DetermineNewlyAckedPackets():
       OnPacketAcked(acked_packet)

     DetectLostPackets(ack.largest_acked_packet)
     SetLossDetectionAlarm()


   UpdateRtt(rtt_sample):
     // Based on {{RFC6298}}.
     if (smoothed_rtt == 0):
       smoothed_rtt = rtt_sample
       rttvar = rtt_sample / 2
     else:
       rttvar = 3/4 * rttvar + 1/4 * (smoothed_rtt - rtt_sample)
       smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * rtt_sample
</pre>
<h2 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7.</a> <a href="#on-packet-acknowledgment" id="on-packet-acknowledgment">On Packet Acknowledgment</a></h2>
<p id="rfc.section.3.7.p.1">When a packet is acked for the first time, the following OnPacketAcked function is called.  Note that a single ACK frame may newly acknowledge several packets.  OnPacketAcked must be called once for each of these newly acked packets.</p>
<p id="rfc.section.3.7.p.2">OnPacketAcked takes one parameter, acked_packet, which is the packet number of the newly acked packet, and returns a list of packet numbers that are detected as lost.</p>
<p id="rfc.section.3.7.p.3">Pseudocode for OnPacketAcked follows:</p>
<pre>
   OnPacketAcked(acked_packet):
     handshake_count = 0
     tlp_count = 0
     rto_count = 0
     # TODO: Don't remove packets immediately, since they can be
     # used for detecting spurous retransmits.
     sent_packets.remove(acked_packet)
</pre>
<h2 id="rfc.section.3.8"><a href="#rfc.section.3.8">3.8.</a> <a href="#setting-the-loss-detection-alarm-1" id="setting-the-loss-detection-alarm-1">Setting the Loss Detection Alarm</a></h2>
<p id="rfc.section.3.8.p.1">QUIC loss detection uses a single alarm for all timer-based loss detection.  The duration of the alarm is based on the alarm&#8217;s mode, which is set in the packet and timer events further below.  The function SetLossDetectionAlarm defined below shows how the single timer is set based on the alarm mode.</p>
<h3 id="rfc.section.3.8.1"><a href="#rfc.section.3.8.1">3.8.1.</a> <a href="#handshake-packets" id="handshake-packets">Handshake Packets</a></h3>
<p id="rfc.section.3.8.1.p.1">The initial flight has no prior RTT sample.  A client SHOULD remember the previous RTT it observed when resumption is attempted and use that for an initial RTT value.  If no previous RTT is available, the initial RTT defaults to 200ms.  Once an RTT measurement is taken, it MUST replace initial_rtt.</p>
<p id="rfc.section.3.8.1.p.2">Endpoints MUST retransmit handshake frames if not acknowledged within a time limit. This time limit will start as the largest of twice the rtt value and MinTLPTimeout.  Each consecutive handshake retransmission doubles the time limit, until an acknowledgement is received.</p>
<p id="rfc.section.3.8.1.p.3">Handshake frames may be cancelled by handshake state transitions.  In particular, all non-protected frames SHOULD be no longer be transmitted once packet protection is available.</p>
<p id="rfc.section.3.8.1.p.4">When stateless rejects are in use, the connection is considered immediately closed once a reject is sent, so no timer is set to retransmit the reject.</p>
<p id="rfc.section.3.8.1.p.5">Version negotiation packets are always stateless, and MUST be sent once per per handshake packet that uses an unsupported QUIC version, and MAY be sent in response to 0RTT packets.</p>
<p id="rfc.section.3.8.1.p.6">(Add sections for early retransmit and TLP/RTO here)</p>
<h3 id="rfc.section.3.8.2"><a href="#rfc.section.3.8.2">3.8.2.</a> <a href="#psuedocode" id="psuedocode">Psuedocode</a></h3>
<p id="rfc.section.3.8.2.p.1">Pseudocode for SetLossDetectionAlarm follows:</p>
<pre>
 SetLossDetectionAlarm():
    if (retransmittable packets are not outstanding):
      loss_detection_alarm.cancel();
      return

    if (handshake packets are outstanding):
      // Handshake retransmission alarm.
      if (smoothed_rtt == 0):
        alarm_duration = 2 * initial_rtt
      else:
        alarm_duration = 2 * smoothed_rtt
      alarm_duration = max(alarm_duration, kMinTLPTimeout)
      alarm_duration = alarm_duration &lt;&lt; handshake_count
      handshake_count++;
    else if (largest sent packet is acked):
      // Early retransmit {{!RFC 5827}}
      // with an alarm to reduce spurious retransmits.
      alarm_duration = 0.25 * smoothed_rtt
    else if (tlp_count &lt; kMaxTLPs):
      // Tail Loss Probe alarm.
      if (retransmittable_packets_outstanding = 1):
        alarm_duration = 1.5 * smoothed_rtt + kDelayedAckTimeout
      else:
        alarm_duration = kMinTLPTimeout
      alarm_duration = max(alarm_duration, 2 * smoothed_rtt)
      tlp_count++
    else:
      // RTO alarm.
      if (rto_count = 0):
        alarm_duration = smoothed_rtt + 4 * rttvar
        alarm_duration = max(alarm_duration, kMinRTOTimeout)
      else:
        alarm_duration = loss_detection_alarm.get_delay() &lt;&lt; 1
      rto_count++

    loss_detection_alarm.set(now + alarm_duration)
</pre>
<h2 id="rfc.section.3.9"><a href="#rfc.section.3.9">3.9.</a> <a href="#on-alarm-firing" id="on-alarm-firing">On Alarm Firing</a></h2>
<p id="rfc.section.3.9.p.1">QUIC uses one loss recovery alarm, which when set, can be in one of several modes.  When the alarm fires, the mode determines the action to be performed.  OnAlarm returns a list of packet numbers that are detected as lost.</p>
<p id="rfc.section.3.9.p.2">Pseudocode for OnAlarm follows:</p>
<pre>
   OnAlarm(acked_packet):
     lost_packets = DetectLostPackets(acked_packet)
     MaybeRetransmit(lost_packets)
     SetLossDetectionAlarm()
</pre>
<h2 id="rfc.section.3.10"><a href="#rfc.section.3.10">3.10.</a> <a href="#detecting-lost-packets" id="detecting-lost-packets">Detecting Lost Packets</a></h2>
<p id="rfc.section.3.10.p.1">Packets in QUIC are only considered lost once a larger packet number is acknowledged.  DetectLostPackets is called every time there is a new largest packet or if the loss detection alarm fires the previous largest acked packet is supplied.</p>
<h3 id="rfc.section.3.10.1"><a href="#rfc.section.3.10.1">3.10.1.</a> <a href="#handshake-packets-1" id="handshake-packets-1">Handshake Packets</a></h3>
<p id="rfc.section.3.10.1.p.1">The receiver MUST ignore unprotected packets that ack protected packets.  The receiver MUST trust protected acks for unprotected packets, however.  Aside from this, loss detection for handshake packets when an ack is processed is identical to other packets.</p>
<h3 id="rfc.section.3.10.2"><a href="#rfc.section.3.10.2">3.10.2.</a> <a href="#psuedocode-1" id="psuedocode-1">Psuedocode</a></h3>
<p id="rfc.section.3.10.2.p.1">DetectLostPackets takes one parameter, acked, which is the largest acked packet, and returns a list of packets detected as lost.</p>
<p id="rfc.section.3.10.2.p.2">Pseudocode for DetectLostPackets follows:</p>
<pre>
   DetectLostPackets(acked):
     lost_packets = {}
     foreach (unacked less than acked):
       time_delta = acked.time_sent - unacked.time_sent
       packet_delta = acked.packet_number - unacked.packet_number
       if (time_delta &gt; kTimeReorderThreshold * smoothed_rtt):
         lost_packets.insert(unacked)
       else if (packet_delta &gt; reordering_threshold)
         lost_packets.insert(unacked)
     return lost_packets
</pre>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#congestion-control" id="congestion-control">Congestion Control</a></h1>
<p id="rfc.section.4.p.1">(describe NewReno-style congestion control for QUIC.) (describe appropriate byte counting.) (define recovery based on packet numbers.) (describe min_rtt based hystart.) (describe how QUIC&#8217;s F-RTO delays reducing CWND until an ack is received.)</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.5.p.1">This document has no IANA actions.  Yet.</p>
<h1 id="rfc.references"><a href="#rfc.references">6.</a> References</h1>
<h2 id="rfc.references.1"><a href="#rfc.references.1">6.1.</a> Normative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="QUIC-TLS">[QUIC-TLS]</b>
      </td>
      <td class="top"><a title="Mozilla">Thomson, M.</a> and <a title="sn3rd">S. Turner</a>, "<a>Using Transport Layer Security (TLS) to Secure QUIC</a>"</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</b>
      </td>
      <td class="top"><a title="Google">Iyengar, J.</a> and <a title="Mozilla">M. Thomson</a>, "<a>QUIC: A UDP-Based Multiplexed and Secure Transport</a>"</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
  </tbody>
</table>
<h2 id="rfc.references.2"><a href="#rfc.references.2">6.2.</a> Informative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.dukkipati-tcpm-tcp-loss-probe">[I-D.dukkipati-tcpm-tcp-loss-probe]</b>
      </td>
      <td class="top"><a>Dukkipati, N.</a>, <a>Cardwell, N.</a>, <a>Cheng, Y.</a> and <a>M. Mathis</a>, "<a href="http://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-loss-probe-01">Tail Loss Probe (TLP): An Algorithm for Fast Recovery of Tail Losses</a>", Internet-Draft draft-dukkipati-tcpm-tcp-loss-probe-01, February 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3782">[RFC3782]</b>
      </td>
      <td class="top"><a>Floyd, S.</a>, <a>Henderson, T.</a> and <a>A. Gurtov</a>, "<a href="http://tools.ietf.org/html/rfc3782">The NewReno Modification to TCP's Fast Recovery Algorithm</a>", RFC 3782, DOI 10.17487/RFC3782, April 2004.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5682">[RFC5682]</b>
      </td>
      <td class="top"><a>Sarolahti, P.</a>, <a>Kojo, M.</a>, <a>Yamamoto, K.</a> and <a>M. Hata</a>, "<a href="http://tools.ietf.org/html/rfc5682">Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP</a>", RFC 5682, DOI 10.17487/RFC5682, September 2009.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5827">[RFC5827]</b>
      </td>
      <td class="top"><a>Allman, M.</a>, <a>Avrachenkov, K.</a>, <a>Ayesta, U.</a>, <a>Blanton, J.</a> and <a>P. Hurtig</a>, "<a href="http://tools.ietf.org/html/rfc5827">Early Retransmit for TCP and Stream Control Transmission Protocol (SCTP)</a>", RFC 5827, DOI 10.17487/RFC5827, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6298">[RFC6298]</b>
      </td>
      <td class="top"><a>Paxson, V.</a>, <a>Allman, M.</a>, <a>Chu, J.</a> and <a>M. Sargent</a>, "<a href="http://tools.ietf.org/html/rfc6298">Computing TCP's Retransmission Timer</a>", RFC 6298, DOI 10.17487/RFC6298, June 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6582">[RFC6582]</b>
      </td>
      <td class="top"><a>Henderson, T.</a>, <a>Floyd, S.</a>, <a>Gurtov, A.</a> and <a>Y. Nishida</a>, "<a href="http://tools.ietf.org/html/rfc6582">The NewReno Modification to TCP's Fast Recovery Algorithm</a>", RFC 6582, DOI 10.17487/RFC6582, April 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6937">[RFC6937]</b>
      </td>
      <td class="top"><a>Mathis, M.</a>, <a>Dukkipati, N.</a> and <a>Y. Cheng</a>, "<a href="http://tools.ietf.org/html/rfc6937">Proportional Rate Reduction for TCP</a>", RFC 6937, DOI 10.17487/RFC6937, May 2013.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> <a href="#change-log" id="change-log">Change Log</a></h1>
<p/>

<ul class="empty">
  <li><strong>RFC Editor&#8217;s Note:</strong>  Please remove this section prior to publication of a final version of this document.</li>
</ul>
<h2 id="rfc.appendix.B.1"><a href="#rfc.appendix.B.1">B.1.</a> <a href="#since-draft-ietf-quic-recovery-00" id="since-draft-ietf-quic-recovery-00">Since draft-ietf-quic-recovery-00:</a></h2>
<p/>

<ul>
  <li>Improved description of constants and ACK behavior</li>
</ul>
<h2 id="rfc.appendix.B.2"><a href="#rfc.appendix.B.2">B.2.</a> <a href="#since-draft-iyengar-quic-loss-recovery-01" id="since-draft-iyengar-quic-loss-recovery-01">Since draft-iyengar-quic-loss-recovery-01:</a></h2>
<p/>

<ul>
  <li>Adopted as base for draft-ietf-quic-recovery.</li>
  <li>Updated authors/editors list.</li>
  <li>Added table of contents.</li>
</ul>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jana Iyengar</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Iyengar</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jri@google.com">jri@google.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ian Swett</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Swett</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ianswett@google.com">ianswett@google.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/quicwg/base-drafts">Fork me on GitHub</a></div></div>
</body>
</html>
